
<!DOCTYPE html>
<html lang="" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>廖锡洪</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="viabcde,"> 
    
    <meta name="author" content="viacbde"> 
    <link rel="alternative" href="atom.xml" title="廖锡洪" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
</head>
</html>
<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">多线程与并发库</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">多线程与并发库</h1>
        <div class="stuff">
            <span>九月 17, 2018</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/java基础/">java基础</a><span class="post-tags-list-count">22</span></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/标签/">标签</a><span class="post-tags-list-count">162</span></li></ul>


        </div>
        <div class="content markdown">
            <h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><strong>死锁</strong></h3><p>当方法1调用时需要的数据被方法2占用 此时方法1等待方法2<br>但方法2的调用需要方法1 此时方法2又等待方法1<br>构成了死锁</p>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a><strong>同步代码块</strong></h3><p>synchronized(this){}<br>这里的this 可以使任意一个类 如public class  sdfsdgjksdjgh{}也可以  </p>
<h3 id="线程安全问题："><a href="#线程安全问题：" class="headerlink" title="线程安全问题："></a><strong>线程安全问题：</strong></h3><p>线程安全问题都是由全局变量及静态变量引起的，定义在方法内部的局部私有变量是没有线程安全与否一说的。 </p>
<h2 id="线程的生命周期的五种状态"><a href="#线程的生命周期的五种状态" class="headerlink" title="线程的生命周期的五种状态"></a><strong>线程的生命周期的五种状态</strong></h2><h3 id="新建（new-Thread）"><a href="#新建（new-Thread）" class="headerlink" title="新建（new Thread）"></a><strong>新建（new Thread）</strong></h3><p>例如：Thread  t1=new Thread();  </p>
<h3 id="就绪（runnable）"><a href="#就绪（runnable）" class="headerlink" title="就绪（runnable）"></a><strong>就绪（runnable）</strong></h3><p>例如：t1.start();<br>线程已经被启动，正在等待被分配给CPU时间片，即此时线程正在就绪队列中排队等候得到CPU资源。</p>
<h3 id="运行（running）"><a href="#运行（running）" class="headerlink" title="运行（running）"></a><strong>运行（running）</strong></h3><p>线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，否则它将一直运行到结束。  </p>
<h3 id="死亡（dead）"><a href="#死亡（dead）" class="headerlink" title="死亡（dead）"></a><strong>死亡（dead）</strong></h3><p>异常终止：调用stop()方法让一个线程终止运行    </p>
<h3 id="堵塞（blocked）"><a href="#堵塞（blocked）" class="headerlink" title="堵塞（blocked）"></a><strong>堵塞（blocked）</strong></h3><p>正在睡眠：用sleep(long t) 方法可使线程进入睡眠。一个睡眠着的线程在指定的时间过去可进入就绪状态。<br>正在等待：调用wait()方法。（调用notify()方法回到就绪状态）<br>被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）  </p>
<h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a><strong>sleep和wait的区别</strong></h3><p>sleep是线程类（Thread）的方法，wait是Object类的方法；<br>sleep不释放对象锁，wait放弃对象锁  </p>
<h3 id="创建线程的2种方法"><a href="#创建线程的2种方法" class="headerlink" title="创建线程的2种方法"></a><strong>创建线程的2种方法</strong></h3><p>运用多态机制 创建Thread的子类对象 thread1 并且覆盖父类的run方法<br>Thread thread = new Thread(){public void run(){}}<br>多态的概念 thread 是 Thrad的一个子类<br>Thread 在start()后调用run()，该run方法 先判断是否有Runable 参数 有则 调用 Runable.run() 没有则往下执行其他代码<br>如果是 子类 覆盖了run() 则不会去找Runable 直接执行子类的run()<br>此时对象可以直接使用start方法启动线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Thread thread1=new Thread() &#123;            </span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while(true) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(500);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(this.getName());</span><br><span class="line">                &#125;               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread1.start();</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package thread;</span><br><span class="line">public class demo_1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        cat c=new cat();</span><br><span class="line">        c.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class cat extends Thread&#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                // TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        System.out.println(&quot;11111&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果是实现runable接口 则需要把对象传入Thread 后<br>对象才可调用run启动线程<br>dog d=new dog();<br>Thread t=new Thread(d);<br>d.run();<br>即覆盖实现了Ruable的类d<br>等价于Thread t=new Thread(new dog().run());<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package thread;</span><br><span class="line">public class demo_2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        dog d=new dog();</span><br><span class="line">        Thread t=new Thread(d);</span><br><span class="line">        d.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class dog implements Runnable&#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                // TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        System.out.println(&quot;11111&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="线程通信-wait-notify"><a href="#线程通信-wait-notify" class="headerlink" title="线程通信 wait() notify()"></a><strong>线程通信 wait() notify()</strong></h2><p><strong>wait() 和 nitify() 方法属于类而非线程独有</strong><br><strong>功能：</strong>实现子线程输出10次 主线程main输出10次 如此循环往复50次<br><strong>思路：</strong>因为子线程先输出 所以子线程的输出逻辑应该在主线程之前,用一个boolean控制子线程和main线程能否开启,各自线程在执行完自己的逻辑后用notify 唤醒其他线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">public class TraditionalThreadCommunication &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    final Business business = new Business();</span><br><span class="line">    //重写一个线程的runable()并启动它</span><br><span class="line">	new Thread(</span><br><span class="line">            new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int i=1;i&lt;=50;i++)&#123;</span><br><span class="line">                        business.sub(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    ).start();</span><br><span class="line">	</span><br><span class="line">    for(int i=1;i&lt;=50;i++)&#123;</span><br><span class="line">        business.main(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//需要同步的代码放在同一个类 由同一个类（锁）控制访问</span><br><span class="line">class Business &#123;</span><br><span class="line">private boolean bShouldSub = true;</span><br><span class="line">public synchronized void sub(int i)&#123;</span><br><span class="line">while(!bShouldSub)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">this.wait();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int j=1;j&lt;=10;j++)&#123;</span><br><span class="line">System.out.println(&quot;sub thread sequence of &quot; + j + &quot;,loop of &quot; + i);</span><br><span class="line">&#125;</span><br><span class="line">bShouldSub = false;</span><br><span class="line">this.notify();</span><br><span class="line">&#125;</span><br><span class="line">  public synchronized void main(int i)&#123;</span><br><span class="line">        while(bShouldSub)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                this.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                // TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=1;j&lt;=10;j++)&#123;</span><br><span class="line">            System.out.println(&quot;main thread sequence of &quot; + j + &quot;,loop of &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">        bShouldSub = true;</span><br><span class="line">        this.notify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="condition-await-和condition-signal"><a href="#condition-await-和condition-signal" class="headerlink" title="condition.await()和condition.signal()"></a><strong>condition.await()和condition.signal()</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">condition.await()和condition.signal()类似于 wait 和notify 但后者只能写在synchornized中 前者只能在lock对象中。且能唤醒指定的线程&gt;&gt;&gt; 详情见三个线程的互相通信</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line">public class ConditionCommunication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Business business = new Business();</span><br><span class="line">        new Thread(</span><br><span class="line">                new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        for(int i=1;i&lt;=50;i++)&#123;</span><br><span class="line">                            business.sub(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        ).start();</span><br><span class="line"></span><br><span class="line">        for(int i=1;i&lt;=50;i++)&#123;</span><br><span class="line">            business.main(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Business &#123;</span><br><span class="line">            Lock lock = new ReentrantLock();</span><br><span class="line">            Condition condition = lock.newCondition();</span><br><span class="line">          private boolean bShouldSub = true;</span><br><span class="line">          public  void sub(int i)&#123;</span><br><span class="line">              lock.lock();</span><br><span class="line">              try&#123;</span><br><span class="line">                  while(!bShouldSub)&#123;</span><br><span class="line">                      try &#123;</span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        // TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                    for(int j=1;j&lt;=10;j++)&#123;</span><br><span class="line">                        System.out.println(&quot;sub thread sequence of &quot; + j + &quot;,loop of &quot; + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                  bShouldSub = false;</span><br><span class="line">                  condition.signal();</span><br><span class="line">              &#125;finally&#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          public  void main(int i)&#123;</span><br><span class="line">              lock.lock();</span><br><span class="line">              try&#123;</span><br><span class="line">                 while(bShouldSub)&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            condition.await();</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                            // TODO Auto-generated catch block</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    for(int j=1;j&lt;=100;j++)&#123;</span><br><span class="line">                        System.out.println(&quot;main thread sequence of &quot; + j + &quot;,loop of &quot; + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    bShouldSub = true;</span><br><span class="line">                    condition.signal();</span><br><span class="line">          &#125;finally&#123;</span><br><span class="line">              lock.unlock();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三个线程互相通信-线程1启动线程2-2启动3-3启动1"><a href="#三个线程互相通信-线程1启动线程2-2启动3-3启动1" class="headerlink" title="三个线程互相通信 线程1启动线程2 2启动3 3启动1"></a><strong>三个线程互相通信 线程1启动线程2 2启动3 3启动1</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">在类中定义三个condictuon</span><br><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line">Condition condition1 = lock.newCondition();</span><br><span class="line">Condition condition2 = lock.newCondition();</span><br><span class="line">Condition condition3 = lock.newCondition();</span><br><span class="line">然后每个方法使用一个condiction</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line">public class ThreeConditionCommunication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Business business = new Business();</span><br><span class="line">        new Thread(</span><br><span class="line">                new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        for(int i=1;i&lt;=50;i++)&#123;</span><br><span class="line">                            business.sub2(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        ).start();</span><br><span class="line">        new Thread(</span><br><span class="line">                new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        for(int i=1;i&lt;=50;i++)&#123;</span><br><span class="line">                            business.sub3(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        ).start();      </span><br><span class="line">        for(int i=1;i&lt;=50;i++)&#123;</span><br><span class="line">            business.main(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class Business &#123;</span><br><span class="line">            Lock lock = new ReentrantLock();</span><br><span class="line">            Condition condition1 = lock.newCondition();</span><br><span class="line">            Condition condition2 = lock.newCondition();</span><br><span class="line">            Condition condition3 = lock.newCondition();</span><br><span class="line">          private int shouldSub = 1;</span><br><span class="line">          public  void sub2(int i)&#123;</span><br><span class="line">              lock.lock();</span><br><span class="line">              try&#123;</span><br><span class="line">                  while(shouldSub != 2)&#123;</span><br><span class="line">                      try &#123;</span><br><span class="line">                        condition2.await();</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        // TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                    for(int j=1;j&lt;=10;j++)&#123;</span><br><span class="line">                        System.out.println(&quot;sub2 thread sequence of &quot; + j + &quot;,loop of &quot; + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                  shouldSub = 3;</span><br><span class="line">                  condition3.signal();</span><br><span class="line">              &#125;finally&#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          public  void sub3(int i)&#123;</span><br><span class="line">              lock.lock();</span><br><span class="line">              try&#123;</span><br><span class="line">                  while(shouldSub != 3)&#123;</span><br><span class="line">                      try &#123;</span><br><span class="line">                        condition3.await();</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        // TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                    for(int j=1;j&lt;=20;j++)&#123;</span><br><span class="line">                        System.out.println(&quot;sub3 thread sequence of &quot; + j + &quot;,loop of &quot; + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                  shouldSub = 1;</span><br><span class="line">                  condition1.signal();</span><br><span class="line">              &#125;finally&#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;       </span><br><span class="line">          public  void main(int i)&#123;</span><br><span class="line">              lock.lock();</span><br><span class="line">              try&#123;</span><br><span class="line">                 while(shouldSub != 1)&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            condition1.await();</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                            // TODO Auto-generated catch block</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    for(int j=1;j&lt;=100;j++)&#123;</span><br><span class="line">                        System.out.println(&quot;main thread sequence of &quot; + j + &quot;,loop of &quot; + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    shouldSub = 2;</span><br><span class="line">                    condition2.signal();</span><br><span class="line">          &#125;finally&#123;</span><br><span class="line">              lock.unlock();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a><strong>线程安全问题</strong></h2><h3 id="适应自旋锁-内核锁-自旋锁"><a href="#适应自旋锁-内核锁-自旋锁" class="headerlink" title="适应自旋锁=内核锁+自旋锁"></a><strong>适应自旋锁=内核锁+自旋锁</strong></h3><p>内核锁就是如果资源被占用就排队，知道别人提醒它资源可用<br>自旋锁就是如果资源被占用，就会间歇性的不断尝试去访问资源<br>2者的折中就是资源被占用，适应一定的策略隔一段时间去请求资源</p>
<h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a><strong>lock</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">lock方法不属于线程 每个类可以使用lock来实现同步</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line">public class LockTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new LockTest().init();</span><br><span class="line">    &#125;</span><br><span class="line">    private void init()&#123;</span><br><span class="line">        final Outputer outputer = new Outputer();</span><br><span class="line">        new Thread(new Runnable()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while(true)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(10);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    outputer.output(&quot;zhangxiaoxiang&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        new Thread(new Runnable()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while(true)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(10);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    outputer.output(&quot;lihuoming&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    static class Outputer&#123;</span><br><span class="line">        Lock lock = new ReentrantLock();</span><br><span class="line">        public void output(String name)&#123;</span><br><span class="line">            int len = name.length();</span><br><span class="line">            lock.lock();</span><br><span class="line">            //用try的原因 防止 syso语句异常 没有解锁 造成死锁</span><br><span class="line">            try&#123;</span><br><span class="line">                for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">                    System.out.print(name.charAt(i));</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;finally&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public synchronized void output2(String name)&#123;</span><br><span class="line">            int len = name.length();</span><br><span class="line">            for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">                    System.out.print(name.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static synchronized void output3(String name)&#123;</span><br><span class="line">            int len = name.length();</span><br><span class="line">            for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">                    System.out.print(name.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a><strong>读写锁</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">读写锁不是属于线程的 而是属于类</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line">public class ReadWriteLockTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Queue3 q3 = new Queue3();</span><br><span class="line">        for(int i=0;i&lt;3;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run()&#123;</span><br><span class="line">                    while(true)&#123;</span><br><span class="line">                        q3.get();                       </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run()&#123;</span><br><span class="line">                    while(true)&#123;</span><br><span class="line">                        q3.put(new Random().nextInt(10000));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;           </span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Queue3&#123;</span><br><span class="line">    private Object data = null;//共享数据，只能有一个线程能写该数据，但可以有多个线程同时读该数据。</span><br><span class="line">    ReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line">    public void get()&#123;</span><br><span class="line">        //读锁 能同时访问 但是 当第一个线程读的时候数据为空</span><br><span class="line">        //则它会解开读锁 再为当前数据加上写锁 其他线程无法访问直至第一个线程从</span><br><span class="line">        //数据库获取到了数据并传入给了该被读取的变量</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; be ready to read data!&quot;);</span><br><span class="line">            Thread.sleep((long)(Math.random()*1000));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;have read data :&quot; + data);           </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void put(Object data)&#123;</span><br><span class="line">        //写锁 不能同时访问</span><br><span class="line">        rwl.writeLock().lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; be ready to write data!&quot;);                  </span><br><span class="line">            Thread.sleep((long)(Math.random()*1000));</span><br><span class="line">            this.data = data;       </span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; have write data: &quot; + data);                 </span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            rwl.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缓存的原理"><a href="#缓存的原理" class="headerlink" title="缓存的原理"></a><strong>缓存的原理</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">缓存的原理 从map里根据key读取数据加读锁</span><br><span class="line">如果map里没有，则解开读锁 加上写锁 从数据库读取并写入缓存 </span><br><span class="line">然后写锁解开 加上读锁</span><br><span class="line">注意：因为可能有多个线程同时运行到 解开读锁这一步 此时不需要都去数据库读取数据 只需读取一次即可 所以仍然需要再次判读是否有线程抢先读取了</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line">public class CacheDemo &#123;</span><br><span class="line">    private Map&lt;String, Object&gt; cache = new HashMap&lt;String, Object&gt;();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    //加锁的原因：如果有多个线程同时访问且当前数据为空 则都会去数据库get 重复执行了</span><br><span class="line">    //如果数据为空 则把读锁解开 把写锁加上 从数据库获取数据后 写锁解开 还原为读锁</span><br><span class="line">    private ReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line">    public  Object getData(String key)&#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        Object value = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            value = cache.get(key);</span><br><span class="line">            if(value == null)&#123;</span><br><span class="line">                rwl.readLock().unlock();</span><br><span class="line">                rwl.writeLock().lock();</span><br><span class="line">                try&#123;</span><br><span class="line">                    //这里再次判断数据是否为空的原因：是因为可能出现多个线程已经执行到了上面的rwl.writeLock().lock();语句</span><br><span class="line">                    //如果没有再次判断，虽然第一个线程已经获取了数据，下一个线程也会再次从数据库获取数据</span><br><span class="line">                    if(value==null)&#123;</span><br><span class="line">                        value = &quot;aaaa&quot;;//实际是去queryDB();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;finally&#123;</span><br><span class="line">                    rwl.writeLock().unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                rwl.readLock().lock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程范围的数据共享（用HashMap版）"><a href="#线程范围的数据共享（用HashMap版）" class="headerlink" title="线程范围的数据共享（用HashMap版）"></a><strong>线程范围的数据共享（用HashMap版）</strong></h3><p>功能：使用HashMap实现仅在单个线程内数据共享<br>思路：把每个线程的线程作为key 数据作为value存入map<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Random;</span><br><span class="line">public class ThreadScopeShareData &#123;</span><br><span class="line">    private static int data = 0;</span><br><span class="line">    private static Map&lt;Thread, Integer&gt; threadData = new HashMap&lt;Thread, Integer&gt;();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(int i=0;i&lt;40;i++)&#123;</span><br><span class="line">            new Thread(new Runnable()&#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                     data = new Random().nextInt();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() </span><br><span class="line">                            + &quot; has put data :&quot; + data);</span><br><span class="line">                    //把每个线程的数据单独保存起来 否则当线程创建后run方法运行一半 </span><br><span class="line">                    //其他线程可能会修改了本线程的数据</span><br><span class="line">                    threadData.put(Thread.currentThread(), data);</span><br><span class="line">                    new A().get();</span><br><span class="line">                    new B().get();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">/*          try &#123;</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                // TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;*/</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class A&#123;</span><br><span class="line">        public void get()&#123;</span><br><span class="line">            int data = threadData.get(Thread.currentThread());</span><br><span class="line">            System.out.println(&quot;A from &quot; + Thread.currentThread().getName() </span><br><span class="line">                    + &quot; get data :&quot; + data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class B&#123;</span><br><span class="line">        public void get()&#123;</span><br><span class="line">            int data = threadData.get(Thread.currentThread());          </span><br><span class="line">            System.out.println(&quot;B from &quot; + Thread.currentThread().getName() </span><br><span class="line">                    + &quot; get data :&quot; + data);</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用ThreadLocal实现线程范围内数据共享"><a href="#使用ThreadLocal实现线程范围内数据共享" class="headerlink" title="使用ThreadLocal实现线程范围内数据共享"></a><strong>使用ThreadLocal实现线程范围内数据共享</strong></h3><p>ThreadLocal在线程结束时便清空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Random;</span><br><span class="line">public class ThreadLocalTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(int i=0;i&lt;2;i++)&#123;</span><br><span class="line">            new Thread(new Runnable()&#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    int data = new Random().nextInt();</span><br><span class="line">                    MyThreadScopeData.getThreadInstance().setName(&quot;name&quot; + data);</span><br><span class="line">                    MyThreadScopeData.getThreadInstance().setAge(data);</span><br><span class="line">                    new A().get();</span><br><span class="line">                    new B().get();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class A&#123;</span><br><span class="line">        public void get()&#123;</span><br><span class="line">                    MyThreadScopeData myData =MyThreadScopeData.getThreadInstance();</span><br><span class="line">            System.out.println(&quot;A from &quot; + Thread.currentThread().getName() </span><br><span class="line">                    + &quot; getMyData: &quot; + myData.getName() + &quot;,&quot; +</span><br><span class="line">                    myData.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class B&#123;</span><br><span class="line">        public void get()&#123;  </span><br><span class="line">            MyThreadScopeData myData = MyThreadScopeData.getThreadInstance();</span><br><span class="line">            System.out.println(&quot;B from &quot; + Thread.currentThread().getName() </span><br><span class="line">                    + &quot; getMyData: &quot; + myData.getName() + &quot;,&quot; +</span><br><span class="line">                    myData.getAge());           </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyThreadScopeData&#123;</span><br><span class="line">    private MyThreadScopeData()&#123;&#125;</span><br><span class="line">    public static /*synchronized*/ MyThreadScopeData getThreadInstance()&#123;</span><br><span class="line">    //该instance保留到当前线程死亡为止 系统自动clear</span><br><span class="line">        MyThreadScopeData instance = map.get();</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new MyThreadScopeData();</span><br><span class="line">            map.set(instance);</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    private static ThreadLocal&lt;MyThreadScopeData&gt; map = new ThreadLocal&lt;MyThreadScopeData&gt;();</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="线程间共享数据"><a href="#线程间共享数据" class="headerlink" title="线程间共享数据"></a><strong>线程间共享数据</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class MultiThreadShareData &#123;</span><br><span class="line">    private static ShareData1 data1 = new ShareData1();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ShareData1 data2 = new ShareData1();</span><br><span class="line">        //自定义的Runable方法，继承了Runable接口</span><br><span class="line">        new Thread(new MyRunnable1(data2)).start();</span><br><span class="line">        new Thread(new MyRunnable2(data2)).start();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line">    class MyRunnable1 implements Runnable&#123;</span><br><span class="line">        private ShareData1 data1;</span><br><span class="line">        public MyRunnable1(ShareData1 data1)&#123;</span><br><span class="line">            this.data1 = data1;</span><br><span class="line">        &#125;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            data1.decrement();          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class MyRunnable2 implements Runnable&#123;</span><br><span class="line">        private ShareData1 data1;</span><br><span class="line">        public MyRunnable2(ShareData1 data1)&#123;</span><br><span class="line">            this.data1 = data1;</span><br><span class="line">        &#125;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            data1.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class ShareData1&#123;</span><br><span class="line">        private int j = 0;</span><br><span class="line">        public synchronized void increment()&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;       </span><br><span class="line">        public synchronized void decrement()&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3种线程池"><a href="#3种线程池" class="headerlink" title="3种线程池"></a><strong>3种线程池</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">只需要调用线程池的excute()方法即可启动线程</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">public class ThreadPoolTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //线程池 自定义每次只能同时执行3个线程</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(3);</span><br><span class="line">        //缓存线程池 可根据需要动态变化 可同时执行的线程数量</span><br><span class="line">        //ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">        //单线程池 线程死亡自动启动另一个线程 保证线程池有线程在运行</span><br><span class="line">        //ExecutorService threadPool = Executors.newSingleThreadExecutor();</span><br><span class="line">        for(int i=1;i&lt;=10;i++)&#123;</span><br><span class="line">            final int task = i;</span><br><span class="line">            threadPool.execute(new Runnable()&#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=1;j&lt;=10;j++)&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Thread.sleep(20);</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            // TODO Auto-generated catch block</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(/*Thread.currentThread().getName() +&quot;  of&quot;+*/&quot; task  &quot;+ task +&quot; has loop  &quot; + j + &quot; times   &quot; );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        //以上代码虽然让线程以启动 但每个线程的run方法在执行的同时 以下的代码也同时执行</span><br><span class="line">        //如果此时调用shutdownNow()方法,很有可能会让执行一半的run方法停止 从而运行时报线程本打断的错误</span><br><span class="line">        //threadPool.shutdownNow();</span><br><span class="line">        //改为调用次方法 当全部线程空闲才关闭线程池</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(&quot;all of 10 tasks have committed! &quot;);</span><br><span class="line"></span><br><span class="line">        //定时器 6s后执行 每个2s执行一次 缺点只能定制几秒以后 可以用目标时间减去此刻时间实现</span><br><span class="line">        Executors.newScheduledThreadPool(3).scheduleAtFixedRate(new Runnable()&#123;</span><br><span class="line">            public void run() &#123;System.out.println(&quot;bombing!&quot;);&#125;</span><br><span class="line">            &#125;,6,2,TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Callable-and-Future"><a href="#Callable-and-Future" class="headerlink" title="Callable and Future"></a><strong>Callable and Future</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast.heima2;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.CompletionService;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.ExecutorCompletionService;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Future;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">public class CallableAndFuture &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //future有什么用 ？等一会取得线程的执行结果</span><br><span class="line">        ExecutorService threadPool =  Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;String&gt; future =</span><br><span class="line">            threadPool.submit(</span><br><span class="line">                new Callable&lt;String&gt;() &#123;</span><br><span class="line">                    public String call() throws Exception &#123;</span><br><span class="line">                        Thread.sleep(2000);</span><br><span class="line">                        return &quot;hello&quot;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        System.out.println(&quot;等待结果&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            //1s之内没有取得结果则报错</span><br><span class="line">            System.out.println(&quot;拿到结果：&quot; + future.get(1000,TimeUnit.SECONDS));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         //对线程池中的线程 先执行完的结果先被获取</span><br><span class="line">        //类似qq农场 那块才熟了收哪块</span><br><span class="line">        ExecutorService threadPool2 =  Executors.newFixedThreadPool(10);</span><br><span class="line">        CompletionService&lt;Integer&gt; completionService = new ExecutorCompletionService&lt;Integer&gt;(threadPool2);</span><br><span class="line">        for(int i=1;i&lt;=10;i++)&#123;</span><br><span class="line">            final int seq = i;</span><br><span class="line">            completionService.submit(new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Integer call() throws Exception &#123;</span><br><span class="line">                    Thread.sleep(new Random().nextInt(5000));</span><br><span class="line">                    return seq;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(</span><br><span class="line">                        completionService.take().get());</span><br><span class="line">            &#125;  catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="控制能同时有几个线程并发Semaphore"><a href="#控制能同时有几个线程并发Semaphore" class="headerlink" title="控制能同时有几个线程并发Semaphore"></a><strong>控制能同时有几个线程并发Semaphore</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">public class SemaphoreTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        final  Semaphore sp = new Semaphore(5);</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            Runnable runnable = new Runnable()&#123;</span><br><span class="line">                    public void run()&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        sp.acquire();</span><br><span class="line">                    &#125; catch (InterruptedException e1) &#123;</span><br><span class="line">                        e1.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + </span><br><span class="line">                            &quot;进入，当前已有&quot; + (5-sp.availablePermits()) + &quot;个并发&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep((long)(Math.random()*10000));</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + </span><br><span class="line">                            &quot;即将离开&quot;);                    </span><br><span class="line">                    sp.release();</span><br><span class="line">                    //下面代码有时候执行不准确，因为其没有和上面的代码合成原子单元</span><br><span class="line">                    System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + </span><br><span class="line">                            &quot;已离开，当前已有&quot; + (3-sp.availablePermits()) + &quot;个并发&quot;);                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            service.execute(runnable);          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="控制只有3个线程同时完成后线程才能继续执行"><a href="#控制只有3个线程同时完成后线程才能继续执行" class="headerlink" title="控制只有3个线程同时完成后线程才能继续执行"></a><strong>控制只有3个线程同时完成后线程才能继续执行</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">控制只有在线程池中3个线程都完成到达cb.wait()时，线程才同时继续运行</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">public class CyclicBarrierTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        final  CyclicBarrier cb = new CyclicBarrier(3);</span><br><span class="line">        for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">            Runnable runnable = new Runnable()&#123;</span><br><span class="line">                    public void run()&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep((long)(Math.random()*10000));  </span><br><span class="line">                        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + </span><br><span class="line">                                &quot;即将到达集合地点1，当前已有&quot; + (cb.getNumberWaiting()+1) + &quot;个已经到达，&quot; + (cb.getNumberWaiting()==2?&quot;都到齐了，继续走啊&quot;:&quot;正在等候&quot;));                 </span><br><span class="line">                        cb.await();</span><br><span class="line">                        Thread.sleep((long)(Math.random()*10000));  </span><br><span class="line">                        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + </span><br><span class="line">                                &quot;即将到达集合地点2，当前已有&quot; + (cb.getNumberWaiting()+1) + &quot;个已经到达，&quot; + (cb.getNumberWaiting()==2?&quot;都到齐了，继续走啊&quot;:&quot;正在等候&quot;));</span><br><span class="line">                        cb.await(); </span><br><span class="line">                        Thread.sleep((long)(Math.random()*10000));  </span><br><span class="line">                        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + </span><br><span class="line">                                &quot;即将到达集合地点3，当前已有&quot; + (cb.getNumberWaiting() + 1) + &quot;个已经到达，&quot; + (cb.getNumberWaiting()==2?&quot;都到齐了，继续走啊&quot;:&quot;正在等候&quot;));                     </span><br><span class="line">                        cb.await();                     </span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;               </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            service.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CountDownLatch的用法"><a href="#CountDownLatch的用法" class="headerlink" title="CountDownLatch的用法"></a><strong>CountDownLatch的用法</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> 使用倒计时器 控制只有被唤几次才会醒</span><br><span class="line">    final CountDownLatch cdOrder = new CountDownLatch(1);</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">public class CountdownLatchTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        //当处于await状态时 需要countDown1次才被唤醒</span><br><span class="line">        final CountDownLatch cdOrder = new CountDownLatch(1);</span><br><span class="line">        //当处于await状态时 需要countDown3次才被唤醒</span><br><span class="line">        final CountDownLatch cdAnswer = new CountDownLatch(3);      </span><br><span class="line">        for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">            Runnable runnable = new Runnable()&#123;</span><br><span class="line">                    public void run()&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + </span><br><span class="line">                                &quot;正准备接受命令&quot;);                     </span><br><span class="line">                        cdOrder.await();</span><br><span class="line">                        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + </span><br><span class="line">                        &quot;已接受命令&quot;);                               </span><br><span class="line">                        Thread.sleep((long)(Math.random()*10000));  </span><br><span class="line">                        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + </span><br><span class="line">                                &quot;回应命令处理结果&quot;);                        </span><br><span class="line">                        cdAnswer.countDown();                       </span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;               </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            service.execute(runnable);</span><br><span class="line">        &#125;       </span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep((long)(Math.random()*10000));</span><br><span class="line">            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + </span><br><span class="line">                    &quot;即将发布命令&quot;);                      </span><br><span class="line">            cdOrder.countDown();</span><br><span class="line">            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + </span><br><span class="line">            &quot;已发送命令，正在等待结果&quot;);    </span><br><span class="line">            cdAnswer.await();</span><br><span class="line">            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + </span><br><span class="line">            &quot;已收到所有响应结果&quot;);   </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;               </span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程间使用Exchanger交换数据"><a href="#线程间使用Exchanger交换数据" class="headerlink" title="线程间使用Exchanger交换数据"></a><strong>线程间使用Exchanger交换数据</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">将数据都放在同一个Exchanger中进行2个线程间的数据交换</span><br><span class="line">import java.util.concurrent.Exchanger;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">public class ExchangerTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        final Exchanger exchanger = new Exchanger();</span><br><span class="line">        service.execute(new Runnable()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;               </span><br><span class="line">                    String data1 = &quot;zxx&quot;;</span><br><span class="line">                    System.out.println(&quot;a线程&quot; + Thread.currentThread().getName() + </span><br><span class="line">                    &quot;正在把数据&quot; + data1 +&quot;换出去&quot;);</span><br><span class="line">                    Thread.sleep((long)(Math.random()*10000));</span><br><span class="line">                    String data2 = (String)exchanger.exchange(data1);</span><br><span class="line">                    System.out.println(&quot;a线程&quot; + Thread.currentThread().getName() + </span><br><span class="line">                    &quot;换回的数据为&quot; + data2);</span><br><span class="line">                &#125;catch(Exception e)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;);</span><br><span class="line">        service.execute(new Runnable()&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;               </span><br><span class="line">                    String data1 = &quot;lhm&quot;;</span><br><span class="line">                    System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + </span><br><span class="line">                    &quot;正在把数据&quot; + data1 +&quot;换出去&quot;);</span><br><span class="line">                    Thread.sleep((long)(Math.random()*10000));                  </span><br><span class="line">                    String data2 = (String)exchanger.exchange(data1);</span><br><span class="line">                    System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + </span><br><span class="line">                    &quot;换回的数据为&quot; + data2);</span><br><span class="line">                &#125;catch(Exception e)&#123;</span><br><span class="line">                &#125;               </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用阻塞队列存取数据"><a href="#使用阻塞队列存取数据" class="headerlink" title="使用阻塞队列存取数据"></a><strong>使用阻塞队列存取数据</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">存数据queue.put(1);</span><br><span class="line">取数据queue.take(）;</span><br><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">public class BlockingQueueTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    //自定义队列能存放3个数据</span><br><span class="line">        final BlockingQueue queue = new ArrayBlockingQueue(3);</span><br><span class="line">        for(int i=0;i&lt;2;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run()&#123;</span><br><span class="line">                    while(true)&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Thread.sleep((long)(Math.random()*1000));</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + &quot;准备放数据!&quot;);                            //放数据</span><br><span class="line">                            queue.put(1);</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + &quot;已经放了数据，&quot; +                           </span><br><span class="line">                                        &quot;队列目前有&quot; + queue.size() + &quot;个数据&quot;);</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                while(true)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //将此处的睡眠时间分别改为100和1000，观察运行结果</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot;准备取数据!&quot;);</span><br><span class="line">                        //取数据</span><br><span class="line">                        queue.take();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot;已经取走数据，&quot; +                           </span><br><span class="line">                                &quot;队列目前有&quot; + queue.size() + &quot;个数据&quot;);                    </span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="阻塞队列的通信"><a href="#阻塞队列的通信" class="headerlink" title="阻塞队列的通信"></a><strong>阻塞队列的通信</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">public class BlockingQueueCommunication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Business business = new Business();</span><br><span class="line">        new Thread(</span><br><span class="line">                new Runnable() &#123;                </span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;                 </span><br><span class="line">                        for(int i=1;i&lt;=5;i++)&#123;</span><br><span class="line">                            business.sub(i);</span><br><span class="line">                        &#125;                       </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        ).start();</span><br><span class="line">        for(int i=1;i&lt;=5;i++)&#123;</span><br><span class="line">            business.main(i);</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">     static class Business &#123;                 </span><br><span class="line">          BlockingQueue&lt;Integer&gt; queue1 = new ArrayBlockingQueue&lt;Integer&gt;(1);</span><br><span class="line">          BlockingQueue&lt;Integer&gt; queue2 = new ArrayBlockingQueue&lt;Integer&gt;(1);</span><br><span class="line">          //匿名构造方法 不能用静态代码块 因为queue1 queue2要在类加载时才初始化</span><br><span class="line">          &#123;</span><br><span class="line">            //  Collections.synchronizedMap(null);</span><br><span class="line">              try &#123;</span><br><span class="line">                  System.out.println(&quot;xxxxxdfsd把vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvsafdsa&quot;);</span><br><span class="line">                queue2.put(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          public   void sub(int i)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    queue1.put(1);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                for(int j=1;j&lt;=10;j++)&#123;</span><br><span class="line">                    System.out.println(&quot;sub：&quot;+i+&quot;[&quot;+1+&quot;]&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //因为queue2里没有数据，所以需要在初始化的时候先把数据放入queue2 才能把数据取出来 </span><br><span class="line">                    queue2.take();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          public   void main(int i)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    queue2.put(1);</span><br><span class="line">                &#125; catch (InterruptedException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                for(int j=1;j&lt;=100;j++)&#123;</span><br><span class="line">                    System.out.println(&quot;main：&quot;+ i+&quot;[&quot;+1+&quot;]&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    queue1.take();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用CopyOnWriteArrayList可以在迭代时移除数据"><a href="#使用CopyOnWriteArrayList可以在迭代时移除数据" class="headerlink" title="使用CopyOnWriteArrayList可以在迭代时移除数据"></a><strong>使用CopyOnWriteArrayList可以在迭代时移除数据</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">如果使用ArrayList 则不能在迭代输出的时候 删除元素 否则 可能会造成死循环</span><br><span class="line">1.如果在移除第一个之后 版本记录号+1 期望版本记录号不变 进入下一次while时，next() 去判断 当前版本号和except版本号不同 throws Exception</span><br><span class="line">2.如果在移除第二个之后 size-1变为2 ,当进入下一次循环 cursor 加1 此时cursor等于2 hasnext 去判断cursor与 size 若相等则 while循环退出 不再读取下一个 （cursor=0指向第一个 =1指向第二个...）</span><br><span class="line">3.如果移除最后一个size由3变为2 再一次进入while hasnext cursor加1变为 3 ，不等于size 继续循环 curosr 继续加 size不变 curosr永远大于size while 永远循环</span><br><span class="line">综上 ArrayList 在迭代时不能移除数据</span><br><span class="line">应使用CopyOnWriteArrayList</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line">public class CollectionModifyExceptionTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Collection&lt;User&gt; users = new CopyOnWriteArrayList&lt;User&gt;();</span><br><span class="line">            //new ArrayList();</span><br><span class="line">        users.add(new User(&quot;张三&quot;,28));   </span><br><span class="line">        users.add(new User(&quot;李四&quot;,25));           </span><br><span class="line">        users.add(new User(&quot;王五&quot;,31));   </span><br><span class="line">        Iterator&lt;User&gt; itrUsers = users.iterator();</span><br><span class="line">        while(itrUsers.hasNext())&#123;</span><br><span class="line">            System.out.println(&quot;aaaa&quot;);</span><br><span class="line">            User user = (User)itrUsers.next();</span><br><span class="line">            if(&quot;李四&quot;.equals(user.getName()))&#123;</span><br><span class="line">                users.remove(user);</span><br><span class="line">                //itrUsers.remove();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(user);               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16条日志交由4个线程分别输出"><a href="#16条日志交由4个线程分别输出" class="headerlink" title="16条日志交由4个线程分别输出"></a><strong>16条日志交由4个线程分别输出</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        final BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;String&gt;(1);</span><br><span class="line">                //创建四个线程 同时去queue里面获取一个日志 即1s获取并打印了4条日志</span><br><span class="line">        for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">            new Thread(new Runnable()&#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    while(true)&#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            String log = queue.take();</span><br><span class="line">                            parseLog(log);</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            // TODO Auto-generated catch block</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;begin:&quot;+(System.currentTimeMillis()/1000));</span><br><span class="line">        /*模拟处理16行日志，下面的代码产生了16个日志对象，当前代码需要运行16秒才能打印完这些日志。</span><br><span class="line">        修改程序代码，开四个线程让这16个对象在4秒钟打完。</span><br><span class="line">        */</span><br><span class="line">        for(int i=0;i&lt;16;i++)&#123;  //这行代码不能改动</span><br><span class="line">            final String log = &quot;&quot;+(i+1);//这行代码不能改动</span><br><span class="line">            &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        queue.put(log);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        // TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    //Test.parseLog(log);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //parseLog方法内部的代码不能改动</span><br><span class="line">    public static void parseLog(String log)&#123;</span><br><span class="line">        System.out.println(log+&quot;:&quot;+(System.currentTimeMillis()/1000));</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><strong>Semaphore</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">import java.util.concurrent.SynchronousQueue;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Semaphore semaphore = new Semaphore(1);</span><br><span class="line">        final SynchronousQueue&lt;String&gt; queue = new SynchronousQueue&lt;String&gt;();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread(new Runnable()&#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123; </span><br><span class="line">                    try &#123;</span><br><span class="line">                        semaphore.acquire();</span><br><span class="line">                        String input = queue.take();</span><br><span class="line">                        String output = TestDo.doSome(input);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+ &quot;:&quot; + output);</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        // TODO Auto-generated catch block</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;begin:&quot;+(System.currentTimeMillis()/1000));</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;  //这行不能改动</span><br><span class="line">            String input = i+&quot;&quot;;  //这行不能改动</span><br><span class="line">            try &#123;</span><br><span class="line">                queue.put(input);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                // TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//不能改动此TestDo类</span><br><span class="line">class TestDo &#123;</span><br><span class="line">    public static String doSome(String input)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        String output = input + &quot;:&quot;+ (System.currentTimeMillis() / 1000);</span><br><span class="line">        return output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><strong>CopyOnWriteArrayList</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">package syn;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line">//不能改动此Test类    </span><br><span class="line">public class Test extends Thread&#123;</span><br><span class="line">    private TestDo testDo;</span><br><span class="line">    private String key;</span><br><span class="line">    private String value;</span><br><span class="line">    public Test(String key,String key2,String value)&#123;</span><br><span class="line">        this.testDo = TestDo.getInstance();</span><br><span class="line">        /*常量&quot;1&quot;和&quot;1&quot;是同一个对象，下面这行代码就是要用&quot;1&quot;+&quot;&quot;的方式产生新的对象，</span><br><span class="line">        以实现内容没有改变，仍然相等（都还为&quot;1&quot;），但对象却不再是同一个的效果*/</span><br><span class="line">        this.key = key+key2; </span><br><span class="line">/*      a = &quot;1&quot;+&quot;&quot;;</span><br><span class="line">        b = &quot;1&quot;+&quot;&quot;</span><br><span class="line">*/</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line">        Test a = new Test(&quot;1&quot;,&quot;&quot;,&quot;1&quot;);</span><br><span class="line">        Test b = new Test(&quot;1&quot;,&quot;&quot;,&quot;2&quot;);</span><br><span class="line">        Test c = new Test(&quot;3&quot;,&quot;&quot;,&quot;3&quot;);</span><br><span class="line">        Test d = new Test(&quot;4&quot;,&quot;&quot;,&quot;4&quot;);</span><br><span class="line">        System.out.println(&quot;begin:&quot;+(System.currentTimeMillis()/1000));</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">        d.start();</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        testDo.doSome(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class TestDo &#123;</span><br><span class="line">    private TestDo() &#123;&#125;</span><br><span class="line">    private static TestDo _instance = new TestDo(); </span><br><span class="line">    public static TestDo getInstance() &#123;</span><br><span class="line">        return _instance;</span><br><span class="line">    &#125;</span><br><span class="line">    //一个线程在迭代时，另一个线程不能对集合进行操作 改用CopyOnWriteArrayList</span><br><span class="line">    //private ArrayList keys = new ArrayList();</span><br><span class="line">    private CopyOnWriteArrayList keys = new CopyOnWriteArrayList();</span><br><span class="line">    public void doSome(Object key, String value) &#123;</span><br><span class="line">        Object o = key;</span><br><span class="line">        //判断集合是否有相同的key 没有则加入 有则将当前的o 改为集合里值和o相同的对象 因为只有对象相同的锁才能访问互斥</span><br><span class="line">        if(!keys.contains(o))&#123;</span><br><span class="line">            keys.add(o);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for(Iterator iter=keys.iterator();iter.hasNext();)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(20);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    // TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                Object oo = iter.next();</span><br><span class="line">                if(oo.equals(o))&#123;</span><br><span class="line">                    o = oo;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized(o)</span><br><span class="line">        // 以大括号内的是需要局部同步的代码，不能改动!</span><br><span class="line">        &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                System.out.println(key+&quot;:&quot;+value + &quot;:&quot;</span><br><span class="line">                        + (System.currentTimeMillis() / 1000));</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用volatile停止线程-而且volatile可以保证flag为系统内存的值而不是缓存里的值，避免了值不一致的情况"><a href="#使用volatile停止线程-而且volatile可以保证flag为系统内存的值而不是缓存里的值，避免了值不一致的情况" class="headerlink" title="使用volatile停止线程,而且volatile可以保证flag为系统内存的值而不是缓存里的值，避免了值不一致的情况"></a><strong>使用volatile停止线程,而且volatile可以保证flag为系统内存的值而不是缓存里的值，避免了值不一致的情况</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread implements Runnable&#123;</span><br><span class="line">	private volatile boolean flag;</span><br><span class="line">	public void stop() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		flag = false;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		while(true) </span><br><span class="line">			System.out.println(&quot;a&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*test*/</span><br><span class="line">public class Test_thread &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		MyThread mt = new MyThread();</span><br><span class="line">		mt.run();</span><br><span class="line">		mt.stop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="/music/1.mp3">
            </audio>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci="55316b017b800ec5c0da" data-cs="fbe9f4aafee144a34ec283ca34c833ad6da91507" data-r="talk" data-o="viacbde" data-a="viabcde" data-d="false">查看评论</div>


    </div>
    
        <div class="side">
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁"><span class="toc-number">1.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步代码块"><span class="toc-number">2.</span> <span class="toc-text">同步代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程安全问题："><span class="toc-number">3.</span> <span class="toc-text">线程安全问题：</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#线程的生命周期的五种状态"><span class="toc-number"></span> <span class="toc-text">线程的生命周期的五种状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#新建（new-Thread）"><span class="toc-number">1.</span> <span class="toc-text">新建（new Thread）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#就绪（runnable）"><span class="toc-number">2.</span> <span class="toc-text">就绪（runnable）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行（running）"><span class="toc-number">3.</span> <span class="toc-text">运行（running）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死亡（dead）"><span class="toc-number">4.</span> <span class="toc-text">死亡（dead）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堵塞（blocked）"><span class="toc-number">5.</span> <span class="toc-text">堵塞（blocked）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep和wait的区别"><span class="toc-number">6.</span> <span class="toc-text">sleep和wait的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建线程的2种方法"><span class="toc-number">7.</span> <span class="toc-text">创建线程的2种方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程通信-wait-notify"><span class="toc-number"></span> <span class="toc-text">线程通信 wait() notify()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#condition-await-和condition-signal"><span class="toc-number"></span> <span class="toc-text">condition.await()和condition.signal()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三个线程互相通信-线程1启动线程2-2启动3-3启动1"><span class="toc-number"></span> <span class="toc-text">三个线程互相通信 线程1启动线程2 2启动3 3启动1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程安全问题"><span class="toc-number"></span> <span class="toc-text">线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#适应自旋锁-内核锁-自旋锁"><span class="toc-number">1.</span> <span class="toc-text">适应自旋锁=内核锁+自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock"><span class="toc-number">2.</span> <span class="toc-text">lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读写锁"><span class="toc-number">3.</span> <span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存的原理"><span class="toc-number">4.</span> <span class="toc-text">缓存的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程范围的数据共享（用HashMap版）"><span class="toc-number">5.</span> <span class="toc-text">线程范围的数据共享（用HashMap版）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用ThreadLocal实现线程范围内数据共享"><span class="toc-number">6.</span> <span class="toc-text">使用ThreadLocal实现线程范围内数据共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程间共享数据"><span class="toc-number">7.</span> <span class="toc-text">线程间共享数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3种线程池"><span class="toc-number">8.</span> <span class="toc-text">3种线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callable-and-Future"><span class="toc-number">9.</span> <span class="toc-text">Callable and Future</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制能同时有几个线程并发Semaphore"><span class="toc-number">10.</span> <span class="toc-text">控制能同时有几个线程并发Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制只有3个线程同时完成后线程才能继续执行"><span class="toc-number">11.</span> <span class="toc-text">控制只有3个线程同时完成后线程才能继续执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch的用法"><span class="toc-number">12.</span> <span class="toc-text">CountDownLatch的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程间使用Exchanger交换数据"><span class="toc-number">13.</span> <span class="toc-text">线程间使用Exchanger交换数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用阻塞队列存取数据"><span class="toc-number">14.</span> <span class="toc-text">使用阻塞队列存取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞队列的通信"><span class="toc-number">15.</span> <span class="toc-text">阻塞队列的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用CopyOnWriteArrayList可以在迭代时移除数据"><span class="toc-number">16.</span> <span class="toc-text">使用CopyOnWriteArrayList可以在迭代时移除数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16条日志交由4个线程分别输出"><span class="toc-number">17.</span> <span class="toc-text">16条日志交由4个线程分别输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Semaphore"><span class="toc-number">18.</span> <span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">19.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用volatile停止线程-而且volatile可以保证flag为系统内存的值而不是缓存里的值，避免了值不一致的情况"><span class="toc-number">20.</span> <span class="toc-text">使用volatile停止线程,而且volatile可以保证flag为系统内存的值而不是缓存里的值，避免了值不一致的情况</span></a></li></ol>
        </li></div>
    
</div>


    </div>
</div>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>