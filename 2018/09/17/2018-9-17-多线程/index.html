<!DOCTYPE HTML>
<html lang="">


<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="keywords" content="多线程与并发库, viabcde">
    <meta name="description" content="死锁当方法1调用时需要的数据被方法2占用 此时方法1等待方法2但方法2的调用需要方法1 此时方法2又等待方法1构成了死锁
同步代码块synchronized(this){}这里的this 可以使任意一个类 如public class  sd">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>多线程与并发库 | 廖锡洪</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/css/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="container">
            <div class="nav-wrapper">
                <div class="brand-logo">
                    <a href="/" class="waves-effect waves-light">
                        
                        <img src="/medias/logo.png" class="logo-img hide-on-small-only">
                        
                        <span class="logo-span">廖锡洪</span>
                    </a>
                </div>
                

<a href="#" data-activates="mobile-nav" class="button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>Index</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>Tags</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>Categories</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>Archives</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>About</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>Friends</span>
        </a>
    </li>
    
    <li>
        <a id="toggleSearch" class="waves-effect waves-light">
            <i id="searchIcon" class="mdi-action-search" title="Search"></i>
        </a>
    </li>

</ul>

<div class="side-nav" id="mobile-nav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">廖锡洪</div>
        <div class="logo-desc">
            
            廖锡洪
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                Index
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                Tags
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                Categories
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                Archives
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                About
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                Friends
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>

    <div class="social-link">
    <a href="https://github.com/viabcde/viabcde.github.io" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:437230257@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=437230257" class="tooltipped" data-tooltip="QQ联系我: 437230257" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>


</div>
</div>

            </div>
        </div>

        
        <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewbox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/>
    </svg>
</a>
        
    </nav>
</header>


<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover post-cover" style="background-image: url('http://pmi6mt23n.bkt.clouddn.com/154.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        多线程与并发库
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="container content">

    
    <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/java基础/" target="_blank">
                                <span class="chip bg-color">java基础</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/java/" class="post-category" target="_blank">
                                java
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2018-09-17
                </div>

                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>Read Count:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><strong>死锁</strong></h3><p>当方法1调用时需要的数据被方法2占用 此时方法1等待方法2<br>但方法2的调用需要方法1 此时方法2又等待方法1<br>构成了死锁</p>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a><strong>同步代码块</strong></h3><p>synchronized(this){}<br>这里的this 可以使任意一个类 如public class  sdfsdgjksdjgh{}也可以  </p>
<h3 id="线程安全问题："><a href="#线程安全问题：" class="headerlink" title="线程安全问题："></a><strong>线程安全问题：</strong></h3><p>线程安全问题都是由全局变量及静态变量引起的，定义在方法内部的局部私有变量是没有线程安全与否一说的。 </p>
<h2 id="线程的生命周期的五种状态"><a href="#线程的生命周期的五种状态" class="headerlink" title="线程的生命周期的五种状态"></a><strong>线程的生命周期的五种状态</strong></h2><h3 id="新建（new-Thread）"><a href="#新建（new-Thread）" class="headerlink" title="新建（new Thread）"></a><strong>新建（new Thread）</strong></h3><p>例如：Thread  t1=new Thread();  </p>
<h3 id="就绪（runnable）"><a href="#就绪（runnable）" class="headerlink" title="就绪（runnable）"></a><strong>就绪（runnable）</strong></h3><p>例如：t1.start();<br>线程已经被启动，正在等待被分配给CPU时间片，即此时线程正在就绪队列中排队等候得到CPU资源。</p>
<h3 id="运行（running）"><a href="#运行（running）" class="headerlink" title="运行（running）"></a><strong>运行（running）</strong></h3><p>线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，否则它将一直运行到结束。  </p>
<h3 id="死亡（dead）"><a href="#死亡（dead）" class="headerlink" title="死亡（dead）"></a><strong>死亡（dead）</strong></h3><p>异常终止：调用stop()方法让一个线程终止运行    </p>
<h3 id="堵塞（blocked）"><a href="#堵塞（blocked）" class="headerlink" title="堵塞（blocked）"></a><strong>堵塞（blocked）</strong></h3><p>正在睡眠：用sleep(long t) 方法可使线程进入睡眠。一个睡眠着的线程在指定的时间过去可进入就绪状态。<br>正在等待：调用wait()方法。（调用notify()方法回到就绪状态）<br>被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）  </p>
<h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a><strong>sleep和wait的区别</strong></h3><p>sleep是线程类（Thread）的方法，wait是Object类的方法；<br>sleep不释放对象锁，wait放弃对象锁  </p>
<h3 id="创建线程的2种方法"><a href="#创建线程的2种方法" class="headerlink" title="创建线程的2种方法"></a><strong>创建线程的2种方法</strong></h3><p>运用多态机制 创建Thread的子类对象 thread1 并且覆盖父类的run方法<br>Thread thread = new Thread(){public void run(){}}<br>多态的概念 thread 是 Thrad的一个子类<br>Thread 在start()后调用run()，该run方法 先判断是否有Runable 参数 有则 调用 Runable.run() 没有则往下执行其他代码<br>如果是 子类 覆盖了run() 则不会去找Runable 直接执行子类的run()<br>此时对象可以直接使用start方法启动线程</p>
<pre><code>Thread thread1=new Thread() {            
            public void run() {
                while(true) {
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(this.getName());
                }               
            }
        };
        thread1.start();
</code></pre><p>或</p>
<pre><code>package thread;
public class demo_1 {
    public static void main(String[] args) {
        cat c=new cat();
        c.start();
    }
}
class cat extends Thread{
    public void run() {
        while(true) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        System.out.println(&quot;11111&quot;);
    }
    }
}
</code></pre><p>如果是实现runable接口 则需要把对象传入Thread 后<br>对象才可调用run启动线程<br>dog d=new dog();<br>Thread t=new Thread(d);<br>d.run();<br>即覆盖实现了Ruable的类d<br>等价于Thread t=new Thread(new dog().run());</p>
<pre><code>package thread;
public class demo_2 {
    public static void main(String[] args) {
        dog d=new dog();
        Thread t=new Thread(d);
        d.run();
    }
}
class dog implements Runnable{
    public void run() {
        while(true) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        System.out.println(&quot;11111&quot;);
    }
    }
}
</code></pre><h2 id="线程通信-wait-notify"><a href="#线程通信-wait-notify" class="headerlink" title="线程通信 wait() notify()"></a><strong>线程通信 wait() notify()</strong></h2><p><strong>wait() 和 nitify() 方法属于类而非线程独有</strong><br><strong>功能：</strong>实现子线程输出10次 主线程main输出10次 如此循环往复50次<br><strong>思路：</strong>因为子线程先输出 所以子线程的输出逻辑应该在主线程之前,用一个boolean控制子线程和main线程能否开启,各自线程在执行完自己的逻辑后用notify 唤醒其他线程  </p>
<pre><code>import java.util.concurrent.atomic.AtomicInteger;
public class TraditionalThreadCommunication {
public static void main(String[] args) {
    final Business business = new Business();
    //重写一个线程的runable()并启动它
    new Thread(
            new Runnable() {
                @Override
                public void run() {
                    for(int i=1;i&lt;=50;i++){
                        business.sub(i);
                    }
                }
            }
    ).start();

    for(int i=1;i&lt;=50;i++){
        business.main(i);
    }
}
}
//需要同步的代码放在同一个类 由同一个类（锁）控制访问
class Business {
private boolean bShouldSub = true;
public synchronized void sub(int i){
while(!bShouldSub){
try {
this.wait();
} catch (InterruptedException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
}
for(int j=1;j&lt;=10;j++){
System.out.println(&quot;sub thread sequence of &quot; + j + &quot;,loop of &quot; + i);
}
bShouldSub = false;
this.notify();
}
  public synchronized void main(int i){
        while(bShouldSub){
            try {
                this.wait();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        for(int j=1;j&lt;=10;j++){
            System.out.println(&quot;main thread sequence of &quot; + j + &quot;,loop of &quot; + i);
        }
        bShouldSub = true;
        this.notify();
  }
}
</code></pre><h2 id="condition-await-和condition-signal"><a href="#condition-await-和condition-signal" class="headerlink" title="condition.await()和condition.signal()"></a><strong>condition.await()和condition.signal()</strong></h2><pre><code>condition.await()和condition.signal()类似于 wait 和notify 但后者只能写在synchornized中 前者只能在lock对象中。且能唤醒指定的线程&gt;&gt;&gt; 详情见三个线程的互相通信
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
public class ConditionCommunication {
    public static void main(String[] args) {
        final Business business = new Business();
        new Thread(
                new Runnable() {
                    @Override
                    public void run() {
                        for(int i=1;i&lt;=50;i++){
                            business.sub(i);
                        }
                    }
                }
        ).start();

        for(int i=1;i&lt;=50;i++){
            business.main(i);
        }
    }
    static class Business {
            Lock lock = new ReentrantLock();
            Condition condition = lock.newCondition();
          private boolean bShouldSub = true;
          public  void sub(int i){
              lock.lock();
              try{
                  while(!bShouldSub){
                      try {
                        condition.await();
                    } catch (Exception e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                  }
                    for(int j=1;j&lt;=10;j++){
                        System.out.println(&quot;sub thread sequence of &quot; + j + &quot;,loop of &quot; + i);
                    }
                  bShouldSub = false;
                  condition.signal();
              }finally{
                  lock.unlock();
              }
          }
          public  void main(int i){
              lock.lock();
              try{
                 while(bShouldSub){
                        try {
                            condition.await();
                        } catch (Exception e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                    }
                    for(int j=1;j&lt;=100;j++){
                        System.out.println(&quot;main thread sequence of &quot; + j + &quot;,loop of &quot; + i);
                    }
                    bShouldSub = true;
                    condition.signal();
          }finally{
              lock.unlock();
          }
      }

    }
}
</code></pre><h2 id="三个线程互相通信-线程1启动线程2-2启动3-3启动1"><a href="#三个线程互相通信-线程1启动线程2-2启动3-3启动1" class="headerlink" title="三个线程互相通信 线程1启动线程2 2启动3 3启动1"></a><strong>三个线程互相通信 线程1启动线程2 2启动3 3启动1</strong></h2><pre><code>思路：
在类中定义三个condictuon
Lock lock = new ReentrantLock();
Condition condition1 = lock.newCondition();
Condition condition2 = lock.newCondition();
Condition condition3 = lock.newCondition();
然后每个方法使用一个condiction
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
public class ThreeConditionCommunication {
    public static void main(String[] args) {
        final Business business = new Business();
        new Thread(
                new Runnable() {
                    @Override
                    public void run() {
                        for(int i=1;i&lt;=50;i++){
                            business.sub2(i);
                        }
                    }
                }
        ).start();
        new Thread(
                new Runnable() {
                    @Override
                    public void run() {
                        for(int i=1;i&lt;=50;i++){
                            business.sub3(i);
                        }
                    }
                }
        ).start();      
        for(int i=1;i&lt;=50;i++){
            business.main(i);
        }
    }
    static class Business {
            Lock lock = new ReentrantLock();
            Condition condition1 = lock.newCondition();
            Condition condition2 = lock.newCondition();
            Condition condition3 = lock.newCondition();
          private int shouldSub = 1;
          public  void sub2(int i){
              lock.lock();
              try{
                  while(shouldSub != 2){
                      try {
                        condition2.await();
                    } catch (Exception e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                  }
                    for(int j=1;j&lt;=10;j++){
                        System.out.println(&quot;sub2 thread sequence of &quot; + j + &quot;,loop of &quot; + i);
                    }
                  shouldSub = 3;
                  condition3.signal();
              }finally{
                  lock.unlock();
              }
          }
          public  void sub3(int i){
              lock.lock();
              try{
                  while(shouldSub != 3){
                      try {
                        condition3.await();
                    } catch (Exception e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                  }
                    for(int j=1;j&lt;=20;j++){
                        System.out.println(&quot;sub3 thread sequence of &quot; + j + &quot;,loop of &quot; + i);
                    }
                  shouldSub = 1;
                  condition1.signal();
              }finally{
                  lock.unlock();
              }
          }       
          public  void main(int i){
              lock.lock();
              try{
                 while(shouldSub != 1){
                        try {
                            condition1.await();
                        } catch (Exception e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                    }
                    for(int j=1;j&lt;=100;j++){
                        System.out.println(&quot;main thread sequence of &quot; + j + &quot;,loop of &quot; + i);
                    }
                    shouldSub = 2;
                    condition2.signal();
          }finally{
              lock.unlock();
          }
      }
    }
}
</code></pre><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a><strong>线程安全问题</strong></h2><h3 id="适应自旋锁-内核锁-自旋锁"><a href="#适应自旋锁-内核锁-自旋锁" class="headerlink" title="适应自旋锁=内核锁+自旋锁"></a><strong>适应自旋锁=内核锁+自旋锁</strong></h3><p>内核锁就是如果资源被占用就排队，知道别人提醒它资源可用<br>自旋锁就是如果资源被占用，就会间歇性的不断尝试去访问资源<br>2者的折中就是资源被占用，适应一定的策略隔一段时间去请求资源</p>
<h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a><strong>lock</strong></h3><pre><code>lock方法不属于线程 每个类可以使用lock来实现同步
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
public class LockTest {
    public static void main(String[] args) {
        new LockTest().init();
    }
    private void init(){
        final Outputer outputer = new Outputer();
        new Thread(new Runnable(){
            @Override
            public void run() {
                while(true){
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    outputer.output(&quot;zhangxiaoxiang&quot;);
                }

            }
        }).start();
        new Thread(new Runnable(){
            @Override
            public void run() {
                while(true){
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    outputer.output(&quot;lihuoming&quot;);
                }
            }
        }).start();
    }
    static class Outputer{
        Lock lock = new ReentrantLock();
        public void output(String name){
            int len = name.length();
            lock.lock();
            //用try的原因 防止 syso语句异常 没有解锁 造成死锁
            try{
                for(int i=0;i&lt;len;i++){
                    System.out.print(name.charAt(i));
                }
                System.out.println();
            }finally{
                lock.unlock();
            }
        }

        public synchronized void output2(String name){
            int len = name.length();
            for(int i=0;i&lt;len;i++){
                    System.out.print(name.charAt(i));
            }
            System.out.println();
        }

        public static synchronized void output3(String name){
            int len = name.length();
            for(int i=0;i&lt;len;i++){
                    System.out.print(name.charAt(i));
            }
            System.out.println();
        }   
    }
}
</code></pre><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a><strong>读写锁</strong></h3><pre><code>读写锁不是属于线程的 而是属于类
import java.util.Random;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
public class ReadWriteLockTest {
    public static void main(String[] args) {
        final Queue3 q3 = new Queue3();
        for(int i=0;i&lt;3;i++)
        {
            new Thread(){
                public void run(){
                    while(true){
                        q3.get();                       
                    }
                }
            }.start();
            new Thread(){
                public void run(){
                    while(true){
                        q3.put(new Random().nextInt(10000));
                    }
                }           
            }.start();
        }

    }
}
class Queue3{
    private Object data = null;//共享数据，只能有一个线程能写该数据，但可以有多个线程同时读该数据。
    ReadWriteLock rwl = new ReentrantReadWriteLock();
    public void get(){
        //读锁 能同时访问 但是 当第一个线程读的时候数据为空
        //则它会解开读锁 再为当前数据加上写锁 其他线程无法访问直至第一个线程从
        //数据库获取到了数据并传入给了该被读取的变量
        rwl.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + &quot; be ready to read data!&quot;);
            Thread.sleep((long)(Math.random()*1000));
            System.out.println(Thread.currentThread().getName() + &quot;have read data :&quot; + data);           
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally{
            rwl.readLock().unlock();
        }
    }
    public void put(Object data){
        //写锁 不能同时访问
        rwl.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + &quot; be ready to write data!&quot;);                  
            Thread.sleep((long)(Math.random()*1000));
            this.data = data;       
            System.out.println(Thread.currentThread().getName() + &quot; have write data: &quot; + data);                 
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally{
            rwl.writeLock().unlock();
        }

    }
}
</code></pre><h3 id="缓存的原理"><a href="#缓存的原理" class="headerlink" title="缓存的原理"></a><strong>缓存的原理</strong></h3><pre><code>缓存的原理 从map里根据key读取数据加读锁
如果map里没有，则解开读锁 加上写锁 从数据库读取并写入缓存 
然后写锁解开 加上读锁
注意：因为可能有多个线程同时运行到 解开读锁这一步 此时不需要都去数据库读取数据 只需读取一次即可 所以仍然需要再次判读是否有线程抢先读取了
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
public class CacheDemo {
    private Map&lt;String, Object&gt; cache = new HashMap&lt;String, Object&gt;();
    public static void main(String[] args) {
    }
    //加锁的原因：如果有多个线程同时访问且当前数据为空 则都会去数据库get 重复执行了
    //如果数据为空 则把读锁解开 把写锁加上 从数据库获取数据后 写锁解开 还原为读锁
    private ReadWriteLock rwl = new ReentrantReadWriteLock();
    public  Object getData(String key){
        rwl.readLock().lock();
        Object value = null;
        try{
            value = cache.get(key);
            if(value == null){
                rwl.readLock().unlock();
                rwl.writeLock().lock();
                try{
                    //这里再次判断数据是否为空的原因：是因为可能出现多个线程已经执行到了上面的rwl.writeLock().lock();语句
                    //如果没有再次判断，虽然第一个线程已经获取了数据，下一个线程也会再次从数据库获取数据
                    if(value==null){
                        value = &quot;aaaa&quot;;//实际是去queryDB();
                    }
                }finally{
                    rwl.writeLock().unlock();
                }
                rwl.readLock().lock();
            }
        }finally{
            rwl.readLock().unlock();
        }
        return value;
    }
}
</code></pre><h3 id="线程范围的数据共享（用HashMap版）"><a href="#线程范围的数据共享（用HashMap版）" class="headerlink" title="线程范围的数据共享（用HashMap版）"></a><strong>线程范围的数据共享（用HashMap版）</strong></h3><p>功能：使用HashMap实现仅在单个线程内数据共享<br>思路：把每个线程的线程作为key 数据作为value存入map</p>
<pre><code>import java.util.HashMap;
import java.util.Map;
import java.util.Random;
public class ThreadScopeShareData {
    private static int data = 0;
    private static Map&lt;Thread, Integer&gt; threadData = new HashMap&lt;Thread, Integer&gt;();
    public static void main(String[] args) {
        for(int i=0;i&lt;40;i++){
            new Thread(new Runnable(){
                @Override
                public void run() {
                     data = new Random().nextInt();
                    System.out.println(Thread.currentThread().getName() 
                            + &quot; has put data :&quot; + data);
                    //把每个线程的数据单独保存起来 否则当线程创建后run方法运行一半 
                    //其他线程可能会修改了本线程的数据
                    threadData.put(Thread.currentThread(), data);
                    new A().get();
                    new B().get();
                }
            }).start();
/*          try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }*/
        }
    }
    static class A{
        public void get(){
            int data = threadData.get(Thread.currentThread());
            System.out.println(&quot;A from &quot; + Thread.currentThread().getName() 
                    + &quot; get data :&quot; + data);
        }
    }
    static class B{
        public void get(){
            int data = threadData.get(Thread.currentThread());          
            System.out.println(&quot;B from &quot; + Thread.currentThread().getName() 
                    + &quot; get data :&quot; + data);
        }       
    }
}
</code></pre><h3 id="使用ThreadLocal实现线程范围内数据共享"><a href="#使用ThreadLocal实现线程范围内数据共享" class="headerlink" title="使用ThreadLocal实现线程范围内数据共享"></a><strong>使用ThreadLocal实现线程范围内数据共享</strong></h3><p>ThreadLocal在线程结束时便清空</p>
<pre><code>import java.util.HashMap;
import java.util.Map;
import java.util.Random;
public class ThreadLocalTest {
    public static void main(String[] args) {
        for(int i=0;i&lt;2;i++){
            new Thread(new Runnable(){
                @Override
                public void run() {
                    int data = new Random().nextInt();
                    MyThreadScopeData.getThreadInstance().setName(&quot;name&quot; + data);
                    MyThreadScopeData.getThreadInstance().setAge(data);
                    new A().get();
                    new B().get();
                }
            }).start();
        }
    }

    static class A{
        public void get(){
                    MyThreadScopeData myData =MyThreadScopeData.getThreadInstance();
            System.out.println(&quot;A from &quot; + Thread.currentThread().getName() 
                    + &quot; getMyData: &quot; + myData.getName() + &quot;,&quot; +
                    myData.getAge());
        }
    }
    static class B{
        public void get(){  
            MyThreadScopeData myData = MyThreadScopeData.getThreadInstance();
            System.out.println(&quot;B from &quot; + Thread.currentThread().getName() 
                    + &quot; getMyData: &quot; + myData.getName() + &quot;,&quot; +
                    myData.getAge());           
        }       
    }
}
class MyThreadScopeData{
    private MyThreadScopeData(){}
    public static /*synchronized*/ MyThreadScopeData getThreadInstance(){
    //该instance保留到当前线程死亡为止 系统自动clear
        MyThreadScopeData instance = map.get();
        if(instance == null){
            instance = new MyThreadScopeData();
            map.set(instance);
        }
        return instance;
    }
    private static ThreadLocal&lt;MyThreadScopeData&gt; map = new ThreadLocal&lt;MyThreadScopeData&gt;();

    private String name;
    private int age;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
}
</code></pre><h3 id="线程间共享数据"><a href="#线程间共享数据" class="headerlink" title="线程间共享数据"></a><strong>线程间共享数据</strong></h3><pre><code>public class MultiThreadShareData {
    private static ShareData1 data1 = new ShareData1();
    public static void main(String[] args) {
        ShareData1 data2 = new ShareData1();
        //自定义的Runable方法，继承了Runable接口
        new Thread(new MyRunnable1(data2)).start();
        new Thread(new MyRunnable2(data2)).start();     
    }
}   
    class MyRunnable1 implements Runnable{
        private ShareData1 data1;
        public MyRunnable1(ShareData1 data1){
            this.data1 = data1;
        }
        public void run() {
            data1.decrement();          
        }
    }
    class MyRunnable2 implements Runnable{
        private ShareData1 data1;
        public MyRunnable2(ShareData1 data1){
            this.data1 = data1;
        }
        public void run() {
            data1.increment();
        }
    }
    class ShareData1{
        private int j = 0;
        public synchronized void increment(){
            j++;
        }       
        public synchronized void decrement(){
            j--;
        }
    }
</code></pre><h3 id="3种线程池"><a href="#3种线程池" class="headerlink" title="3种线程池"></a><strong>3种线程池</strong></h3><pre><code>只需要调用线程池的excute()方法即可启动线程
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
public class ThreadPoolTest {
    public static void main(String[] args) {
        //线程池 自定义每次只能同时执行3个线程
        ExecutorService threadPool = Executors.newFixedThreadPool(3);
        //缓存线程池 可根据需要动态变化 可同时执行的线程数量
        //ExecutorService threadPool = Executors.newCachedThreadPool();
        //单线程池 线程死亡自动启动另一个线程 保证线程池有线程在运行
        //ExecutorService threadPool = Executors.newSingleThreadExecutor();
        for(int i=1;i&lt;=10;i++){
            final int task = i;
            threadPool.execute(new Runnable(){
                @Override
                public void run() {
                    for(int j=1;j&lt;=10;j++){
                        try {
                            Thread.sleep(20);
                        } catch (InterruptedException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                        System.out.println(/*Thread.currentThread().getName() +&quot;  of&quot;+*/&quot; task  &quot;+ task +&quot; has loop  &quot; + j + &quot; times   &quot; );
                    }
                }
            });
        }
        //以上代码虽然让线程以启动 但每个线程的run方法在执行的同时 以下的代码也同时执行
        //如果此时调用shutdownNow()方法,很有可能会让执行一半的run方法停止 从而运行时报线程本打断的错误
        //threadPool.shutdownNow();
        //改为调用次方法 当全部线程空闲才关闭线程池
        threadPool.shutdown();
        System.out.println(&quot;all of 10 tasks have committed! &quot;);

        //定时器 6s后执行 每个2s执行一次 缺点只能定制几秒以后 可以用目标时间减去此刻时间实现
        Executors.newScheduledThreadPool(3).scheduleAtFixedRate(new Runnable(){
            public void run() {System.out.println(&quot;bombing!&quot;);}
            },6,2,TimeUnit.SECONDS);
    }
}
</code></pre><h3 id="Callable-and-Future"><a href="#Callable-and-Future" class="headerlink" title="Callable and Future"></a><strong>Callable and Future</strong></h3><pre><code>package cn.itcast.heima2;
import java.util.Random;
import java.util.concurrent.Callable;
import java.util.concurrent.CompletionService;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorCompletionService;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
public class CallableAndFuture {
    public static void main(String[] args) {
        //future有什么用 ？等一会取得线程的执行结果
        ExecutorService threadPool =  Executors.newSingleThreadExecutor();
        Future&lt;String&gt; future =
            threadPool.submit(
                new Callable&lt;String&gt;() {
                    public String call() throws Exception {
                        Thread.sleep(2000);
                        return &quot;hello&quot;;
                    };
                }
        );
        System.out.println(&quot;等待结果&quot;);
        try {
            //1s之内没有取得结果则报错
            System.out.println(&quot;拿到结果：&quot; + future.get(1000,TimeUnit.SECONDS));
        } catch (Exception e) {
            e.printStackTrace();
        }
         //对线程池中的线程 先执行完的结果先被获取
        //类似qq农场 那块才熟了收哪块
        ExecutorService threadPool2 =  Executors.newFixedThreadPool(10);
        CompletionService&lt;Integer&gt; completionService = new ExecutorCompletionService&lt;Integer&gt;(threadPool2);
        for(int i=1;i&lt;=10;i++){
            final int seq = i;
            completionService.submit(new Callable&lt;Integer&gt;() {
                @Override
                public Integer call() throws Exception {
                    Thread.sleep(new Random().nextInt(5000));
                    return seq;
                }
            });
        }
        for(int i=0;i&lt;10;i++){
            try {
                System.out.println(
                        completionService.take().get());
            }  catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre><h3 id="控制能同时有几个线程并发Semaphore"><a href="#控制能同时有几个线程并发Semaphore" class="headerlink" title="控制能同时有几个线程并发Semaphore"></a><strong>控制能同时有几个线程并发Semaphore</strong></h3><pre><code>import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;
public class SemaphoreTest {
    public static void main(String[] args) {
        ExecutorService service = Executors.newCachedThreadPool();
        final  Semaphore sp = new Semaphore(5);
        for(int i=0;i&lt;10;i++){
            Runnable runnable = new Runnable(){
                    public void run(){
                    try {
                        sp.acquire();
                    } catch (InterruptedException e1) {
                        e1.printStackTrace();
                    }
                    System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + 
                            &quot;进入，当前已有&quot; + (5-sp.availablePermits()) + &quot;个并发&quot;);
                    try {
                        Thread.sleep((long)(Math.random()*10000));
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + 
                            &quot;即将离开&quot;);                    
                    sp.release();
                    //下面代码有时候执行不准确，因为其没有和上面的代码合成原子单元
                    System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + 
                            &quot;已离开，当前已有&quot; + (3-sp.availablePermits()) + &quot;个并发&quot;);                    
                }
            };
            service.execute(runnable);          
        }
    }
}
</code></pre><h3 id="控制只有3个线程同时完成后线程才能继续执行"><a href="#控制只有3个线程同时完成后线程才能继续执行" class="headerlink" title="控制只有3个线程同时完成后线程才能继续执行"></a><strong>控制只有3个线程同时完成后线程才能继续执行</strong></h3><pre><code>控制只有在线程池中3个线程都完成到达cb.wait()时，线程才同时继续运行
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public class CyclicBarrierTest {
    public static void main(String[] args) {
        ExecutorService service = Executors.newCachedThreadPool();
        final  CyclicBarrier cb = new CyclicBarrier(3);
        for(int i=0;i&lt;3;i++){
            Runnable runnable = new Runnable(){
                    public void run(){
                    try {
                        Thread.sleep((long)(Math.random()*10000));  
                        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + 
                                &quot;即将到达集合地点1，当前已有&quot; + (cb.getNumberWaiting()+1) + &quot;个已经到达，&quot; + (cb.getNumberWaiting()==2?&quot;都到齐了，继续走啊&quot;:&quot;正在等候&quot;));                 
                        cb.await();
                        Thread.sleep((long)(Math.random()*10000));  
                        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + 
                                &quot;即将到达集合地点2，当前已有&quot; + (cb.getNumberWaiting()+1) + &quot;个已经到达，&quot; + (cb.getNumberWaiting()==2?&quot;都到齐了，继续走啊&quot;:&quot;正在等候&quot;));
                        cb.await(); 
                        Thread.sleep((long)(Math.random()*10000));  
                        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + 
                                &quot;即将到达集合地点3，当前已有&quot; + (cb.getNumberWaiting() + 1) + &quot;个已经到达，&quot; + (cb.getNumberWaiting()==2?&quot;都到齐了，继续走啊&quot;:&quot;正在等候&quot;));                     
                        cb.await();                     
                    } catch (Exception e) {
                        e.printStackTrace();
                    }               
                }
            };
            service.execute(runnable);
        }
        service.shutdown();
    }
}
</code></pre><h3 id="CountDownLatch的用法"><a href="#CountDownLatch的用法" class="headerlink" title="CountDownLatch的用法"></a><strong>CountDownLatch的用法</strong></h3><pre><code> 使用倒计时器 控制只有被唤几次才会醒
    final CountDownLatch cdOrder = new CountDownLatch(1);
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public class CountdownLatchTest {
    public static void main(String[] args) {
        ExecutorService service = Executors.newCachedThreadPool();
        //当处于await状态时 需要countDown1次才被唤醒
        final CountDownLatch cdOrder = new CountDownLatch(1);
        //当处于await状态时 需要countDown3次才被唤醒
        final CountDownLatch cdAnswer = new CountDownLatch(3);      
        for(int i=0;i&lt;3;i++){
            Runnable runnable = new Runnable(){
                    public void run(){
                    try {
                        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + 
                                &quot;正准备接受命令&quot;);                     
                        cdOrder.await();
                        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + 
                        &quot;已接受命令&quot;);                               
                        Thread.sleep((long)(Math.random()*10000));  
                        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + 
                                &quot;回应命令处理结果&quot;);                        
                        cdAnswer.countDown();                       
                    } catch (Exception e) {
                        e.printStackTrace();
                    }               
                }
            };
            service.execute(runnable);
        }       
        try {
            Thread.sleep((long)(Math.random()*10000));
            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + 
                    &quot;即将发布命令&quot;);                      
            cdOrder.countDown();
            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + 
            &quot;已发送命令，正在等待结果&quot;);    
            cdAnswer.await();
            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + 
            &quot;已收到所有响应结果&quot;);   
        } catch (Exception e) {
            e.printStackTrace();
        }               
        service.shutdown();
    }
}
</code></pre><h3 id="线程间使用Exchanger交换数据"><a href="#线程间使用Exchanger交换数据" class="headerlink" title="线程间使用Exchanger交换数据"></a><strong>线程间使用Exchanger交换数据</strong></h3><pre><code>将数据都放在同一个Exchanger中进行2个线程间的数据交换
import java.util.concurrent.Exchanger;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public class ExchangerTest {
    public static void main(String[] args) {
        ExecutorService service = Executors.newCachedThreadPool();
        final Exchanger exchanger = new Exchanger();
        service.execute(new Runnable(){
            public void run() {
                try {               
                    String data1 = &quot;zxx&quot;;
                    System.out.println(&quot;a线程&quot; + Thread.currentThread().getName() + 
                    &quot;正在把数据&quot; + data1 +&quot;换出去&quot;);
                    Thread.sleep((long)(Math.random()*10000));
                    String data2 = (String)exchanger.exchange(data1);
                    System.out.println(&quot;a线程&quot; + Thread.currentThread().getName() + 
                    &quot;换回的数据为&quot; + data2);
                }catch(Exception e){
                }
            }   
        });
        service.execute(new Runnable(){
            public void run() {
                try {               
                    String data1 = &quot;lhm&quot;;
                    System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + 
                    &quot;正在把数据&quot; + data1 +&quot;换出去&quot;);
                    Thread.sleep((long)(Math.random()*10000));                  
                    String data2 = (String)exchanger.exchange(data1);
                    System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + 
                    &quot;换回的数据为&quot; + data2);
                }catch(Exception e){
                }               
            }   
        });     
    }
}
</code></pre><h3 id="使用阻塞队列存取数据"><a href="#使用阻塞队列存取数据" class="headerlink" title="使用阻塞队列存取数据"></a><strong>使用阻塞队列存取数据</strong></h3><pre><code>存数据queue.put(1);
取数据queue.take(）;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
public class BlockingQueueTest {
    public static void main(String[] args) {
    //自定义队列能存放3个数据
        final BlockingQueue queue = new ArrayBlockingQueue(3);
        for(int i=0;i&lt;2;i++){
            new Thread(){
                public void run(){
                    while(true){
                        try {
                            Thread.sleep((long)(Math.random()*1000));
                            System.out.println(Thread.currentThread().getName() + &quot;准备放数据!&quot;);                            //放数据
                            queue.put(1);
                            System.out.println(Thread.currentThread().getName() + &quot;已经放了数据，&quot; +                           
                                        &quot;队列目前有&quot; + queue.size() + &quot;个数据&quot;);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }.start();
        }
        new Thread(){
            public void run(){
                while(true){
                    try {
                        //将此处的睡眠时间分别改为100和1000，观察运行结果
                        Thread.sleep(1000);
                        System.out.println(Thread.currentThread().getName() + &quot;准备取数据!&quot;);
                        //取数据
                        queue.take();
                        System.out.println(Thread.currentThread().getName() + &quot;已经取走数据，&quot; +                           
                                &quot;队列目前有&quot; + queue.size() + &quot;个数据&quot;);                    
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }.start();          
    }
}
</code></pre><h3 id="阻塞队列的通信"><a href="#阻塞队列的通信" class="headerlink" title="阻塞队列的通信"></a><strong>阻塞队列的通信</strong></h3><pre><code>import java.util.Collections;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;
public class BlockingQueueCommunication {
    public static void main(String[] args) {
        final Business business = new Business();
        new Thread(
                new Runnable() {                
                    @Override
                    public void run() {                 
                        for(int i=1;i&lt;=5;i++){
                            business.sub(i);
                        }                       
                    }
                }
        ).start();
        for(int i=1;i&lt;=5;i++){
            business.main(i);
        }       
    }
     static class Business {                 
          BlockingQueue&lt;Integer&gt; queue1 = new ArrayBlockingQueue&lt;Integer&gt;(1);
          BlockingQueue&lt;Integer&gt; queue2 = new ArrayBlockingQueue&lt;Integer&gt;(1);
          //匿名构造方法 不能用静态代码块 因为queue1 queue2要在类加载时才初始化
          {
            //  Collections.synchronizedMap(null);
              try {
                  System.out.println(&quot;xxxxxdfsd把vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvsafdsa&quot;);
                queue2.put(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
          }
          public   void sub(int i){
                try {
                    queue1.put(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                for(int j=1;j&lt;=10;j++){
                    System.out.println(&quot;sub：&quot;+i+&quot;[&quot;+1+&quot;]&quot;);
                }
                try {
                    //因为queue2里没有数据，所以需要在初始化的时候先把数据放入queue2 才能把数据取出来 
                    queue2.take();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
          }
          public   void main(int i){
                try {
                    queue2.put(1);
                } catch (InterruptedException e1) {
                    e1.printStackTrace();
                }
                for(int j=1;j&lt;=100;j++){
                    System.out.println(&quot;main：&quot;+ i+&quot;[&quot;+1+&quot;]&quot;);
                }
                try {
                    queue1.take();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
          }
      }
}
</code></pre><h3 id="使用CopyOnWriteArrayList可以在迭代时移除数据"><a href="#使用CopyOnWriteArrayList可以在迭代时移除数据" class="headerlink" title="使用CopyOnWriteArrayList可以在迭代时移除数据"></a><strong>使用CopyOnWriteArrayList可以在迭代时移除数据</strong></h3><pre><code>如果使用ArrayList 则不能在迭代输出的时候 删除元素 否则 可能会造成死循环
1.如果在移除第一个之后 版本记录号+1 期望版本记录号不变 进入下一次while时，next() 去判断 当前版本号和except版本号不同 throws Exception
2.如果在移除第二个之后 size-1变为2 ,当进入下一次循环 cursor 加1 此时cursor等于2 hasnext 去判断cursor与 size 若相等则 while循环退出 不再读取下一个 （cursor=0指向第一个 =1指向第二个...）
3.如果移除最后一个size由3变为2 再一次进入while hasnext cursor加1变为 3 ，不等于size 继续循环 curosr 继续加 size不变 curosr永远大于size while 永远循环
综上 ArrayList 在迭代时不能移除数据
应使用CopyOnWriteArrayList
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.concurrent.CopyOnWriteArrayList;
public class CollectionModifyExceptionTest {
    public static void main(String[] args) {
        Collection&lt;User&gt; users = new CopyOnWriteArrayList&lt;User&gt;();
            //new ArrayList();
        users.add(new User(&quot;张三&quot;,28));   
        users.add(new User(&quot;李四&quot;,25));           
        users.add(new User(&quot;王五&quot;,31));   
        Iterator&lt;User&gt; itrUsers = users.iterator();
        while(itrUsers.hasNext()){
            System.out.println(&quot;aaaa&quot;);
            User user = (User)itrUsers.next();
            if(&quot;李四&quot;.equals(user.getName())){
                users.remove(user);
                //itrUsers.remove();
            } else {
                System.out.println(user);               
            }
        }
    }
}    
</code></pre><h3 id="16条日志交由4个线程分别输出"><a href="#16条日志交由4个线程分别输出" class="headerlink" title="16条日志交由4个线程分别输出"></a><strong>16条日志交由4个线程分别输出</strong></h3><pre><code>import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class Test {

    public static void main(String[] args){
        final BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;String&gt;(1);
                //创建四个线程 同时去queue里面获取一个日志 即1s获取并打印了4条日志
        for(int i=0;i&lt;4;i++){
            new Thread(new Runnable(){
                @Override
                public void run() {
                    while(true){
                        try {
                            String log = queue.take();
                            parseLog(log);
                        } catch (InterruptedException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                    }
                }
            }).start();
        }
        System.out.println(&quot;begin:&quot;+(System.currentTimeMillis()/1000));
        /*模拟处理16行日志，下面的代码产生了16个日志对象，当前代码需要运行16秒才能打印完这些日志。
        修改程序代码，开四个线程让这16个对象在4秒钟打完。
        */
        for(int i=0;i&lt;16;i++){  //这行代码不能改动
            final String log = &quot;&quot;+(i+1);//这行代码不能改动
            {
                    try {
                        queue.put(log);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    //Test.parseLog(log);
            }
        }
    }
    //parseLog方法内部的代码不能改动
    public static void parseLog(String log){
        System.out.println(log+&quot;:&quot;+(System.currentTimeMillis()/1000));
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }       
    }
}
</code></pre><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><strong>Semaphore</strong></h3><pre><code>import java.util.concurrent.Semaphore;
import java.util.concurrent.SynchronousQueue;

public class Test {

    public static void main(String[] args) {
        final Semaphore semaphore = new Semaphore(1);
        final SynchronousQueue&lt;String&gt; queue = new SynchronousQueue&lt;String&gt;();
        for(int i=0;i&lt;10;i++){
            new Thread(new Runnable(){
                @Override
                public void run() { 
                    try {
                        semaphore.acquire();
                        String input = queue.take();
                        String output = TestDo.doSome(input);
                        System.out.println(Thread.currentThread().getName()+ &quot;:&quot; + output);
                        semaphore.release();
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }   
                }
            }).start();
        }
        System.out.println(&quot;begin:&quot;+(System.currentTimeMillis()/1000));
        for(int i=0;i&lt;10;i++){  //这行不能改动
            String input = i+&quot;&quot;;  //这行不能改动
            try {
                queue.put(input);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
}
//不能改动此TestDo类
class TestDo {
    public static String doSome(String input){
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        String output = input + &quot;:&quot;+ (System.currentTimeMillis() / 1000);
        return output;
    }
}
</code></pre><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><strong>CopyOnWriteArrayList</strong></h3><pre><code>package syn;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.concurrent.CopyOnWriteArrayList;
//不能改动此Test类    
public class Test extends Thread{
    private TestDo testDo;
    private String key;
    private String value;
    public Test(String key,String key2,String value){
        this.testDo = TestDo.getInstance();
        /*常量&quot;1&quot;和&quot;1&quot;是同一个对象，下面这行代码就是要用&quot;1&quot;+&quot;&quot;的方式产生新的对象，
        以实现内容没有改变，仍然相等（都还为&quot;1&quot;），但对象却不再是同一个的效果*/
        this.key = key+key2; 
/*      a = &quot;1&quot;+&quot;&quot;;
        b = &quot;1&quot;+&quot;&quot;
*/
        this.value = value;
    }
    public static void main(String[] args) throws InterruptedException{
        Test a = new Test(&quot;1&quot;,&quot;&quot;,&quot;1&quot;);
        Test b = new Test(&quot;1&quot;,&quot;&quot;,&quot;2&quot;);
        Test c = new Test(&quot;3&quot;,&quot;&quot;,&quot;3&quot;);
        Test d = new Test(&quot;4&quot;,&quot;&quot;,&quot;4&quot;);
        System.out.println(&quot;begin:&quot;+(System.currentTimeMillis()/1000));
        a.start();
        b.start();
        c.start();
        d.start();
    }
    public void run(){
        testDo.doSome(key, value);
    }
}
class TestDo {
    private TestDo() {}
    private static TestDo _instance = new TestDo(); 
    public static TestDo getInstance() {
        return _instance;
    }
    //一个线程在迭代时，另一个线程不能对集合进行操作 改用CopyOnWriteArrayList
    //private ArrayList keys = new ArrayList();
    private CopyOnWriteArrayList keys = new CopyOnWriteArrayList();
    public void doSome(Object key, String value) {
        Object o = key;
        //判断集合是否有相同的key 没有则加入 有则将当前的o 改为集合里值和o相同的对象 因为只有对象相同的锁才能访问互斥
        if(!keys.contains(o)){
            keys.add(o);
        }else{
            for(Iterator iter=keys.iterator();iter.hasNext();){
                try {
                    Thread.sleep(20);
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                Object oo = iter.next();
                if(oo.equals(o)){
                    o = oo;
                    break;
                }
            }
        }
        synchronized(o)
        // 以大括号内的是需要局部同步的代码，不能改动!
        {
            try {
                Thread.sleep(1000);
                System.out.println(key+&quot;:&quot;+value + &quot;:&quot;
                        + (System.currentTimeMillis() / 1000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

}
</code></pre><h3 id="使用volatile停止线程-而且volatile可以保证flag为系统内存的值而不是缓存里的值，避免了值不一致的情况"><a href="#使用volatile停止线程-而且volatile可以保证flag为系统内存的值而不是缓存里的值，避免了值不一致的情况" class="headerlink" title="使用volatile停止线程,而且volatile可以保证flag为系统内存的值而不是缓存里的值，避免了值不一致的情况"></a><strong>使用volatile停止线程,而且volatile可以保证flag为系统内存的值而不是缓存里的值，避免了值不一致的情况</strong></h3><pre><code>public class MyThread implements Runnable{
    private volatile boolean flag;
    public void stop() {
        // TODO Auto-generated method stub
        flag = false;
    }
    @Override
    public void run() {
        // TODO Auto-generated method stub
        while(true) 
            System.out.println(&quot;a&quot;);
    }
}
/*test*/
public class Test_thread {
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        MyThread mt = new MyThread();
        mt.run();
        mt.stop();
    }
}
</code></pre>
            </div>
            <hr>

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff;
        background-color: #22AB38;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff;
        background-color: #019FE8;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a class="reward-link btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs">
                        <li class="tab wechat-tab waves-effect waves-light"><a class="active" href="#wechat">微信</a></li>
                        <li class="tab alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                    </ul>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('#reward .reward-link').on('click', function () {
            $('#rewardModal').openModal();
        });

        $('#rewardModal .close').on('click', function () {
            $('#rewardModal').closeModal();
        });
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone, qq, weibo, douban"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            <div class="reprint">
                <p>
                    <span class="reprint-tip">
                        <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;Reprint please specify:
                    </span>
                    <a href="http://viabcde.github.io" class="b-link-green">廖锡洪</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/2018/09/17/2018-9-17-多线程/" class="b-link-green">多线程与并发库</a>
                </p>
            </div>
        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2018/09/17/2018-9-17-类库/">
                    <div class="card-image">
                        
                        <img src="http://pmi6mt23n.bkt.clouddn.com/153.jpg" class="responsive-img" alt="常用类库">
                        
                        <span class="card-title">常用类库</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">                                            
Java类库概念：Java的应用程序接口(API)以包的形式来组织，每个包提供了大量的相关类、接口和异常处理类，这些包的集合就是Java的类库

包名</div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2018-09-17
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/java/" class="post-category" target="_blank">
                                    java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/java基础/" target="_blank">
                        <span class="chip bg-color">java基础</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2018/09/17/2018-9-18-Shell脚本/">
                    <div class="card-image">
                        
                        <img src="http://pmi6mt23n.bkt.clouddn.com/145.gif" class="responsive-img" alt="Linux与Shell脚本编程">
                        
                        <span class="card-title">Linux与Shell脚本编程</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">Linux内核的功能①系统内存管理  
②软件程序管理  
③硬件设备管理  
④文件系统管理  
GNU coreutils软件包由三部分构成：用以处理文件、操作文本、管理进程的工具GNU/Linux shell是一种特殊的交互式工具。它</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2018-09-17
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/java/" class="post-category" target="_blank">
                                    java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Linux/" target="_blank">
                        <span class="chip bg-color">Linux</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            本站由&copy;<a href="https://blinkfox.github.io/" target="_blank">Blinkfox</a>基于
            <a href="https://hexo.io/" target="_blank">Hexo</a> 的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">hexo-theme-matery</a>主题搭建.

            

            
			
                <br>
                
                <span id="busuanzi_container_site_pv">
                    <i class="fa fa-heart-o"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
                
                
                <span id="busuanzi_container_site_uv">
                    <i class="fa fa-users"></i>
                    次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
                
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/viabcde/viabcde.github.io" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:437230257@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=437230257" class="tooltipped" data-tooltip="QQ联系我: 437230257" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>


</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword" class="search-input" autofocus>
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/js/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->



    <script src="/libs/others/clicklove.js"></script>


    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"search":null,"path":"search.xml","field":"post","log":false});</script></body>
</html>