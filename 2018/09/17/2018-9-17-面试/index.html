
<!DOCTYPE html>
<html lang="" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>廖锡洪</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="viabcde,"> 
    
    <meta name="author" content="viacbde"> 
    <link rel="alternative" href="atom.xml" title="廖锡洪" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
</head>
</html>
<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">Java</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">Java</h1>
        <div class="stuff">
            <span>九月 17, 2018</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/java基础/">java基础</a><span class="post-tags-list-count">22</span></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/标签/">标签</a><span class="post-tags-list-count">162</span></li></ul>


        </div>
        <div class="content markdown">
            <h3 id="什么是虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#什么是虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="什么是虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a><strong>什么是虚拟机？为什么Java被称作是“平台无关的编程语言”？</strong></h3><p>虚拟机可以将java字节码解析成机器可识别的0101二进制文件<br>java由编译器一次编译成clas文件能在各个装有虚拟机的平台运行  </p>
<h3 id="JDK-和-JRE-的区别是什么？"><a href="#JDK-和-JRE-的区别是什么？" class="headerlink" title="JDK 和 JRE 的区别是什么？"></a><strong>JDK 和 JRE 的区别是什么？</strong></h3><p>JRE是java运行环境，主要就是虚拟机<br>JDK包括JRE、编译器和其他工具  </p>
<h3 id="static关键字-Java中是否可以覆盖-override-一个private或者是static的方法？"><a href="#static关键字-Java中是否可以覆盖-override-一个private或者是static的方法？" class="headerlink" title="static关键字,Java中是否可以覆盖(override)一个private或者是static的方法？"></a><strong><code>static</code>关键字,Java中是否可以覆盖(override)一个private或者是static的方法？</strong></h3><p>static 和private编译时绑定成静态绑定：<br>就是在编译期间就已经加载到了内存，包括private、static、final修饰的变量和方法，还有构造函数，都是静态绑定<br>而覆盖是在运行时动态绑定的  </p>
<h3 id="是否可以在static环境中访问非static变量？"><a href="#是否可以在static环境中访问非static变量？" class="headerlink" title="是否可以在static环境中访问非static变量？"></a><strong>是否可以在static环境中访问非static变量？</strong></h3><p>不可以 因为static在类加载时就初始化了，而此时非static的还没加载，会报错  </p>
<h3 id="什么是自动拆装箱？"><a href="#什么是自动拆装箱？" class="headerlink" title="什么是自动拆装箱？"></a><strong>什么是自动拆装箱？</strong></h3><p>自动装箱和拆箱就是基本类型和引用类型之间的转换，至于为什么要转换，因为基本类型转换为引用类型后，就可以new对象，从而调用包装类中封装好的方法进行基本类型之间的转换或者toString（当然用类名直接调用也可以，便于一眼看出该方法是静态的），还有就是如果集合中想存放基本类型，泛型的限定类型只能是对应的包装类型。</p>
<h3 id="Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？"><a href="#Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？" class="headerlink" title="Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？"></a><strong>Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</strong></h3><p>Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。  </p>
<h3 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a><strong>接口和抽象类的区别是什么？</strong></h3><p>三个方面 关键字 方法  成员变量 其他  </p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a><strong>关键字</strong></h3><p>接口是对某一功能的抽象  关键字interface  无方法体（java9之后才有）implements后所有的方法必须实现   接口是最顶级的抽象 其变量只能是static final 即常量<br>抽象类是对某一事物的抽象  关键字abstract  有方法体 有抽象和非抽象方法 extends后不一定要实现所有方法  抽象类可以是任意类型的变量<br>类单继承 接口多实现    </p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a><strong>双亲委派模型</strong></h3><p>当类加载器需要加载class文件时会一层往一层去询问父类加载器能不能加载这个class文件，只有询问到最顶层父类后，才开始从父类往下找有能力加载该文件的加载器 </p>
<h3 id="在JDK1-4中引入了一个NIO的类库，使得Java涉及IO的操作拥有阻塞式和非阻塞式两种，问一下阻塞IO与非阻塞IO有什么区别？有什么优缺点？"><a href="#在JDK1-4中引入了一个NIO的类库，使得Java涉及IO的操作拥有阻塞式和非阻塞式两种，问一下阻塞IO与非阻塞IO有什么区别？有什么优缺点？" class="headerlink" title="在JDK1.4中引入了一个NIO的类库，使得Java涉及IO的操作拥有阻塞式和非阻塞式两种，问一下阻塞IO与非阻塞IO有什么区别？有什么优缺点？"></a><strong>在JDK1.4中引入了一个NIO的类库，使得Java涉及IO的操作拥有阻塞式和非阻塞式两种，问一下阻塞IO与非阻塞IO有什么区别？有什么优缺点？</strong></h3><p>// 答案如下：<br>// 1. 在阻塞模式下，若从网络中读取不到指定大小的数据量，阻塞IO就在那里阻塞着。比如，后面已经有10个字节的数据发过来，但是假如现在只收到8个字节，那么当前线程就在那傻傻地等待下一个字节的到来，直到把这10个字节读取完，这才将阻塞放开通行。<br>// 2. 在非阻塞模式下，若从网络流中读取不到指定大小的数据量，非阻塞IO就立即通行。比如，后面已经有10个字节的数据发过来，但是我现在只收到8个字节，那么当前线程就读取这8个字节的数据，读完后就立即返回，等另外两个字节来的时候再去读取。<br>// 3. 从上面可以看出，阻塞IO在性能方面是很低下的，如果要使用阻塞IO完成一个Web服务器的话，那么对于每一个请求都必须启用一个线程进行处理。而使用非阻塞IO的话，一到两个线程基本上就够了，因为线程不会产生阻塞，好比一下接收A请求的数据，另一下接收B请求的数据，等等，就是不停的东奔西跑，直接到把数据接收完了。<br>// 4. 虽然说，非阻塞IO比阻塞IO有更高的性能，但是对于开发来说，难度就成数倍递增了。由于是有多少数据就读取多少数据，这样在读取完整之前需要将已经读取到的数据保存起来，而且需要与其他地方来的数据隔离开来不能混在一起，否则就不知道这数据是谁的了。  </p>
<h2 id="————————————-试题————————————————"><a href="#————————————-试题————————————————" class="headerlink" title="————————————-试题————————————————"></a><strong>————————————-试题————————————————</strong></h2><p>下面都是我自己的答案非官方，仅供参考，如果有疑问或错误请一定要提出来，大家一起进步啦~~~<br><strong>下面哪些是Thread类的方法（）</strong><br>A start()       B run()       C exit()       D getPriority()<br>答案：ABD<br>解析：看Java API docs吧：<a href="http://docs.oracle.com/javase/7/docs/api/，exit()是System类的方法，如System.exit(0)。" target="_blank" rel="noopener">http://docs.oracle.com/javase/7/docs/api/，exit()是System类的方法，如System.exit(0)。</a><br><strong>下面关于java.lang.Exception类的说法正确的是（）</strong><br>A 继承自Throwable      B Serialable      CD 不记得，反正不正确<br>答案：A<br>解析：Java异常的基类为java.lang.Throwable，java.lang.Error和java.lang.Exception继承 Throwable，RuntimeException和其它的Exception等继承Exception，具体的RuntimeException继承RuntimeException。<br>扩展：错误和异常的区别(Error vs Exception)<br>java.lang.Error: Throwable的子类，用于标记严重错误。合理的应用程序不应该去try/catch这种错误。绝大多数的错误都是非正常的，就根本不该出现的。<br>java.lang.Exception: Throwable的子类，用于指示一种合理的程序想去catch的条件。即它仅仅是一种程序运行条件，而非严重错误，并且鼓励用户程序去catch它。<br>Error和RuntimeException 及其子类都是未检查的异常（unchecked exceptions），而所有其他的Exception类都是检查了的异常（checked exceptions）.<br>checked exceptions: 通常是从一个可以恢复的程序中抛出来的，并且最好能够从这种异常中使用程序恢复。比如FileNotFoundException,    ParseException等。检查了的异常发生在编译阶段，必须要使用try…catch（或者throws）否则编译不通过。<br>unchecked exceptions: 通常是如果一切正常的话本不该发生的异常，但是的确发生了。发生在运行期，具有不确定性，主要是由于程序的逻辑问题所引起的。比如ArrayIndexOutOfBoundException, ClassCastException等。从语言本身的角度讲，程序不该去catch这类异常，虽然能够从诸如RuntimeException这样的异常中catch并恢复，但是并不鼓励终端程序员这么做，因为完全没要必要。因为这类错误本身就是bug，应该被修复，出现此类错误时程序就应该立即停止执行。 因此，面对Errors和unchecked exceptions应该让程序自动终止执行，程序员不该做诸如try/catch这样的事情，而是应该查明原因，修改代码逻辑。<br>RuntimeException：RuntimeException体系包括错误的类型转换、数组越界访问和试图访问空指针等等。<br>处理RuntimeException的原则是：如果出现 RuntimeException，那么一定是程序员的错误。例如，可以通过检查数组下标和数组边界来避免数组越界访问异常。其他（IOException等等）checked异常一般是外部错误，例如试图从文件尾后读取数据等，这并不是程序本身的错误，而是在应用环境中出现的外部错误。<br><strong>下面程序的运行结果是（）</strong><br>String str1 = “hello”;<br>String str2 = “he” + new String(“llo”);<br>System.err.println(str1 == str2);<br>答案：false<br>解析：因为str2中的llo是新申请的内存块，而==判断的是对象的地址而非值，所以不一样。如果是String str2 = str1，那么就是true了。<br><strong>下列说法正确的有（）</strong><br>A． class中的constructor不可省略<br>B． constructor必须与class同名，但方法不能与class同名<br>C． constructor在一个对象被new时执行<br>D．一个class只能定义一个constructor<br>答案：C<br>解析：这里可能会有误区，其实普通的类方法是可以和类名同名的，和构造方法唯一的区分就是，构造方法没有返回值。<br><strong>具体选项不记得，但用到的知识如下：</strong>       </p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> []a = <span class="keyword">new</span> <span class="built_in">String</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>则：<code>a[0]~a[9] = null</code><br>a.length = 10<br>如果是<code>int []a = new int[10];</code><br>则：<code>a[0]~a[9] = 0</code><br>a.length = 10<br><strong>下面程序的运行结果：（）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">        Thread t = new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                pong();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.run();</span><br><span class="line">        System.out.print(&quot;ping&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static void pong() &#123;</span><br><span class="line">        System.out.print(&quot;pong&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>A pingpong        B pongping       C pingpong和pongping都有可能       D 都不输出<br>答案：B<br>解析：这里考的是Thread类中start()和run()方法的区别了。start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程，进而调用run()方法来执行任务，而单独的调用run()就跟调用普通方法是一样的，已经失去线程的特性了。因此在启动一个线程的时候一定要使用start()而不是run()。<br><strong>下列属于关系型数据库的是（）</strong><br>A. Oracle    B MySql    C IMS     D MongoDB<br>答案：AB<br>解答：IMS（Information Management System ）数据库是IBM公司开发的两种数据库类型之一;<br>一种是关系数据库，典型代表产品：DB2；<br>另一种则是层次数据库，代表产品：IMS层次数据库。<br>非关系型数据库有MongoDB、memcachedb、Redis等。<br><strong>GC线程是否为守护线程？（）</strong><br>答案：是<br>解析：线程分为守护线程和非守护线程（即用户线程）。<br>只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。<br>守护线程最典型的应用就是 GC (垃圾回收器)<br><strong>volatile关键字是否能保证线程安全？（）</strong><br>答案：不能<br>解析：volatile关键字用在多线程同步中，可保证读取的可见性，JVM只是保证从主内存加载到线程工作内存的值是最新的读取值，而非cache中。但多个线程对<br>volatile的写操作，无法保证线程安全。例如假如线程1，线程2 在进行read,load 操作中，发现主内存中count的值都是5，那么都会加载这个最新的值，在线程1堆count进行修改之后，会write到主内存中，主内存中的count变量就会变为6；线程2由于已经进行read,load操作，在进行运算之后，也会更新主内存count的变量值为6；导致两个线程及时用volatile关键字修改之后，还是会存在并发的情况。<br><strong>下列说法正确的是（）</strong><br>A LinkedList继承自List<br>B AbstractSet继承自Set<br>C HashSet继承自AbstractSet<br>D WeakMap继承自HashMap<br>答案：AC<br>解析：下面是一张下载的Java中的集合类型的继承关系图，一目了然。<br><strong>存在使i + 1 &lt; i的数吗（）</strong>    </p>
<p>答案：存在<br>解析：如果i为int型，那么当i为int能表示的最大整数时，i+1就溢出变成负数了，此时不就&lt;i了吗。<br>扩展：存在使i &gt; j || i &lt;= j不成立的数吗（）<br>答案：存在<br>解析：比如Double.NaN或Float.NaN，感谢@BuilderQiu网友指出。<br><strong>0.6332的数据类型是（）</strong><br>A float     B double     C Float      D Double<br>答案：B<br>解析：默认为double型，如果为float型需要加上f显示说明，即0.6332f<br><strong>下面哪个流类属于面向字符的输入流(  )</strong><br>A  BufferedWriter           B  FileInputStream          C  ObjectInputStream          D  InputStreamReader<br> 答案：D<br> 解析：Java的IO操作中有面向字节(Byte)和面向字符(Character)两种方式。<br> 面向字节的操作为以8位为单位对二进制的数据进行操作，对数据不进行转换，这些类都是InputStream和OutputStream的子类。<br> 面向字符的操作为以字符为单位对数据进行操作，在读的时候将二进制数据转为字符，在写的时候将字符转为二进制数据，这些类都是Reader和Writer的子类。<br>总结：以InputStream（输入）/OutputStream（输出）为后缀的是字节流；<br>          以Reader（输入）/Writer（输出）为后缀的是字符流。<br>扩展：Java流类图结构，一目了然，解决大部分选择题：<br><strong>Java接口的修饰符可以为（）</strong><br>A private     B protected     C final       D abstract<br>答案：CD<br>解析：接口很重要，为了说明情况，这里稍微啰嗦点：<br>（1）接口用于描述系统对外提供的所有服务,因此接口中的成员常量和方法都必须是公开(public)类型的,确保外部使用者能访问它们；<br>（2）接口仅仅描述系统能做什么,但不指明如何去做,所以接口中的方法都是抽象(abstract)方法；<br>（3）接口不涉及和任何具体实例相关的细节,因此接口没有构造方法,不能被实例化,没有实例变量，只有静态（static）变量；<br>（4）接口的中的变量是所有实现类共有的，既然共有，肯定是不变的东西，因为变化的东西也不能够算共有。所以变量是不可变(final)类型，也就是常量了。<br>（5） 接口中不可以定义变量？如果接口可以定义变量，但是接口中的方法又都是抽象的，在接口中无法通过行为来修改属性。有的人会说了，没有关系，可以通过 实现接口的对象的行为来修改接口中的属性。这当然没有问题，但是考虑这样的情况。如果接口 A 中有一个public 访问权限的静态变量 a。按照 Java 的语义，我们可以不通过实现接口的对象来访问变量 a，通过 A.a = xxx; 就可以改变接口中的变量 a 的值了。正如抽象类中是可以这样做的，那么实现接口 A 的所有对象也都会自动拥有这一改变后的 a 的值了，也就是说一个地方改变了 a，所有这些对象中 a 的值也都跟着变了。这和抽象类有什么区别呢，怎么体现接口更高的抽象级别呢，怎么体现接口提供的统一的协议呢，那还要接口这种抽象来做什么呢？所以接口中 不能出现变量，如果有变量，就和接口提供的统一的抽象这种思想是抵触的。所以接口中的属性必然是常量，只能读不能改，这样才能为实现接口的对象提供一个统 一的属性。<br>通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现 implements）开放，接口是对开闭原则的一种体现。<br>所以：<br>接口的方法默认是public abstract；<br>接口中不可以定义变量即只能定义常量(加上final修饰就会变成常量)。所以接口的属性默认是public static final 常量，且必须赋初值。<br>注意：final和abstract不能同时出现。<br><strong>不通过构造函数也能创建对象吗（）</strong><br>A 是     B 否<br>答案：A<br>解析：Java创建对象的几种方式（重要）：<br>(1) 用new语句创建对象，这是最常见的创建对象的方法。<br>(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。<br>(3) 调用对象的clone()方法。<br>(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。<br>(1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用构造函数。<br><strong>ArrayList list = new ArrayList(20);中的list扩充几次（）</strong><br>A 0     B 1     C 2      D 3<br>答案：A<br>解析：这里有点迷惑人，大家都知道默认ArrayList的长度是10个，所以如果你要往list里添加20个元素肯定要扩充一次（扩充为原来的1.5倍），但是这里显示指明了需要多少空间，所以就一次性为你分配这么多空间，也就是不需要扩充了。<br><strong>下面哪些是对称加密算法（）</strong><br>A DES   B AES   C DSA   D RSA<br>答案：AB<br>解析：常用的对称加密算法有：DES、3DES、RC2、RC4、AES<br>常用的非对称加密算法有：RSA、DSA、ECC<br>使用单向散列函数的加密算法：MD5、SHA<br>18.新建一个流对象，下面哪个选项的代码是错误的？（）<br>A）new BufferedWriter(new FileWriter(“a.txt”));<br>B）new BufferedReader(new FileInputStream(“a.dat”));<br>C）new GZIPOutputStream(new FileOutputStream(“a.zip”));<br>D）new ObjectInputStream(new FileInputStream(“a.dat”));<br>答案：B<br>解析：请记得13题的那个图吗？Reader只能用FileReader进行实例化。<br><strong>下面程序能正常运行吗（）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class NULL &#123;</span><br><span class="line">    public static void haha()&#123;</span><br><span class="line">        System.out.println(&quot;haha&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ((NULL)null).haha();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>答案：能正常运行<br>解析：输出为haha，因为null值可以强制转换为任何java类类型,(String)null也是合法的。但null强制转换后是无效对象，其返回值还是为null，而static方法的调用是和类名绑定的，不借助对象进行访问所以能正确输出。反过来，没有static修饰就只能用对象进行访问，使用null调用对象肯定会报空指针错了。这里和C++很类似。这里感谢@Florian网友解答。<br><strong>下面程序的运行结果是什么（）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class HelloA &#123;</span><br><span class="line">    public HelloA() &#123;</span><br><span class="line">        System.out.println(&quot;HelloA&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123; System.out.println(&quot;I&apos;m A class&quot;); &#125;</span><br><span class="line">    static &#123; System.out.println(&quot;static A&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class HelloB extends HelloA &#123;</span><br><span class="line">    public HelloB() &#123;</span><br><span class="line">        System.out.println(&quot;HelloB&quot;);</span><br><span class="line">    &#125;    </span><br><span class="line">    &#123; System.out.println(&quot;I&apos;m B class&quot;); &#125;    </span><br><span class="line">    static &#123; System.out.println(&quot;static B&quot;); &#125;    </span><br><span class="line">    public static void main(String[] args) &#123; </span><br><span class="line">　　　　 new HelloB(); </span><br><span class="line">　　 &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">答案：   </span><br><span class="line">static A   </span><br><span class="line">static B   </span><br><span class="line">I&apos;m A class    </span><br><span class="line">HelloA   </span><br><span class="line">I&apos;m B class   </span><br><span class="line">HelloB   </span><br><span class="line">解析：说实话我觉得这题很好，考查静态语句块、构造语句块（就是只有大括号的那块）以及构造函数的执行顺序。    </span><br><span class="line">对象的初始化顺序：（1）类加载之后，按从上到下（从父类到子类）执行被static修饰的语句；（2）当static语句执行完之后,再执行main方法；（3）如果有语句new了自身的对象，将从上到下执行构造代码块、构造器（两者可以说绑定在一起）。    </span><br><span class="line">下面稍微修改下上面的代码，以便更清晰的说明情况：    </span><br><span class="line">View Code    </span><br><span class="line">此时输出结果为：   </span><br><span class="line">``` </span><br><span class="line">static A</span><br><span class="line">static B</span><br><span class="line">-------main start-------</span><br><span class="line">I&apos;m A class</span><br><span class="line">HelloA</span><br><span class="line">I&apos;m B class</span><br><span class="line">HelloB</span><br><span class="line">I&apos;m A class</span><br><span class="line">HelloA</span><br><span class="line">I&apos;m B class</span><br><span class="line">HelloB</span><br><span class="line">-------main end-------</span><br></pre></td></tr></table></figure></p>
<p><strong>getCustomerInfo()方法如下，try中可以捕获三种类型的异常，如果在该方法运行中产生了一个IOException，将会输出什么结果（）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void getCustomerInfo() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // do something that may cause an Exception</span><br><span class="line">    &#125; catch (java.io.FileNotFoundException ex) &#123;</span><br><span class="line">        System.out.print(&quot;FileNotFoundException!&quot;);</span><br><span class="line">    &#125; catch (java.io.IOException ex) &#123;</span><br><span class="line">        System.out.print(&quot;IOException!&quot;);</span><br><span class="line">    &#125; catch (java.lang.Exception ex) &#123;</span><br><span class="line">        System.out.print(&quot;Exception!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>A IOException!<br>BIOException!Exception!<br>CFileNotFoundException!IOException!<br>DFileNotFoundException!IOException!Exception!<br>答案：A<br>解析：考察多个catch语句块的执行顺序。当用多个catch语句时，catch语句块在次序上有先后之分。从最前面的catch语句块依次先后进行异常类型匹配，这样如果父异常在子异常类之前，那么首先匹配的将是父异常类，子异常类将不会获得匹配的机会，也即子异常类型所在的catch语句块将是不可到达的语句。所以，一般将父类异常类即Exception老大放在catch语句块的最后一个。<br><strong>下面代码的运行结果为：（）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line">public class foo&#123;</span><br><span class="line">    public static void main (String[] args)&#123;</span><br><span class="line">        String s;</span><br><span class="line">        System.out.println(&quot;s=&quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>A 代码得到编译，并输出“s=”<br>B 代码得到编译，并输出“s=null”<br>C 由于String s没有初始化，代码不能编译通过<br>D 代码得到编译，但捕获到 NullPointException异常<br>答案：C<br>解析：开始以为会输出null什么的，运行后才发现Java中所有定义的基本类型或对象都必须初始化才能输出值。<br>  <strong>System.out.println(“5” + 2);的输出结果应该是（）。</strong><br>A 52                   B7                     C2                     D5<br>答案：A<br>解析：没啥好说的，Java会自动将2转换为字符串。<br> <strong>指出下列程序运行的结果 （）</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    String str = new String(&quot;good&quot;);</span><br><span class="line">    char[] ch = &#123; &apos;a&apos;, &apos;b&apos;, &apos;c&apos; &#125;;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Example ex = new Example();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.print(ex.str + &quot; and &quot;);</span><br><span class="line">        System.out.print(ex.ch);</span><br><span class="line">    &#125;</span><br><span class="line">    public void change(String str, char ch[]) &#123;</span><br><span class="line">        str = &quot;test ok&quot;;</span><br><span class="line">        ch[0] = &apos;g&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A、 good and abc<br>B、 good and gbc<br>C、 test ok and abc<br>D、 test ok and gbc<br>答案：B<br>解析：大家可能以为Java中String和数组都是对象所以肯定是对象引用，然后就会选D，其实这是个很大的误区：因为在java里没有引用传递，只有值传递<br>这个值指的是实参的地址的拷贝，得到这个拷贝地址后，你可以通过它修改这个地址的内容（引用不变），因为此时这个内容的地址和原地址是同一地址，<br>但是你不能改变这个地址本身使其重新引用其它的对象，也就是值传递，可能说的不是很清楚，下面给出一个完整的能说明情况的例子吧：<br>程序有些啰嗦，但能反映问题，该程序运行结果为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">对象交换前：p1 = Alexia female</span><br><span class="line">对象交换前：p2 = Edward male</span><br><span class="line"></span><br><span class="line">对象交换后：p1 = Alexia female</span><br><span class="line">对象交换后：p2 = Edward male</span><br><span class="line"></span><br><span class="line">对象数组交换前：arraya[0] = Alexia female, arraya[1] = Edward male</span><br><span class="line">对象数组交换前：arrayb[0] = jmwang female, arrayb[1] = hwu male</span><br><span class="line"></span><br><span class="line">对象数组交换后：arraya[0] = Alexia female, arraya[1] = Edward male</span><br><span class="line">对象数组交换后：arrayb[0] = jmwang female, arrayb[1] = hwu male</span><br><span class="line"></span><br><span class="line">基本类型数组交换前：a[0] = 0, a[1] = 1</span><br><span class="line">基本类型数组交换前：b[0] = 1, b[1] = 2</span><br><span class="line"></span><br><span class="line">基本类型数组交换后：a[0] = 0, a[1] = 1</span><br><span class="line">基本类型数组交换后：b[0] = 1, b[1] = 2</span><br><span class="line"></span><br><span class="line">对象数组内容交换并改变后：arraya[1] = wjl male</span><br><span class="line">对象数组内容交换并改变后：arrayb[1] = Edward male</span><br><span class="line"></span><br><span class="line">基本类型数组内容交换并改变后：a[1] = 5</span><br><span class="line">基本类型数组内容交换并改变后：b[1] = 1</span><br></pre></td></tr></table></figure>
<p>说明：不管是对象、基本类型还是对象数组、基本类型数组，在函数中都不能改变其实际地址但能改变其中的内容。<br><strong>要从文件”file.dat”中读出第10个字节到变量c中,下列哪个方法适合? （）</strong><br>A FileInputStream in=new FileInputStream(“file.dat”); in.skip(9); int c=in.read();<br>B FileInputStream in=new FileInputStream(“file.dat”); in.skip(10); int c=in.read();<br>C FileInputStream in=new FileInputStream(“file.dat”); int c=in.read();<br>D RandomAccessFile in=new RandomAccessFile(“file.dat”); in.skip(9); int c=in.readByte();<br>答案：A?D?<br>解析：long skip(long n)作用是跳过n个字节不读，主要用在包装流中的，因为一般流（如FileInputStream）只能顺序一个一个的读不能跳跃读，但是包装流可以用skip方法跳跃读取。那么什么是包装流呢？各种字节节点流类，它们都只具有读写字节内容的方法，以FileInputStream与FileOutputStream为例，它们只能在文件中读取或者向文件中写入字节，在实际应用中我们往往需要在文件中读取或者写入各种类型的数据，就必须先将其他类型的数据转换成字节数组后写入文件，或者从文件中读取到的字节数组转换成其他数据类型，想想都很麻烦！！因此想通过FileOutputStream将一个浮点小数写入到文件中或将一个整数写入到文件时是非常困难的。这时就需要包装类DataInputStream/DataOutputStream，它提供了往各种输入输出流对象中读入或写入各种类型的数据的方法。<br>DataInputStream/DataOutputStream并没有对应到任何具体的流设备，一定要给它传递一个对应具体流设备的输入或输出流对象，完成类似 DataInputStream/DataOutputStream功能的类就是一个包装类，也叫过滤流类或处理流类。它对InputOutStream/OutputStream流类进行了包装，使编程人员使用起来更方便。其中DataInputStream包装类的构造函数语法：public DataInputStream(InputStream in)。包装类也可以包装另外一个包装类。<br>首先BC肯定 是错的，那A正确吗？按上面的解析应该也不对，但我试了下，发现A也是正确的，与网上解析的资料有些出入，下面是我的code：<br>那么D呢，RandomAccessFile是IO包的类，但是其自成一派，从Object直接继承而来。可以对文件进行读取和写入。支持文件的随机访问，即可以随机读取文件中的某个位置内容，这么说RandomAccessFile肯定可以达到题目的要求，但是选项有些错误，比如RandomAccessFile的初始化是两个参数而非一个参数，采用的跳跃读取方法是skipBytes()而非skip()，即正确的写法是：<br>RandomAccessFile in = new RandomAccessFile(“file.dat”, “r”);<br>in.skipBytes(9);<br>int c = in.readByte();<br>这样也能读到第十个字节，也就是A和D都能读到第十个字节，那么到底该选哪个呢？A和D有啥不同吗？求大神解答~~~<br><strong>下列哪种异常是检查型异常，需要在编写程序时声明 （）</strong><br>ANullPointerException        BClassCastException      CFileNotFoundException       D IndexOutOfBoundsException<br>答案：C<br>解析：看第2题的解析。<br><strong>下面的方法，当输入为2的时候返回值是多少?（）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static int getValue(int i) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    switch (i) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">        result = result + i;</span><br><span class="line">    case 2:</span><br><span class="line">        result = result + i * 2;</span><br><span class="line">    case 3:</span><br><span class="line">        result = result + i * 3;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>A0                    B2                    C4                     D10<br>答案：D<br>解析：注意这里case后面没有加break，所以从case 2开始一直往下运行。<br><strong>选项中哪一行代码可以替换题目中//add code here而不产生编译错误？（）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class MyClass &#123;</span><br><span class="line">     public int constInt = 5;</span><br><span class="line">     //add code here</span><br><span class="line">     public void method() &#123;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Apublic abstract void method(int a);<br>B constInt = constInt + 5;<br>C public int method();<br>D public abstract void anotherMethod() {}<br>答案：A<br>解析：考察抽象类的使用。<br>抽象类遵循的原则：<br>（1）abstract关键字只能修饰类和方法，不能修饰字段。<br>（2）抽象类不能被实例化（无法使用new关键字创建对象实例），只能被继承。<br>（3）抽象类可以包含属性，方法，构造方法，初始化块，内部类，枚举类，和普通类一样，普通方法一定要实现，变量可以初始化或不初始化但不能初始化后在抽象类中重新赋值或操作该变量（只能在子类中改变该变量）。<br>（4）抽象类中的抽象方法（加了abstract关键字的方法）不能实现。<br>（5）含有抽象方法的类必须定义成抽象类。<br>扩展：抽象类和接口的区别，做个总结吧：<br>（1）接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的。   </p>
<p>（2）abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface，实现多重继承。接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。   </p>
<p>（3）在abstract class 中可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface中，只能够有静态的不能被修改的数据成员（也就是必须是 static final的，不过在 interface中一般不定义数据成员），所有的成员方法默认都是 public abstract 类型的。  </p>
<p>（4）abstract class和interface所反映出的设计理念不同。其实abstract class表示的是”is-a”关系，interface表示的是”has-a”关系。   </p>
<p>（5）实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。抽象类中可以有非抽象方法。接口中则不能有实现方法。   </p>
<p>（6）接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以在子类中重新赋值。<br><strong>阅读Shape和Circle两个类的定义。在序列化一个Circle的对象circle到文件时，下面哪个字段会被保存到文件中？ (  )</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">       public String name;</span><br><span class="line">&#125;</span><br><span class="line">class Circle extends Shape implements Serializable&#123;</span><br><span class="line">       private float radius;</span><br><span class="line">       transient int color;</span><br><span class="line">       public static String type = &quot;Circle&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Aname<br>B radius<br>C color<br>D type<br>答案：B<br>解析：这里有详细的解释：<a href="http://www.cnblogs.com/lanxuezaipiao/p/3369962.html" target="_blank" rel="noopener">http://www.cnblogs.com/lanxuezaipiao/p/3369962.html</a><br><strong>下面是People和Child类的定义和构造方法，每个构造方法都输出编号。在执行new Child(“mike”)的时候都有哪些构造方法被顺序调用？请选择输出结果 ( )</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class People &#123;</span><br><span class="line">    String name;</span><br><span class="line">    public People() &#123;</span><br><span class="line">        System.out.print(1);</span><br><span class="line">    &#125;</span><br><span class="line">    public People(String name) &#123;</span><br><span class="line">        System.out.print(2);</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends People &#123;</span><br><span class="line">    People father;</span><br><span class="line">    public Child(String name) &#123;</span><br><span class="line">        System.out.print(3);</span><br><span class="line">        this.name = name;</span><br><span class="line">        father = new People(name + &quot;:F&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Child() &#123;</span><br><span class="line">        System.out.print(4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>A312              B 32               C 432              D 132<br>答案：D<br>解析：考察的又是父类与子类的构造函数调用次序。在Java中，子类的构造过程中必须调用其父类的构造函数，是因为有继承关系存在时，子类要把父类的内容继承下来。但如果父类有多个构造函数时，该如何选择调用呢？<br>第一个规则：子类的构造过程中，必须调用其父类的构造方法。一个类，如果我们不写构造方法，那么编译器会帮我们加上一个默认的构造方法（就是没有参数的构造方法），但是如果你自己写了构造方法，那么编译器就不会给你添加了，所以有时候当你new一个子类对象的时候，肯定调用了子类的构造方法，但是如果在子类构造方法中我们并没有显示的调用基类的构造方法，如：super();  这样就会调用父类没有参数的构造方法。<br>第二个规则：如果子类的构造方法中既没有显示的调用基类构造方法，而基类中又没有无参的构造方法，则编译出错，所以，通常我们需要显示的：super(参数列表)，来调用父类有参数的构造函数，此时无参的构造函数就不会被调用。<br>总之，一句话：子类没有显示调用父类构造函数，不管子类构造函数是否带参数都默认调用父类无参的构造函数，若父类没有则编译出错。<br>最后，给大家出个思考题：下面程序的运行结果是什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Dervied extends Base &#123;</span><br><span class="line">    private String name = &quot;dervied&quot;;</span><br><span class="line">    public Dervied() &#123;</span><br><span class="line">        tellName();</span><br><span class="line">        printName();</span><br><span class="line">    &#125;</span><br><span class="line">    public void tellName() &#123;</span><br><span class="line">        System.out.println(&quot;Dervied tell name: &quot; + name);</span><br><span class="line">    &#125;    </span><br><span class="line">    public void printName() &#123;</span><br><span class="line">        System.out.println(&quot;Dervied print name: &quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        </span><br><span class="line">        new Dervied();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Base &#123;    </span><br><span class="line">    private String name = &quot;base&quot;;</span><br><span class="line">    public Base() &#123;</span><br><span class="line">        tellName();</span><br><span class="line">        printName();</span><br><span class="line">    &#125;   </span><br><span class="line">    public void tellName() &#123;</span><br><span class="line">        System.out.println(&quot;Base tell name: &quot; + name);</span><br><span class="line">    &#125;    </span><br><span class="line">    public void printName() &#123;</span><br><span class="line">        System.out.println(&quot;Base print name: &quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="/music/1.mp3">
            </audio>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci="55316b017b800ec5c0da" data-cs="fbe9f4aafee144a34ec283ca34c833ad6da91507" data-r="talk" data-o="viacbde" data-a="viabcde" data-d="false">查看评论</div>


    </div>
    
        <div class="side">
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是虚拟机？为什么Java被称作是“平台无关的编程语言”？"><span class="toc-number">1.</span> <span class="toc-text">什么是虚拟机？为什么Java被称作是“平台无关的编程语言”？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-和-JRE-的区别是什么？"><span class="toc-number">2.</span> <span class="toc-text">JDK 和 JRE 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static关键字-Java中是否可以覆盖-override-一个private或者是static的方法？"><span class="toc-number">3.</span> <span class="toc-text">static关键字,Java中是否可以覆盖(override)一个private或者是static的方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#是否可以在static环境中访问非static变量？"><span class="toc-number">4.</span> <span class="toc-text">是否可以在static环境中访问非static变量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是自动拆装箱？"><span class="toc-number">5.</span> <span class="toc-text">什么是自动拆装箱？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？"><span class="toc-number">6.</span> <span class="toc-text">Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口和抽象类的区别是什么？"><span class="toc-number">7.</span> <span class="toc-text">接口和抽象类的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关键字"><span class="toc-number">8.</span> <span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双亲委派模型"><span class="toc-number">9.</span> <span class="toc-text">双亲委派模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在JDK1-4中引入了一个NIO的类库，使得Java涉及IO的操作拥有阻塞式和非阻塞式两种，问一下阻塞IO与非阻塞IO有什么区别？有什么优缺点？"><span class="toc-number">10.</span> <span class="toc-text">在JDK1.4中引入了一个NIO的类库，使得Java涉及IO的操作拥有阻塞式和非阻塞式两种，问一下阻塞IO与非阻塞IO有什么区别？有什么优缺点？</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#————————————-试题————————————————"><span class="toc-number"></span> <span class="toc-text">————————————-试题————————————————</span></a>
        </li></div>
    
</div>


    </div>
</div>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>