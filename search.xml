<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android-Studio</title>
      <link href="/2019/02/05/2018-12-24-android-studio/"/>
      <url>/2019/02/05/2018-12-24-android-studio/</url>
      
        <content type="html"><![CDATA[<h3 id="android-studio恢复默认布局"><a href="#android-studio恢复默认布局" class="headerlink" title="android-studio恢复默认布局"></a><strong>android-studio恢复默认布局</strong></h3><p>window===restore default layout</p><h3 id="android-studio将当前布局设置为默认布局"><a href="#android-studio将当前布局设置为默认布局" class="headerlink" title="android-studio将当前布局设置为默认布局"></a><strong>android-studio将当前布局设置为默认布局</strong></h3><p>window—store current layout as default</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a><strong>目录结构</strong></h3><p><strong>mainfests目录</strong>:有系统生成的文件AndroidNaibfest.xml，存储程序的重要信息<br><strong>java目录</strong>:系统自动生成1个默认的java文件MainActivity.java,存储java文件<br><strong>res目录</strong>：存放非程序文件，在drawable文件夹下存储图片等资源，layout文件夹下系统自动生成主显示控制文件activity_main.xml和主设计文件content_main.xml，<br>menu文件夹存储界面的菜单的设计文件，mipmpa文件夹存放根据分辨率划分的图片资源，values文件夹存放文字strings.xml，颜色colors.xml和样式styles.xml<br>Grad;e Scripts–build.gradle存放工程的架构信息     </p><h3 id="界面文本"><a href="#界面文本" class="headerlink" title="界面文本"></a><strong>界面文本</strong></h3><p>①可以直接写在contain_main.xml等xml文件的android:text=”Hello world”的键值对中；<br>②也可以写在res/values的strings.xml文件中</p><pre><code>&lt;reources&gt;    &lt;string name = &quot;str_button&quot;&gt;hello world&lt;/string&gt;&lt;/resources&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/2019/02/04/hello-world/"/>
      <url>/2019/02/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Java 写一个线程安全的单例模式</title>
      <link href="/2019/01/05/2019-01-05-%E7%94%A8%20Java%20%E5%86%99%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/01/05/2019-01-05-%E7%94%A8%20Java%20%E5%86%99%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="完整版"><a href="#完整版" class="headerlink" title="完整版"></a><strong>完整版</strong></h3><pre><code>public class Singleton {      private static class SingletonCreater{        private static final Singleton INSTANCE = new Singleton();    }    private Singleton(){}    public static final Singleton getInstance(){        return SingletonCreater.INSTANCE;    }}</code></pre><h3 id="初级版"><a href="#初级版" class="headerlink" title="初级版"></a><strong>初级版</strong></h3><pre><code>public class Singleton{    private static Singleton instance;    private Singleton(){} //将构造方法私有     public static Singleton getInstance(){        if(instance == null)            instance = new Singleton();        return instance;    }}</code></pre><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a><strong>存在的问题</strong></h3><p>getInstance方法线程不安全：加锁synchronized<br>加锁后存在的问题：只允许一个线程访问<br>解决方法：双重检验锁</p><pre><code>public static Singleton getInstance(){    if(instance == null){              //Single Checked        synchronized(Singleton.class){            if(instance == null)       //Double Checked                instance = new Singleton();        }    }    return instance;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解释New创建对象</title>
      <link href="/2019/01/04/2019-01-05-%E8%A7%A3%E9%87%8Anew%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/01/04/2019-01-05-%E8%A7%A3%E9%87%8Anew%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>instance = new Singletoe();<br>JVM大概做了如下工作：<br>1.给instance分配内存<br>2.调用Singleton的构造方法来初始化成员变量<br>3.将instance对象指向分配的内存空间（执行完这一步instance就不为空了）  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volatile</title>
      <link href="/2019/01/01/2019-01-01-volatile/"/>
      <url>/2019/01/01/2019-01-01-volatile/</url>
      
        <content type="html"><![CDATA[<p>由于java 虚拟机会对程序进行代码优化，即为了提高效率，允许线程保存变量的私有拷贝，从而可能发生变量数据读取不一致的情况<br>vilatile修饰的变量则不允许线程保存变量的私有拷贝，每次被线程访问时，都强迫从共享内存中重读该成员变量的值。<br>它也可以修饰数组，但修饰的是数组的引用，即数组声明的内存地址  </p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>使得一个非原子操作变成原子操作<br>例如：因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子  </p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a><strong>实践</strong></h3><p>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。<br>volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -多线程 - </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Html遇到的问题</title>
      <link href="/2018/12/24/2018-12-24-html%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2018/12/24/2018-12-24-html%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="style-”display-none-”和type-”hide”的区别"><a href="#style-”display-none-”和type-”hide”的区别" class="headerlink" title="style=”display:none;”和type=”hide”的区别"></a><strong>style=”display:none;”和type=”hide”的区别</strong></h3><p>hide不显示但会在页面占位置，而displat:none不显示也不会在页面占位置</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http</title>
      <link href="/2018/12/24/2018-12-24-HTTP/"/>
      <url>/2018/12/24/2018-12-24-HTTP/</url>
      
        <content type="html"><![CDATA[<p>MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型  </p><h3 id="HTTP是无连接"><a href="#HTTP是无连接" class="headerlink" title="HTTP是无连接"></a><strong>HTTP是无连接</strong></h3><p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。<br>HTTP 协议这种特性优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。<br>可以使用Keep-Alive保持连接，但缺点是占用本可以释放的空闲资源   </p><h3 id="HTTP协议是无状态协议"><a href="#HTTP协议是无状态协议" class="headerlink" title="HTTP协议是无状态协议"></a><strong>HTTP协议是无状态协议</strong></h3><p>无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式<code>[RFC5322</code>]和多用途Internet邮件扩展（MIME）<code>[RFC2045]</code>来传送<br><img src="https://viabcde.github.io/images/201812/87.png" alt="enter descriptionhere">     </p><h3 id="客户端请求："><a href="#客户端请求：" class="headerlink" title="客户端请求："></a><strong>客户端请求：</strong></h3><pre class=" language-http"><code class="language-http">GET /hello.txt HTTP/1.1<span class="token header-name keyword">User-Agent:</span> curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3<span class="token header-name keyword">Host:</span> www.example.com<span class="token header-name keyword">Accept-Language:</span> en, mi</code></pre><h3 id="服务端响应"><a href="#服务端响应" class="headerlink" title="服务端响应:"></a><strong>服务端响应:</strong></h3><pre><code>HTTP/1.1 200 OKDate: Mon, 27 Jul 2009 12:28:53 GMTServer: ApacheLast-Modified: Wed, 22 Jul 2009 19:15:56 GMTETag: &quot;34aa387-d-1568eb00&quot;Accept-Ranges: bytesContent-Length: 51Vary: Accept-EncodingContent-Type: text/plain</code></pre><h3 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a><strong>http请求方法</strong></h3><p>1   GET    请求指定的页面信息，并返回实体主体。<br>2    HEAD    类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头<br>3    POST    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。<br>4    PUT    从客户端向服务器传送的数据取代指定的文档的内容。<br>5    DELETE    请求服务器删除指定的页面。<br>6    CONNECT    HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>7    OPTIONS    允许客户端查看服务器的性能。<br>8    TRACE    回显服务器收到的请求，主要用于测试或诊断。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Json</title>
      <link href="/2018/12/21/2018-12-06-json/"/>
      <url>/2018/12/21/2018-12-06-json/</url>
      
        <content type="html"><![CDATA[<h3 id="json实例"><a href="#json实例" class="headerlink" title="json实例"></a><strong>json实例</strong></h3><p>json是javaScript的子集，可使用javaScript的eval()函数解析，即重新运算求出参数的内容（还原成原生的javaScript函数）   数据由逗号分隔，大括号保存对象，中括号保存数组<br><strong>示例</strong>   </p><pre><code>{&quot;sites&quot;: [{ &quot;name&quot;:&quot;菜鸟教程&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; }, { &quot;name&quot;:&quot;google&quot; , &quot;url&quot;:&quot;www.google.com&quot; }, { &quot;name&quot;:&quot;微博&quot; , &quot;url&quot;:&quot;www.weibo.com&quot; }]}</code></pre><p>可以像这样访问 JavaScript 对象数组中的第一项（索引从 0 开始）：   </p><pre><code>sites[0].name;</code></pre><p>返回的内容是：   runoob<br>可以像这样修改数据：  </p><pre class=" language-lsl"><code class="language-lsl">sites[0].name="菜鸟教程";</code></pre><h2 id="json对应javaScript"><a href="#json对应javaScript" class="headerlink" title="json对应javaScript"></a><strong>json对应javaScript</strong></h2><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span> <span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"菜鸟教程"</span> <span class="token punctuation">,</span> <span class="token property">"url"</span><span class="token operator">:</span><span class="token string">"www.runoob.com"</span> <span class="token punctuation">}</span></code></pre><p>这一点也容易理解，与这条 JavaScript 语句等价：</p><pre class=" language-makefile"><code class="language-makefile">name <span class="token operator">=</span> <span class="token string">"菜鸟教程"</span>url <span class="token operator">=</span> <span class="token string">"www.runoob.com"</span></code></pre><p><strong>效果：</strong><br><img src="https://viabcde.github.io/images/201812/47.png" alt="enter descriptionhere"><br><strong>代码：</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;JavaScript 创建 JSON 对象&lt;/h2&gt;&lt;p&gt;网站名称: &lt;span id=&quot;jname&quot;&gt;&lt;/span&gt;&lt;br /&gt; 网站地址: &lt;span id=&quot;jurl&quot;&gt;&lt;/span&gt;&lt;br /&gt; 网站 slogan: &lt;span id=&quot;jslogan&quot;&gt;&lt;/span&gt;&lt;br /&gt; &lt;/p&gt;&lt;script&gt;var JSONObject= {    &quot;name&quot;:&quot;菜鸟教程&quot;,    &quot;url&quot;:&quot;www.runoob.com&quot;,     &quot;slogan&quot;:&quot;学的不仅是技术，更是梦想！&quot;};document.getElementById(&quot;jname&quot;).innerHTML=JSONObject.name document.getElementById(&quot;jurl&quot;).innerHTML=JSONObject.url document.getElementById(&quot;jslogan&quot;).innerHTML=JSONObject.slogan &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="访问对象的值"><a href="#访问对象的值" class="headerlink" title="访问对象的值"></a><strong>访问对象的值</strong></h3><p><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/48.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;你可以使用点号（.）来访问 JSON 对象的值：&lt;/p&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;var myObj, x;myObj = { &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:null };x = myObj.name;document.getElementById(&quot;demo&quot;).innerHTML = x;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>或者使用中括号来访问</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;你也可以使用中括号（[]）来访问 JOSN 对象的值：&lt;/p&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;var myObj, x;myObj = myObj = { &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:null };x = myObj[&quot;name&quot;];document.getElementById(&quot;demo&quot;).innerHTML = x;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="使用-for-in-来循环对象的属性及其值"><a href="#使用-for-in-来循环对象的属性及其值" class="headerlink" title="使用 for-in 来循环对象的属性及其值"></a><strong>使用 for-in 来循环对象的属性及其值</strong></h3><p><strong>效果：</strong><br><img src="https://viabcde.github.io/images/201812/49.png" alt="enter descriptionhere"><br><strong>代码</strong><br><strong>获取属性</strong>   </p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;使用 for-in 来循环对象的属性:&lt;/p&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;var myObj = { &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:null };for (x in myObj) {    document.getElementById(&quot;demo&quot;).innerHTML += x + &quot;&lt;br&gt;&quot;;}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>获得值</strong>   </p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;在 for-in 循环对象的属性时，使用中括号（[]）来访问属性的值：&lt;/p&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;var myObj = { &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:null };for (x in myObj) {    document.getElementById(&quot;demo&quot;).innerHTML += myObj[x] + &quot;&lt;br&gt;&quot;;}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="删除对象的属性和值"><a href="#删除对象的属性和值" class="headerlink" title="删除对象的属性和值"></a><strong>删除对象的属性和值</strong></h3><p><strong>删除属性</strong>  </p><pre><code>delete myObj.sites.site1;</code></pre><p><strong>删除值</strong></p><pre><code>delete myObj.sites[&quot;site1&quot;]</code></pre><h3 id="将服务器传的JSON格式的数据转为javaScript"><a href="#将服务器传的JSON格式的数据转为javaScript" class="headerlink" title="将服务器传的JSON格式的数据转为javaScript"></a><strong>将服务器传的JSON格式的数据转为javaScript</strong></h3><p><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/50.png" alt="enter descriptionhere"><br><strong>代码</strong></p><pre><code>&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;var obj = JSON.parse(&#39;{ &quot;name&quot;:&quot;runoob&quot;, &quot;alexa&quot;:10000, &quot;site&quot;:&quot;www.runoob.com&quot; }&#39;);document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot;：&quot; + obj.site;&lt;/script&gt;</code></pre><h3 id="使用AJAX请求json数据并解析为javaScript"><a href="#使用AJAX请求json数据并解析为javaScript" class="headerlink" title="使用AJAX请求json数据并解析为javaScript"></a><strong>使用AJAX请求json数据并解析为javaScript</strong></h3><p><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/51.png" alt="enter descriptionhere"><br><strong>代码</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;使用 XMLHttpRequest 来获取文件内容&lt;/h2&gt;&lt;p&gt;文件内容是标准的 JSON 格式，可以使用 JSON.parse 方法将其转换为 JavaScript 对象。&lt;/p&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;var xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange = function() {    if (this.readyState == 4 &amp;&amp; this.status == 200) {        myObj = JSON.parse(this.responseText);        document.getElementById(&quot;demo&quot;).innerHTML = myObj.name;    }};xmlhttp.open(&quot;GET&quot;, &quot;/try/ajax/json_demo.txt&quot;, true);xmlhttp.send();&lt;/script&gt;&lt;p&gt;查看 JSON 文件数据 &lt;a href=&quot;/try/ajax/json_demo.txt&quot; target=&quot;_blank&quot;&gt;json_demo.txt&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="JSON-不能存储-Date-对象问题"><a href="#JSON-不能存储-Date-对象问题" class="headerlink" title="JSON 不能存储 Date 对象问题"></a><strong>JSON 不能存储 Date 对象问题</strong></h3><p><strong>解决方法1</strong><br>将其转换为字符串。<br>之后再将字符串转换为 Date 对象   </p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;将字符串转换为 Date 对象。&lt;/h2&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;var text = &#39;{ &quot;name&quot;:&quot;Runoob&quot;, &quot;initDate&quot;:&quot;2013-12-14&quot;, &quot;site&quot;:&quot;www.runoob.com&quot;}&#39;;var obj = JSON.parse(text);obj.initDate = new Date(obj.initDate);document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot;创建日期: &quot; + obj.initDate;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>解决方法2</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;字符串转换为 Date 对象&lt;/h2&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;var text = &#39;{ &quot;name&quot;:&quot;Runoob&quot;, &quot;initDate&quot;:&quot;2013-12-14&quot;, &quot;site&quot;:&quot;www.runoob.com&quot;}&#39;;var obj = JSON.parse(text, function (key, value) {    if (key == &quot;initDate&quot;) {        return new Date(value);    } else {        return value;}});document.getElementById(&quot;demo&quot;).innerHTML = obj.name + &quot;创建日期：&quot; + obj.initDate;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="eval和json-parse区别"><a href="#eval和json-parse区别" class="headerlink" title="eval和json.parse区别"></a><strong>eval和json.parse区别</strong></h3><p>eval不会检查字符串是否符合json格式，parse会检查</p><pre><code>var data = &#39;{&quot;student&quot; : [{&quot;name&quot;:&quot;鸣人&quot;,&quot;age&quot;:17}, {&quot;name&quot;:&quot;小樱&quot;,&quot;age&quot;:17},{&quot;name&quot;:&quot;佐助&quot;,&quot;age&quot;:17}]}&#39;;eval(&#39;(&#39; + data + &#39;)&#39;);</code></pre><pre><code>var data = &#39;{&quot;student&quot; : [{&quot;name&quot;:&quot;鸣人&quot;,&quot;age&quot;:17}, {&quot;name&quot;:&quot;小樱&quot;,&quot;age&quot;:17},{&quot;name&quot;:&quot;佐助&quot;,&quot;age&quot;:17}]}&#39;;JSON.parse(data);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Controller和@RestController的区别</title>
      <link href="/2018/12/21/2018-12-06-@Controller%E5%92%8C@RestController%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/12/21/2018-12-06-@Controller%E5%92%8C@RestController%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>使用@Controller，配合视图解析器可以返回jsp、html等页面，如果要返回json，则需要再加@ResponseBody<br>或者直接使用@RestController，此时只能返回json，不能返回jsp、html</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle3</title>
      <link href="/2018/12/20/2018-12-06-Oracle3/"/>
      <url>/2018/12/20/2018-12-06-Oracle3/</url>
      
        <content type="html"><![CDATA[<h3 id="一、字符函数"><a href="#一、字符函数" class="headerlink" title="一、字符函数"></a><strong>一、字符函数</strong></h3><p>字符函数是oracle中最常用的函数，我们来看看有哪些字符函数：<br>lower(char)：将字符串转化为小写的格式。<br>upper(char)：将字符串转化为大写的格式。<br>length(char)：返回字符串的长度。<br>substr(char, m, n)：截取字符串的子串，n代表取n个字符的意思，不是代表取到第n个<br>replace(char1, search_string, replace_string)<br>instr(C1,C2,I,J) –&gt;判断某字符或字符串是否存在，存在返回出现的位置的索引，否则返回小于1;在一个字符串中搜索指定的字符,返回发现指定的字符的位置;<br>C1 被搜索的字符串<br>C2 希望搜索的字符串<br>I 搜索的开始位置,默认为1<br>J 出现的位置,默认为1   </p><h2 id="问题：将所有员工的名字按小写的方式显示"><a href="#问题：将所有员工的名字按小写的方式显示" class="headerlink" title="问题：将所有员工的名字按小写的方式显示"></a><strong>问题：将所有员工的名字按小写的方式显示</strong></h2><p>SQL&gt; select lower(ename) from emp;   </p><h2 id="问题：将所有员工的名字按大写的方式显示。"><a href="#问题：将所有员工的名字按大写的方式显示。" class="headerlink" title="问题：将所有员工的名字按大写的方式显示。"></a><strong>问题：将所有员工的名字按大写的方式显示。</strong></h2><p>SQL&gt; select upper(ename) from emp;<br><strong>问题：显示正好为5个字符的员工的姓名。</strong><br>SQL&gt; select * from emp where length(ename)=5;<br>问题：显示所有员工姓名的前三个字符。<br>SQL&gt; select substr(ename, 1, 3) from emp;<br>问题：以首字母大写,后面小写的方式显示所有员工的姓名。<br>SQL&gt; select upper(substr(ename,1,1)) || lower(substr(ename,2,length(ename)-1)) from emp;<br>问题：以首字母小写,后面大写的方式显示所有员工的姓名。<br>SQL&gt; select lower(substr(ename,1,1)) || upper(substr(ename,2,length(ename)-1)) from emp;<br>问题：显示所有员工的姓名，用“我是老虎”替换所有“A”<br>SQL&gt; select replace(ename,’A’, ‘我是老虎’) from emp;<br>问题：instr(<code>char1,char2,[,n[,m]]</code>)用法<br>SQL&gt; select instr(‘azhangsanbcd’, ‘zhangsan’) from dual; –返回2<br>SQL&gt; select instr(‘oracle traning’, ‘ra’, 1, 1) instring from dual; –返回2<br>SQL&gt; select instr(‘oracle traning’, ‘ra’, 1, 2) instring from dual; –返回9<br>SQL&gt; select instr(‘oracle traning’, ‘ra’, 1, 3) instring from dual; –返回0，根据条件，由于ra只出现二次，第四个参数3，就是说第3次出现ra的位置，显然第3次是没有再出现了，所以结果返回0。注意空格也算一个字符<br>SQL&gt; select instr(‘abc’,’d’) from dual;  –返回0   </p><h3 id="二、数学函数"><a href="#二、数学函数" class="headerlink" title="二、数学函数"></a><strong>二、数学函数</strong></h3><p>数学函数的输入参数和返回值的数据类型都是数字类型的。数学函数包括cos，cosh，exp，ln, log，sin，sinh，sqrt，tan，tanh，acos，asin，atan，round等<br>我们讲最常用的：<br><code>round(n,[m])</code> 该函数用于执行四舍五入，<br>如果省掉m，则四舍五入到整数。<br>如果m是正数，则四舍五入到小数点的m位后。<br>如果m是负数，则四舍五入到小数点的m位前。<br>eg、SELECT round(23.75123) FROM dual; –返回24<br>SELECT round(23.75123, -1) FROM dual; –返回20<br>SELECT round(27.75123, -1) FROM dual; –返回30<br>SELECT round(23.75123, -3) FROM dual; –返回0<br>SELECT round(23.75123, 1) FROM dual; –返回23.8<br>SELECT round(23.75123, 2) FROM dual; –返回23.75<br>SELECT round(23.75123, 3) FROM dual; –返回23.751<br><code>trunc(n,[m])</code> 该函数用于截取数字。<br>如果省掉m，就截去小数部分，<br>如果m是正数就截取到小数点的m位后，<br>如果m是负数，则截取到小数点的前m位。<br>eg、SELECT trunc(23.75123) FROM dual; –返回23<br>SELECT trunc(23.75123, -1) FROM dual; –返回20<br>SELECT trunc(27.75123, -1) FROM dual; –返回20<br>SELECT trunc(23.75123, -3) FROM dual; –返回0<br>SELECT trunc(23.75123, 1) FROM dual; –返回23.7<br>SELECT trunc(23.75123, 2) FROM dual; –返回23.75<br>SELECT trunc(23.75123, 3) FROM dual; –返回23.751<br>mod(m,n)取余函数<br>eg、select mod(10,2) from dual; –返回0<br>SELECT MOD(10,3) FROM dual; –返回1<br>floor(n) 返回小于或是等于n的最大整数<br>ceil(n) 返回大于或是等于n的最小整数<br>eg、SELECT ceil(24.56) from dual; –返回25<br>SELECT floor(24.56) from dual; –返回24<br>abs(n) 返回数字n的绝对值<br>对数字的处理，在财务系统或银行系统中用的最多，不同的处理方法，对财务报表有不同的结果   </p><h3 id="三、日期函数"><a href="#三、日期函数" class="headerlink" title="三、日期函数"></a><strong>三、日期函数</strong></h3><p>日期函数用于处理date类型的数据。默认情况下日期格式是dd-mon-yy 即“12-7 月-12”<br>(1)sysdate 返回系统时间<br>eg、SQL&gt; select sysdate from dual;<br>(2)oracle add_months函数<br>oracle add_months(time,months)函数可以得到某一时间之前或之后n个月的时间<br>eg、select add_months(sysdate,-6) from dual; –该查询的结果是当前时间半年前的时间<br>select add_months(sysdate,6) from dual; –该查询的结果是当前时间半年后的时间<br>(3)last_day(d)：返回指定日期所在月份的最后一天   </p><h3 id="问题：查找已经入职8个月多的员工"><a href="#问题：查找已经入职8个月多的员工" class="headerlink" title="问题：查找已经入职8个月多的员工"></a><strong>问题：查找已经入职8个月多的员工</strong></h3><p>SQL&gt; select * from emp where sysdate&gt;=add_months(hiredate,8);<br>问题：显示满10年服务年限的员工的姓名和受雇日期。</p><pre class=" language-n1ql"><code class="language-n1ql">SQL> select ename, hiredate from emp where sysdate>=add_months(hiredate,12*10);</code></pre><p>问题：对于每个员工，显示其加入公司的天数。<br>SQL&gt; select floor(sysdate-hiredate) “入职天数”,ename from emp;<br>或者<br>SQL&gt; select trunc(sysdate-hiredate) “入职天数”,ename from emp;<br>问题：找出各月倒数第3天受雇的所有员工。<br>SQL&gt; select hiredate,ename from emp where last_day(hiredate)-2=hiredate;</p><p>四、转换函数<br>转换函数用于将数据类型从一种转为另外一种。在某些情况下，oracle server允许值的数据类型和实际的不一样，这时oracle server会隐含的转化数据类型<br>比如：<br>create table t1(id int);<br>insert into t1 values(‘10’);–这样oracle会自动的将’10’ –&gt;10<br>create table t2 (id varchar2(10));<br>insert into t2 values(1); –这样oracle就会自动的将1 –&gt;’1’；<br>我们要说的是尽管oracle可以进行隐含的数据类型的转换，但是它并不适应所有的情况，为了提高程序的可靠性，我们应该使用转换函数进行转换。</p><p>to_char()函数<br>你可以使用select ename, hiredate, sal from emp where deptno = 10;显示信息，可是，在某些情况下，这个并不能满足你的需求。<br>问题：日期是否可以显示 时/分/秒<br>SQL&gt; select ename, to_char(hiredate, ‘yyyy-mm-dd hh24:mi:ss’) from emp;<br>问题：薪水是否可以显示指定的货币符号<br>SQL&gt;<br>yy：两位数字的年份 2004–&gt;04<br>yyyy：四位数字的年份 2004年<br>mm：两位数字的月份 8 月–&gt;08<br>dd：两位数字的天 30 号–&gt;30<br>hh24： 8点–&gt;20<br>hh12：8点–&gt;08<br>mi、ss–&gt;显示分钟\秒<br>9：显示数字，并忽略前面0<br>0：显示数字，如位数不足，则用0补齐<br>.：在指定位置显示小数点<br>,：在指定位置显示逗号<br>$：在数字前加美元<br>L：在数字前面加本地货币符号<br>C：在数字前面加国际货币符号<br>G：在指定位置显示组分隔符、<br>D：在指定位置显示小数点符号(.)</p><h2 id="问题：显示薪水的时候，把本地货币单位加在前面"><a href="#问题：显示薪水的时候，把本地货币单位加在前面" class="headerlink" title="问题：显示薪水的时候，把本地货币单位加在前面"></a><strong>问题：显示薪水的时候，把本地货币单位加在前面</strong></h2><pre class=" language-moonscript"><code class="language-moonscript">SQL> select ename, to_char(hiredate, 'yyyy-mm-dd hh24:mi:ss'), to_char(sal,'L99999.99') from emp;</code></pre><p>问题：显示1980年入职的所有员工<br>SQL&gt; select <em> from emp where to_char(hiredate, ‘yyyy’)=1980;<br>问题：显示所有12月份入职的员工<br>SQL&gt; select </em> from emp where to_char(hiredate, ‘mm’)=12;</p><p>to_date()函数<br>函数to_date用于将字符串转换成date类型的数据。</p><h2 id="问题：能否按照中国人习惯的方式年—月—日添加日期。"><a href="#问题：能否按照中国人习惯的方式年—月—日添加日期。" class="headerlink" title="问题：能否按照中国人习惯的方式年—月—日添加日期。"></a><strong>问题：能否按照中国人习惯的方式年—月—日添加日期。</strong></h2><pre class=" language-sql"><code class="language-sql">eg、<span class="token keyword">SELECT</span> to_date<span class="token punctuation">(</span><span class="token string">'2012-02-18 09:25:30'</span><span class="token punctuation">,</span><span class="token string">'yyyy-mm-dd hh24:mi:ss'</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> dual<span class="token punctuation">;</span></code></pre><p>五、sys_context()系统函数<br>1)terminal：当前会话客户所对应的终端的标示符，如计算机名<br>2)language: 语言<br>3)db_name： 当前数据库名称<br>4)nls_date_format： 当前会话客户所对应的日期格式<br>5)session_user： 当前会话客户所对应的数据库用户名<br>6)current_schema： 当前会话客户所对应的默认方案名<br>7)host： 返回数据库所在主机的名称<br>通过该函数，可以查询一些重要信息，比如你正在使用哪个数据库？<br>select sys_context(‘USERENV’,’db_name’) from dual;<br>注意：USERENV是固定的，不能改的，db_name可以换成其它,<br>eg、select sys_context(‘USERENV’,’language’) from dual;<br>select sys_context(‘USERENV’,’current_schema’) from dual;</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle索引</title>
      <link href="/2018/12/20/2018-12-06-Oracle%E7%B4%A2%E5%BC%95/"/>
      <url>/2018/12/20/2018-12-06-Oracle%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p>索引是用于加速数据存取的数据对象。合理的使用索引可以大大降低i/o次数，从而提高数据访问性能<br><strong>使用原则</strong><br>1)、在大表上建立索引才有意义<br>2)、在where子句或是连接条件上经常引用的列上建立索引<br>3)、索引的层次不要超过4层<br>系统会用更多的硬盘和内存空间来保存索引，而且在更新数据时，为了数据和索引的一致性，会花费更多时间更新索引<br>所以，少用的 字段尽量不加索引   </p><pre class=" language-armasm"><code class="language-armasm">B*树索引建立在重复值很少的列上，而位图索引则建立在重复值很多、不同值相对固定的列上  </code></pre><h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a><strong>单列索引</strong></h3><pre><code>create index 索引名 on 表名(列名);eg、create index nameIndex on custor(name);</code></pre><h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a><strong>复合索引</strong></h3><p>复合索引是基于两列或是多列的索引。在同一张表上可以有多个索引，但是要求列的组合必须不同，比如：<br>create index emp_idx1 on emp(ename, job);<br>create index emp_idx1 on emp(job, ename);<br>以上这两个索引是两个不同的索引。    </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java程序中如何使用事务</title>
      <link href="/2018/12/20/2018-12-06-java%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1/"/>
      <url>/2018/12/20/2018-12-06-java%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>java程序中如何使用事务<br>在java操作数据库时，为了保证数据的一致性，比如账户操作(1)从一个账户中减掉10$(2)在另一个账户上加入10$,我们看看如何使用事务？   </p><pre><code>package junit.test;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class TransationTest {    public static void main(String[] args) {        Connection conn = null;        try {            // 1.加载驱动            Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);            // 2.得到连接            conn = DriverManager.getConnection(&quot;jdbc:oracle:thin:@127.0.0.1:1521:orcl&quot;, &quot;scott&quot;, &quot;oracle&quot;);            Statement sm = conn.createStatement();            // 从scott的sal中减去100            sm.executeUpdate(&quot;update emp set sal=sal-100 where ename=&#39;SCOTT&#39;&quot;);            int i = 7 / 0; //报java.lang.ArithmeticException: / by zero异常            // 给smith的sal加上100            sm.executeUpdate(&quot;update emp set sal=sal+100 where ename=&#39;SMITH&#39;&quot;);            // 关闭打开的资源            sm.close();            conn.close();        } catch (Exception e) {            // 如果发生异常，就回滚            try {                conn.rollback();            } catch (SQLException e1) {                e1.printStackTrace();            }            e.printStackTrace();        }    }}</code></pre><p>运行，会出现异常，查看数据库，SCOTT 的sal 减了100，但是SMITH 的sal 却不变，很可怕。。。<br>我们怎样才能保证，这两个操作要么同时成功，要么同时失败呢？<br>设置sql不自动提交：conn.setAutoCommit(false);// 设置不能默认提交  </p><pre><code>package junit.test;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class TransationTest {    public static void main(String[] args) {        Connection conn = null;        try {            // 1.加载驱动            Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);            // 2.得到连接            conn = DriverManager.getConnection(&quot;jdbc:oracle:thin:@127.0.0.1:1521:orcl&quot;, &quot;scott&quot;, &quot;oracle&quot;);            // 加入事务处理            conn.setAutoCommit(false);// 设置不能默认提交            Statement sm = conn.createStatement();            // 从scott的sal中减去100            sm.executeUpdate(&quot;update emp set sal=sal-100 where ename=&#39;SCOTT&#39;&quot;);            int i = 7 / 0;            // 给smith的sal加上100            sm.executeUpdate(&quot;update emp set sal=sal+100 where ename=&#39;SMITH&#39;&quot;);            // 提交事务            conn.commit();            // 关闭打开的资源            sm.close();            conn.close();        } catch (Exception e) {            // 如果发生异常，就回滚            try {                conn.rollback();            } catch (SQLException e1) {                e1.printStackTrace();            }            e.printStackTrace();        }    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle2</title>
      <link href="/2018/12/19/2018-12-06-Oracle2/"/>
      <url>/2018/12/19/2018-12-06-Oracle2/</url>
      
        <content type="html"><![CDATA[<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a><strong>创建用户</strong></h3><p>具有dba(数据库管理员)的权限才能使用<br>create user 用户名 identified by 密码;<br>eg、<code>create user xiaoming identified by oracle;</code><br><strong>可能遇到的bug：</strong>oracle有个毛病，密码必须以字母开头，如果以数字开头，它不会创建用户   </p><h3 id="修改用户的密码"><a href="#修改用户的密码" class="headerlink" title="修改用户的密码"></a><strong>修改用户的密码</strong></h3><p>一是修改自己的密码，可直接修改：SQL&gt; <code>password 用户名</code>   或者直接敲  <code>passw</code><br>二是给别人修改密码则需要具有dba的权限，或是拥有alter user的系统权限   <code>SQL&gt; alter user 用户名 identified by 新密码</code>   </p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a><strong>删除用户</strong></h3><p><strong>前提：</strong>一般以dba的身份去删除某个用户，如果用其它用户去删除用户则需要具有drop user的权限<br>drop user 用户名 cascade<br><strong>加cascade的原因：</strong>在删除用户时，如果要删除的用户，已经创建了表，那么就需要在删除的时候带一个参数cascade，即把该用户及表一同删除;   </p><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a><strong>权限</strong></h3><p>权限分为系统权限和对象权限<br>何为系统权限？<br>用户对数据库的相关权限，connect、resource、dba等系统权限，如建库、建表、建索引、建存储过程、登陆数据库、修改密码等。<br>何为对象权限？<br>用户对其他用户的数据对象操作的权限，insert、delete、update、select、all等对象权限，数据对象有很多，比如表，索引，视图，触发器、存储过程、包等。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a><strong>角色</strong></h3><p>角色分为预定义角色和自定义角色    </p><h2 id="预定义角色connect、resource、dba"><a href="#预定义角色connect、resource、dba" class="headerlink" title="预定义角色connect、resource、dba"></a><strong>预定义角色connect、resource、dba</strong></h2><p><strong>connect角色</strong>   ：开发人员需要的大部分权限   </p><p><code>`</code> create cluster<br>create database link<br>create session<br>alter session<br>create table<br>create view<br>create sequence</p><pre><code>**resource角色**：具有应用开发人员所需要的其它权限，比如建立存储过程，触发器等    </code></pre><p>create cluster<br>create indextype<br>create table<br>create sequence<br>create type<br>create procedure<br>create trigger</p><pre><code>**dba角色**dba角色具有所有的系统权限，及with admin option选项，默认的dba用户为sys和system，它们可以将任何系统权限授予其他用户。但是要注意的是dba角色不具备sysdba和sysoper的特权（启动和关闭数据库）   ## **自定义角色**一般是dba来建立，如果用别的用户来建立，则需要具有create role的系统权限。   **建立角色（不验证）**：`create role 角色名 not identified;`**建立角色（数据库验证）**：`create role 角色名 identified by 密码;`## **给角色授权**``` SQL&gt; conn system/oracle;SQL&gt; grant create session to 角色名 with admin optionSQL&gt; conn scott/oracle@orcl;SQL&gt; grant select on scott.emp to 角色名;SQL&gt; grant insert, update, delete on scott.emp to 角色名;</code></pre><p><strong>注意：</strong>系统权限的unlimited tablespace和对象权限的with grant option选项是不能授予角色的   </p><h2 id="分配角色给某个用户"><a href="#分配角色给某个用户" class="headerlink" title="分配角色给某个用户"></a><strong>分配角色给某个用户</strong></h2><p>一般分配角色是由dba来完成的，如果要以其它用户身份分配角色，则要求用户必须具有grant any role的系统权限。<br><code>`</code> SQL&gt; conn system/oracle;<br>SQL&gt; grant 角色名 to blake with admin option;</p><pre><code>## **删除角色**一般是dba来执行，如果其它用户则要求该用户具有drop any role系统权限``` SQL&gt; conn system/oracle;SQL&gt; drop role 角色名;</code></pre><p><strong>bug:</strong> 如果角色被删除，那么被授予角色的用户不具有之前角色里的权限</p><h2 id="显示角色信息"><a href="#显示角色信息" class="headerlink" title="显示角色信息"></a><strong>显示角色信息</strong></h2><p><strong>显示所有角色：</strong> <code>SQL&gt; select * from dba_roles;</code><br><strong>显示角色具有的系统权限</strong>：<code>SQL&gt; select privilege, admin_option from role_sys_privs where role=&#39;角色名&#39;;</code></p><h3 id="用户管理案例"><a href="#用户管理案例" class="headerlink" title="用户管理案例"></a><strong>用户管理案例</strong></h3><p>概述：创建的新用户是没有任何权限的，甚至连登陆的数据库的权限都没有，需要为其指定相应的权限。给一个用户赋权限使用命令grant，回收权限使用命令revoke。<br>为了讲清楚用户的管理，这里我给大家举一个案例。<br>SQL&gt; conn xiaoming/oracle<br>ERROR:<br>ORA-01045: user XIAOMING lacks CREATE SESSION privilege; logon denied<br>警告: 您不再连接到 ORACLE。<br>SQL&gt; show user<br>USER 为 “”<br>SQL&gt; conn system/oracle<br>已连接。<br>SQL&gt; grant connect to xiaoming;<br>授权成功。<br>SQL&gt; conn xiaoming/oracle<br>已连接。<br>SQL&gt;<br>注意：grant connect to xiaoming;在这里，准确的讲，connect不是权限，而是角色。   </p><p>现在说下对象权限，现在要做这么件事情：<br> 希望xiaoming用户可以去查询emp表<br> 希望xiaoming用户可以去查询scott的emp表<br>grant select on scott.emp to xiaoming<br> 希望xiaoming用户可以去修改scott的emp表<br>grant update on scott.emp to xiaoming<br> 希望xiaoming 用户可以去修改/删除，查询，添加scott的emp表<br>grant all on scott.emp to xiaoming<br> scott希望收回xiaoming对emp表的查询权限<br>revoke select on scott.emp from xiaoming   </p><h3 id="with-admin-option与with-grant-option区别"><a href="#with-admin-option与with-grant-option区别" class="headerlink" title="with admin option与with grant option区别"></a><strong>with admin option与with grant option区别</strong></h3><p>1、with admin option用于系统权限授权，with grant option用于对象授权。<br>2、给一个用户授予系统权限带上with admin option时，此用户可把此系统权限授予其他用户或角色，但收回这个用户的系统权限时，这个用户已经授予其他用户或角色的此系统权限不会因传播无效，如授予A系统权限create session with admin option,然后A又把create session权限授予B,但管理员收回A的create session权限时，B依然拥有create session的权限，但管理员可以显式收回B create session的权限，即直接revoke create session from B.<br>而with grant option用于对象授权时，被授予的用户也可把此对象权限授予其他用户或角色，不同的是但管理员收回用with grant option授权的用户对象权限时，权限会因传播而失效，如grant select on table with grant option to A,A用户把此权限授予B，但管理员收回A的权限时，B的权限也会失效，但管理员不可以直接收回B的SELECT ON TABLE 权限。   </p><h3 id="账户锁定"><a href="#账户锁定" class="headerlink" title="账户锁定"></a><strong>账户锁定</strong></h3><p>指定scott这个用户最多只能尝试3次登陆，锁定时间为2天<br>创建profile文件<br>SQL&gt; create profile lock_account limit failed_login_attempts 3 password_lock_time 2;<br>SQL&gt; alter user scott profile lock_account;<br>给账户(用户)解锁<br>SQL&gt; alter user scott account unlock<br>终止口令:给前面创建的用户test创建一个profile文件，要求该用户每隔10天要修改自己的登陆密码，宽限期为2天。<br>SQL&gt; create profile myprofile limit password_life_time 10 password_grace_time 2;<br>SQL&gt; alter user test profile myprofile;<br>口令历史:希望用户在修改密码时，不能使用以前使用过的密码，可使用口令历史，这样oracle就会将口令修改的信息存放到数据字典中，这样当用户修改密码时，oracle就会对新旧密码进行比较，当发现新旧密码一样时，就提示用户重新输入密码。<br>例子：<br>1）建立profile<br>SQL&gt;create profile password_history limit password_life_time 10 password_grace_time 2<br>password_reuse_time 10 //password_reuse_time指定口令可重用时间即10天后就可以重用<br>2）分配给某个用户<br>SQL&gt; alter user test profile password_history;<br>删除profile:<br>SQL&gt; drop profile password_history 【casade】<br>注意：文件删除后，用这个文件去约束的那些用户通通也都被释放了。。<br>加了casade，就会把级联的相关东西也给删除掉   </p><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a><strong>添加数据</strong></h3><p>–所有字段都插入数据<br>insert into student values (‘a001’, ‘张三’, ‘男’, ‘01-5 月-05’, 10);<br>–oracle中默认的日期格式‘dd-mon-yy’ dd 天 mon 月份 yy 2位的年 ‘09-6 月-99’ 1999年6月9日<br>–修改日期的默认格式（临时修改，数据库重启后仍为默认；如要修改需要修改注册表）<br>alter session set nls_date_format =’yyyy-mm-dd’;<br>–修改后，可以用我们熟悉的格式添加日期类型：<br>insert into student values (‘a002’, ‘mike’, ‘男’, ‘1905-05-06’, 10);<br>–插入部分字段<br>insert into student(xh, xm, sex) values (‘a003’, ‘john’, ‘女’);<br>–插入空值<br>insert into student(xh, xm, sex, birthday) values (‘a004’, ‘martin’, ‘男’, null);<br>–问题来了，如果你要查询student表里birthday为null的记录，怎么写sql呢？<br>–错误写法：select <em> from student where birthday = null;<br>–正确写法：select </em> from student where birthday is null;<br>–如果要查询birthday不为null,则应该这样写：<br>select * from student where birthday is not null;   </p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a><strong>删除数据</strong></h3><p>delete from student; –删除所有记录，表结构还在，写日志，可以恢复的，速度慢。<br>–delete的数据可以恢复。<br>savepoint a; –创建保存点<br>delete from student;<br>rollback to a; –恢复到保存点<br>一个有经验的dba，在确保完成无误的情况下要定期创建还原点。    </p><h3 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a><strong>查看表结构</strong></h3><p>desc emp;</p><h3 id="查询所有列"><a href="#查询所有列" class="headerlink" title="查询所有列"></a><strong>查询所有列</strong></h3><p>select <em> from dept;<br>备注:切忌动不动就用`select </em><code>，使用</code>*`效率比较低，特别在大表中要注意。  </p><h3 id="打开显示操作时间的开关，在底部显示操作时间"><a href="#打开显示操作时间的开关，在底部显示操作时间" class="headerlink" title="打开显示操作时间的开关，在底部显示操作时间"></a><strong>打开显示操作时间的开关，在底部显示操作时间</strong></h3><p>set timing on/off;<br>eg、sql&gt; insert into tb_stu values(‘0001’, ‘zhangsan’, 24);<br>1 row inserted<br>executed in 0.015 seconds   </p><h3 id="添加主键约束"><a href="#添加主键约束" class="headerlink" title="添加主键约束"></a><strong>添加主键约束</strong></h3><p>alter table tb_dept add constraint tb_dept primary key (deptno);   </p><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a><strong>统计</strong></h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token function">count</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> emp<span class="token punctuation">;</span></code></pre><h3 id="如何取消重复行distinct"><a href="#如何取消重复行distinct" class="headerlink" title="如何取消重复行distinct"></a><strong>如何取消重复行distinct</strong></h3><p>select distinct deptno, job from emp;   </p><h3 id="nvl函数"><a href="#nvl函数" class="headerlink" title="nvl函数"></a><strong>nvl函数</strong></h3><p>格式为：nvl(string1, replace_with) 　　<br>功能：如果string1为null，则nvl函数返回replace_with的值，否则返回string1的值。 　<br>注意事项：string1和replace_with必须为同一数据类型，除非显示的使用to_char函数。    　<br>eg、如何显示每个雇员的年工资？   </p><pre class=" language-lsl"><code class="language-lsl">select sal*13+nvl(comm, 0)*13 "年薪" , ename, comm from emp;   </code></pre><h3 id="如何处理null值"><a href="#如何处理null值" class="headerlink" title="如何处理null值"></a><strong>如何处理null值</strong></h3><p>使用nvl函数来处理</p><h3 id="如何连接字符串"><a href="#如何连接字符串" class="headerlink" title="如何连接字符串(||)"></a><strong>如何连接字符串(||)</strong></h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> ename <span class="token operator">||</span> <span class="token string">' is a '</span> <span class="token operator">||</span> job <span class="token keyword">from</span> emp<span class="token punctuation">;</span></code></pre><h3 id="如何查找1982-1-1后入职的员工？"><a href="#如何查找1982-1-1后入职的员工？" class="headerlink" title="如何查找1982.1.1后入职的员工？"></a><strong>如何查找1982.1.1后入职的员工？</strong></h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> ename<span class="token punctuation">,</span>hiredate <span class="token keyword">from</span> emp <span class="token keyword">where</span> hiredate <span class="token operator">></span><span class="token string">'1-1 月-1982'</span><span class="token punctuation">;</span></code></pre><h3 id="如何使用like操作符"><a href="#如何使用like操作符" class="headerlink" title="如何使用like操作符"></a><strong>如何使用like操作符</strong></h3><pre class=" language-shell"><code class="language-shell">%：表示0到多个字符 _：表示任意单个字符</code></pre><h2 id="问题：如何显示首字符为s的员工姓名和工资？"><a href="#问题：如何显示首字符为s的员工姓名和工资？" class="headerlink" title="问题：如何显示首字符为s的员工姓名和工资？"></a><strong>问题：如何显示首字符为s的员工姓名和工资？</strong></h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> ename<span class="token punctuation">,</span>sal <span class="token keyword">from</span> emp <span class="token keyword">where</span> ename <span class="token operator">like</span> <span class="token string">'s%'</span><span class="token punctuation">;</span></code></pre><h2 id="如何显示第三个字符为大写o的所有员工的姓名和工资？"><a href="#如何显示第三个字符为大写o的所有员工的姓名和工资？" class="headerlink" title="如何显示第三个字符为大写o的所有员工的姓名和工资？"></a><strong>如何显示第三个字符为大写o的所有员工的姓名和工资？</strong></h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> ename<span class="token punctuation">,</span>sal <span class="token keyword">from</span> emp <span class="token keyword">where</span> ename <span class="token operator">like</span> <span class="token string">'__o%'</span><span class="token punctuation">;</span></code></pre><h2 id="如何显示empno为7844-7839-123-456的雇员情况？"><a href="#如何显示empno为7844-7839-123-456的雇员情况？" class="headerlink" title="如何显示empno为7844,7839,123,456的雇员情况？"></a><strong>如何显示empno为7844,7839,123,456的雇员情况？</strong></h2><p>select * from emp where empno in (7844, 7839, 123, 456);     </p><h2 id="如何显示没有上级的雇员的情况？"><a href="#如何显示没有上级的雇员的情况？" class="headerlink" title="如何显示没有上级的雇员的情况？"></a><strong>如何显示没有上级的雇员的情况？</strong></h2><p>错误写法：select <em> from emp where mgr = ‘’;<br>正确写法：select </em> from emp where mgr is null;<br>查询工资高于500或者是岗位为manager的雇员，同时还要满足他们的姓名首字母为大写的J？<br>select * from emp where (sal &gt; 500 or job = ‘MANAGER’) and ename like ‘J%’;<br>使用列的别名排序<br>问题：按年薪排序   </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> ename<span class="token punctuation">,</span> <span class="token punctuation">(</span>sal<span class="token operator">+</span>nvl<span class="token punctuation">(</span>comm<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">12</span> <span class="token string">"年薪"</span> <span class="token keyword">from</span> emp <span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token string">"年薪"</span> <span class="token keyword">asc</span><span class="token punctuation">;</span></code></pre><p>备注：别名需要使用“”号圈中,英文不需要“”号  </p><h2 id="最高工资那个人是谁？"><a href="#最高工资那个人是谁？" class="headerlink" title="最高工资那个人是谁？"></a><strong>最高工资那个人是谁？</strong></h2><p>错误写法：select ename, sal from emp where sal=max(sal);<br>正确写法：select ename, sal from emp where sal=(select max(sal) from emp);<br>注意：select ename, max(sal) from emp;这语句执行的时候会报错，说ora-00937：非单组分组函数。因为max是分组函数，而ename不是分组函数…….<br>但是select min(sal), max(sal) from emp;这句是可以执行的。因为min和max都是分组函数，就是说：如果列里面有一个分组函数，其它的都必须是分组函数，否则就出错。这是语法规定的<br>group by 用于对查询的结果分组统计，<br>having 子句用于限制分组显示结果。   </p><h2 id="问题：如何显示每个部门的平均工资和最高工资？"><a href="#问题：如何显示每个部门的平均工资和最高工资？" class="headerlink" title="问题：如何显示每个部门的平均工资和最高工资？"></a><strong>问题：如何显示每个部门的平均工资和最高工资？</strong></h2><p>select avg(sal), max(sal), deptno from emp group by deptno;<br>（注意：这里暗藏了一点，如果你要分组查询的话，分组的字段deptno一定要出现在查询的列表里面，否则会报错。因为分组的字段都不出现的话，就没办法分组了）   </p><h2 id="问题：显示每个部门的每种岗位的平均工资和最低工资？"><a href="#问题：显示每个部门的每种岗位的平均工资和最低工资？" class="headerlink" title="问题：显示每个部门的每种岗位的平均工资和最低工资？"></a><strong>问题：显示每个部门的每种岗位的平均工资和最低工资？</strong></h2><p>select min(sal), avg(sal), deptno, job from emp group by deptno, job;   </p><h2 id="问题：显示平均工资低于2000的部门号和它的平均工资？"><a href="#问题：显示平均工资低于2000的部门号和它的平均工资？" class="headerlink" title="问题：显示平均工资低于2000的部门号和它的平均工资？"></a><strong>问题：显示平均工资低于2000的部门号和它的平均工资？</strong></h2><p>select avg(sal), max(sal), deptno from emp group by deptno having avg(sal)&lt; 2000;<br>如果在select语句中同时包含有group by, having, order by 那么它们的顺序是group by, having, order by  </p><h2 id="显示某个员工的上级领导的姓名？"><a href="#显示某个员工的上级领导的姓名？" class="headerlink" title="显示某个员工的上级领导的姓名？"></a><strong>显示某个员工的上级领导的姓名？</strong></h2><p>比如显示员工‘FORD’的上级<br>SELECT worker.ename, boss.ename FROM emp worker, emp boss WHERE worker.mgr = boss.empno AND worker.ename = ‘FORD’;   </p><h2 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a><strong>单行子查询</strong></h2><p>SELECT * FROM emp WHERE deptno = (select deptno from emp WHERE ename = ‘SMITH’);<br>数据库在执行sql是从左到右扫描的，如果有括号的话，括号里面的先被优先执行。  </p><h2 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a><strong>多行子查询</strong></h2><p>SELECT * FROM emp WHERE job IN (SELECT DISTINCT job FROM emp WHERE deptno = 10);<br>注意：不能用job=..，因为等号=是一对一的  </p><h2 id="如何显示工资比部门30的所有员工的工资高的员工的姓名、工资和部门号？"><a href="#如何显示工资比部门30的所有员工的工资高的员工的姓名、工资和部门号？" class="headerlink" title="如何显示工资比部门30的所有员工的工资高的员工的姓名、工资和部门号？"></a><strong>如何显示工资比部门30的所有员工的工资高的员工的姓名、工资和部门号？</strong></h2><p>–方法一<br>SELECT ename, sal, deptno FROM emp WHERE sal &gt; all(SELECT sal FROM emp WHERE deptno = 30);<br>–方法二(执行效率最高，使用聚合函数)<br>SELECT ename, sal, deptno FROM emp WHERE sal &gt; (SELECT max(sal) FROM emp WHERE deptno = 30);  </p><h2 id="如何显示工资比部门30的任意一个员工的工资高的员工姓名、工资和部门号？"><a href="#如何显示工资比部门30的任意一个员工的工资高的员工姓名、工资和部门号？" class="headerlink" title="如何显示工资比部门30的任意一个员工的工资高的员工姓名、工资和部门号？"></a><strong>如何显示工资比部门30的任意一个员工的工资高的员工姓名、工资和部门号？</strong></h2><p>–方法一<br>SELECT ename, sal, deptno FROM emp WHERE sal &gt; ANY (SELECT sal FROM emp WHERE deptno = 30);<br>–方法二(执行效率最高，使用聚合函数)<br>SELECT ename, sal, deptno FROM emp WHERE sal &gt; (SELECT min(sal) FROM emp WHERE deptno = 30);   </p><h2 id="多列子查询"><a href="#多列子查询" class="headerlink" title="多列子查询"></a><strong>多列子查询</strong></h2><h2 id="查询与SMITH-的部门和岗位完全相同的所有雇员"><a href="#查询与SMITH-的部门和岗位完全相同的所有雇员" class="headerlink" title="查询与SMITH 的部门和岗位完全相同的所有雇员"></a><strong>查询与SMITH 的部门和岗位完全相同的所有雇员</strong></h2><p>SELECT deptno, job FROM emp WHERE ename = ‘SMITH’;<br>SELECT * FROM emp WHERE (deptno, job) = (SELECT deptno, job FROM emp WHERE ename = ‘SMITH’);  </p><h2 id="如何显示高于自己部门平均工资的员工的信息"><a href="#如何显示高于自己部门平均工资的员工的信息" class="headerlink" title="如何显示高于自己部门平均工资的员工的信息"></a><strong>如何显示高于自己部门平均工资的员工的信息</strong></h2><p>SELECT e.ename, e.deptno, e.sal, ds.mysal<br>FROM emp e, (SELECT deptno, AVG(sal) mysal FROM emp GROUP by deptno) ds<br>WHERE e.deptno = ds.deptno AND e.sal &gt; ds.mysal;<br><strong>注意：</strong>给表取别名的时候，不能加as；但是给列取别名，是可以加as的  </p><h2 id="用查询结果创建新表"><a href="#用查询结果创建新表" class="headerlink" title="用查询结果创建新表"></a><strong>用查询结果创建新表</strong></h2><p>CREATE TABLE mytable (id, name, sal, job, deptno) as SELECT empno, ename, sal, job, deptno FROM emp;</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a><strong>分页</strong></h3><p>根据rowid来分</p><pre><code>SELECT *  FROM EMP WHERE ROWID IN       (SELECT RID          FROM (SELECT ROWNUM RN, RID                  FROM (SELECT ROWID RID, EMPNO FROM EMP ORDER BY EMPNO DESC)                 WHERE ROWNUM &lt;= ( (currentPage-1) * pageSize + pageSize )) --每页显示几条         WHERE RN &gt; ((currentPage-1) * pageSize) ) --当前页数 ORDER BY EMPNO DESC;eg、-- 5 = (currentPage-1) * pageSize + pageSize   每页显示几条-- 0 = (currentPage-1) * pageSize              当前页数SELECT *  FROM EMP WHERE ROWID IN       (SELECT RID          FROM (SELECT ROWNUM RN, RID                  FROM (SELECT ROWID RID, EMPNO FROM EMP ORDER BY EMPNO DESC)                 WHERE ROWNUM &lt;= ( (1-1) * 5 + 5 )) --每页显示几条         WHERE RN &gt; ((1-1) * 5) ) --当前页数 ORDER BY EMPNO DESC;</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a><strong>事务</strong></h2><p>设置只读事务: set transaction read only;</p><h3 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a><strong>导出表</strong></h3><p>在导入和导出的时候，要到oracle目录的bin目录下<br>C:\Users\jiqinlin&gt;cd D:\dev\oracle\product\10.2.0\db_1\bin<br>C:\Users\jiqinlin&gt;d:<br>D:\dev\oracle\product\10.2.0\db_1\bin&gt;exp userid=scott/oracle@orcl tables=(emp) file=d:\emp.dmp   </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle</title>
      <link href="/2018/12/19/2018-12-06-Oracle/"/>
      <url>/2018/12/19/2018-12-06-Oracle/</url>
      
        <content type="html"><![CDATA[<p>特点：安全性高  </p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h3><p>这里的数据库是磁盘上存储数据的集合，在物理上表现为数据文件、日志文件和控制文件等  </p><h3 id="全局数据库名"><a href="#全局数据库名" class="headerlink" title="全局数据库名"></a><strong>全局数据库名</strong></h3><p>用于区分一个数据库的标识。它由数据库名称和域名构成，类似网络中的域名   </p><h3 id="数据库实例"><a href="#数据库实例" class="headerlink" title="数据库实例"></a><strong>数据库实例</strong></h3><p>具体的数据库  </p><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a><strong>表空间</strong></h3><p>存放多个关系表   </p><h3 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a><strong>数据文件</strong></h3><p>扩展名是.dbf，是用于存储数据库数据的文件。一个数据文件中可能存储很多个表的数据，而一个表的数据<br>也可以存放在多个数据文件中。数据文件和数据库表不存在一对一的关系  </p><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a><strong>日志文件</strong></h3><p>扩展名.log，它记录了数据的所有更改信息，用于恢复数据库  </p><h3 id="控制文件"><a href="#控制文件" class="headerlink" title="控制文件"></a><strong>控制文件</strong></h3><p>技展名.ctl，是一个二进制文件。控制文件是数据库启动及运行所必需的文件。存储数据文件和日志文件的<br>名称和位置<br><strong>外模式</strong> ：用户看到的视图，部分逻辑结构<br><strong>模式</strong>  ：所有逻辑结构<br><strong>内模式</strong>：数据的物理结构和存取方式的描述  </p><h3 id="Java连接Oracle"><a href="#Java连接Oracle" class="headerlink" title="Java连接Oracle"></a><strong>Java连接Oracle</strong></h3><pre class=" language-less"><code class="language-less"><span class="token property">driver</span><span class="token punctuation">:</span> oracle<span class="token number">.</span>jdbc<span class="token number">.</span>driver<span class="token number">.</span>OracleDriver<span class="token property">url</span><span class="token punctuation">:</span> <span class="token property">jdbc</span><span class="token punctuation">:</span><span class="token property">oracle</span><span class="token punctuation">:</span><span class="token property">thin</span><span class="token punctuation">:</span><span class="token variable">@localhost<span class="token punctuation">:</span></span><span class="token property">1521</span><span class="token punctuation">:</span>数据库名</code></pre><h3 id="char和varchar2-区别"><a href="#char和varchar2-区别" class="headerlink" title="char和varchar2    区别"></a><strong>char和varchar2    区别</strong></h3><p>char用户输入的值小于指定长度，系统自动用空格填充  varchar2不会，节省空间<br>char 查询的速度极快浪费空间，适合查询比较频繁的数据字段。<br>varchar 节省空间<br>nchar和nvarchar存储unicode字符，为中文而设计<br><strong>number(p,s)</strong><br>p表示总位数        s表示小数点右边的位数  </p><h3 id="date数据类型"><a href="#date数据类型" class="headerlink" title="date数据类型"></a><strong>date数据类型</strong></h3><p>默认<br>用于存储表中的日期和时间数据。使用7字节固定长度，每个字节分别存储世纪、年、月、日、小<br>时、分和秒。sysdate函数的功能是返回当前的日期和时间。</p><h3 id="timestamp数据类型"><a href="#timestamp数据类型" class="headerlink" title="timestamp数据类型"></a><strong>timestamp数据类型</strong></h3><p>扩展<br>用于存储日期的年、月、日以及时间的小时、分和秒。秒值精确到小数小后6位，包含时区<br>信息。systimestamp函数的功能是返回当前日期、时间和时区<br><strong>sys和system这两个用户最大的区别是</strong>  ：在于有没有create database的权限   </p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a><strong>图片</strong></h3><p>blob 二进制数据，可以存放图片/声音4g；一般来讲，在真实项目中是不会把图片和声音真的往数据库里存放，一般存放图片、视频的路径，如果安全需要比较高的话，则放入数据库。  </p><h3 id="sql-plus工具"><a href="#sql-plus工具" class="headerlink" title="sql*plus工具"></a><strong><code>sql*plus</code>工具</strong></h3><p><code>sql*plus</code>是oracle自带的工具软件，主要用于执行sql语句，pl\sql块。<br>操作如下：<br>(1)、在D:\dev\oracle\product\10.2.0\db_1\bin\目录下的sqlplusw.exe。(D:\dev\oracle\为oracle安装目录)<br>(2)、在运行栏中输入“sqlplusw”即可  </p><h3 id="连接命令"><a href="#连接命令" class="headerlink" title="连接命令"></a><strong>连接命令</strong></h3><p>conn 用户名/密码@网络服务名 <code>[as sysdba/sysoper]</code>，当用特权用户身份连接时，必须带上as sysdba或是as sysoper   </p><pre class=" language-nginx"><code class="language-nginx">conn system<span class="token operator">/</span>oracle@orcl</code></pre><h2 id="1-、连接命令"><a href="#1-、连接命令" class="headerlink" title="1)、连接命令"></a>1)、连接命令</h2><p><strong>1.connect</strong><br>用法：conn 用户名/密码@网络服务名 as sysdba/sysoper<br>说明：当用特权用户身份连接时，必须带上as sysdba或是as sysoper<br>eg、<br>SQL&gt; show user<br>USER 为 “SCOTT”<br>SQL&gt; conn system/oracle@orcl<br>已连接。<br>SQL&gt; show user<br>USER 为 “SYSTEM”<br>SQL&gt;<br>以上命令实现类似切换用户的效果<br><strong>2.disc/ disconn / disconnect</strong><br>说明: 该命令用来断开与当前数据库的连接<br><strong>3.pssword</strong><br>说明: 该命令用于修改用户的密码，如果要想修改其它用户的密码，需要用sys/system登录。<br>eg、<br>SQL&gt; conn scott/oracle<br>已连接。<br>SQL&gt; passw<br>更改 SCOTT 的口令<br>旧口令:<br>新口令:<br>重新键入新口令:<br>口令已更改<br>SQL&gt;<br><strong>4.show user</strong><br>说明: 显示当前用户名<br><strong>5.exit</strong><br>说明: 该命令会断开与数据库的连接，同时会退出<code>sql*plus</code><br>5.clear screen<br>清空屏幕   </p><h2 id="2-、文件操作命令"><a href="#2-、文件操作命令" class="headerlink" title="2)、文件操作命令"></a><strong>2)、文件操作命令</strong></h2><p><strong>1.start和@</strong><br>说明: 运行sql脚本<br>案例: sql&gt;@ d:\a.sql或是sql&gt;start d:\a.sql<br><strong>2.edit</strong><br>说明: 该命令可以编辑指定的sql脚本<br>案例: sql&gt;edit d:\a.sql,这样会把d:\a.sql 这个文件打开<br><strong>3.spool</strong><br>说明: 该命令可以将<code>sql*plus</code>屏幕上的内容输出到指定文件中去。<br>案例: sql&gt;spool d:\b.sql并输入sql&gt;spool off<br>eg、<br>sql&gt;spool d:\b.sql;<br>sql&gt;select * from emp;<br>sql&gt;spool off;   </p><h2 id="3-、交互式命令"><a href="#3-、交互式命令" class="headerlink" title="3)、交互式命令"></a><strong>3)、交互式命令</strong></h2><p><strong>1.&amp;</strong><br>说明：可以替代变量，而该变量在执行时，需要用户输入。<br>select * from emp where job=’&amp;job’；  </p><h2 id="4-、显示和设置环境变量"><a href="#4-、显示和设置环境变量" class="headerlink" title="4)、显示和设置环境变量"></a><strong>4)、显示和设置环境变量</strong></h2><p>概述：可以用来控制输出的各种格式，set show 如果希望永久的保存相关的设<br>置，可以去修改glogin.sql 脚本<br><strong>1.linesize</strong><br>说明：设置显示行的宽度，默认是80个字符<br>show linesize<br>set linesize 90<br><strong>2.pagesize</strong><br>说明：设置每页显示的行数目，默认是14<br>用法和linesize 一样<br>至于其它环境参数的使用也是大同小异   </p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a><strong>触发器</strong></h3><p>作用：当某条语句执行前或后触发，或者某个表中的某一行被改变时触发<br>create <code>[or replace]</code> tigger 触发器名 触发时间 触发事件<br>on 表名   </p><pre class=" language-vbscript"><code class="language-vbscript">[for each row]</code></pre><p>begin<br>  pl/sql语句<br>end<br>其中：<br>触发器名：触发器对象的名称。由于触发器是数据库自动执行的，因此该名称只是一个名称，没有实质的用途。<br>触发时间：指明触发器何时执行，该值可取：<br>before：表示在数据库动作之前触发器执行;<br>after：表示在数据库动作之后触发器执行。<br>触发事件：指明哪些数据库动作会触发此触发器：<br>insert：数据库插入会触发此触发器;<br>update：数据库修改会触发此触发器;<br>delete：数据库删除会触发此触发器。<br>表 名：数据库触发器所在的表。<br>for each row：对表的每一行触发器执行一次。如果没有这一选项，则只对整个表执行一次。<br>示例：</p><pre><code>create or replace trigger auth_secure before insert or update or DELETE on tb_empbegin   IF(to_char(sysdate,&#39;DY&#39;)=&#39;星期日&#39;) THEN       RAISE_APPLICATION_ERROR(-20600,&#39;不能在周末修改表tb_emp&#39;);   END IF;END;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle遇到的问题</title>
      <link href="/2018/12/19/2018-12-06-Oracle%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2018/12/19/2018-12-06-Oracle%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="登录时遇到：ORA-28009：connection-as-SYS-should-be-as-SYSDBA-OR-SYSOPER"><a href="#登录时遇到：ORA-28009：connection-as-SYS-should-be-as-SYSDBA-OR-SYSOPER" class="headerlink" title="登录时遇到：ORA-28009：connection as SYS should be as SYSDBA OR SYSOPER"></a><strong>登录时遇到：ORA-28009：connection as SYS should be as SYSDBA OR SYSOPER</strong></h3><p>解决方法：<br>例如我的oracle 密码为 Oracle12c 输入口令应该填 Oracle12c as sysdba<br>记住中间有空格  </p><h3 id="在查询字段为null的记录时注意"><a href="#在查询字段为null的记录时注意" class="headerlink" title="在查询字段为null的记录时注意"></a><strong>在查询字段为null的记录时注意</strong></h3><p>使用is null  /  is not null 而不是 = null<br>select * from student where birthday is null;   </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序入门程序的解释</title>
      <link href="/2018/12/17/2018-12-06-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A3%E9%87%8A/"/>
      <url>/2018/12/17/2018-12-06-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p>程序的组成<br><img src="https://viabcde.github.io/images/201812/44.png" alt="enter descriptionhere"><br><strong>app.js</strong>：小程序的逻辑     必须<br><strong>app.json</strong>  ：小程序的公共设置   必须<br><strong>app.wxss</strong>：小程序的公共样式表   非必须<br>每个文件夹表示一个页面，一个页面由4个文件组成<br><strong>js</strong>：页面逻辑   必须<br><strong>wxml</strong>：页面结构   必须<br><strong>json</strong>：页面配置  非必须<br><strong>wxss</strong>：页面样式表   非必须    </p><h3 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a><strong>app.js</strong></h3><pre><code>//app.jsApp({  onLaunch: function () {    //当小程序初始化完成时，会触发onLaunch（全局只触发一次）  },  onShow: function () {  //当小程序启动，或从后台进入前台显示，会触发onShow  },  onHide: function () {  //当小程序从前台进入后台，会触发onHide  },  onError: function (msg) {  //当小程序发生脚本错误，或者api调用失败时，会触发onError并带上错误信息  },  other:function(){//全局函数，可以被项目上的其他js文件调用  },  globalData:{//全局对象  },})</code></pre><p>使用App()函数，指定小程序的生命周期属性，如初始化：onLaunch等函数<br><strong>onLaunch</strong>：初始化，只触发一次<br><strong>onShow</strong>：监听小程序显示，  在启动，或从后台进入前台时会触发onShow<br><strong>onHide</strong>：监听小程序隐藏，   在从前台进入后台时触发onHide<br><strong>onError</strong>：错误监听函数，  脚本发生错误/api调用失败触发inError<br><strong>其他</strong>：自定义函数，使用this访问<br><strong>前台、后台定义：</strong> 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。   </p><h3 id="app-json"><a href="#app-json" class="headerlink" title="app.json"></a><strong>app.json</strong></h3><pre><code>{  &quot;pages&quot;:[    &quot;pages/index/index&quot;,    &quot;pages/logs/logs&quot;  ],  &quot;window&quot;:{    &quot;backgroundTextStyle&quot;:&quot;light&quot;,    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,    &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;,    &quot;navigationBarTextStyle&quot;:&quot;black&quot;  }}</code></pre><p><strong>pages</strong>：来指定小程序由哪些页面组成    pages内只需要写wxml文件的路径，其他文件不用写<br><strong>window</strong>：<br><strong>navigationBarBackgroundColor</strong>    HexColor    导航栏背景颜色，如 #000000<br><strong>navigationBarTextStyle</strong>    String        导航栏标题颜色，仅支持 black / white<br><strong>navigationBarTitleText</strong>    String        导航栏标题文字内容<br><strong>navigationStyle</strong>    String    default    导航栏样式，仅支持以下值：default 默认样式custom 自定义导航栏，只保留右上角胶囊按钮    微信版本 6.6.0<br><strong>backgroundColor</strong>    HexColor    #ffffff    窗口的背景色<br><strong>backgroundTextStyle</strong>    String    dark    下拉 loading 的样式，仅支持 dark / light<br><strong>backgroundColorTop</strong>    String    #ffffff    顶部窗口的背景色，仅 iOS 支持    微信版本 6.5.16<br><strong>backgroundColorBottom</strong>    String    #ffffff    底部窗口的背景色，仅 iOS 支持    微信版本 6.5.16<br><strong>enablePullDownRefresh</strong>    Boolean    false    是否开启当前页面的下拉刷新。详见 Page.onPullDownRefresh<br><strong>onReachBottomDistance</strong>    Number    50    页面上拉触底事件触发时距页面底部距离，单位为px。详见 Page.onReachBottom<br><strong>pageOrientation</strong>    String    portrait    屏幕旋转设置，仅支持 auto / portrait 详见 响应显示区域变化    微信版本 6.7.3<br><img src="https://viabcde.github.io/images/201812/45.png" alt="enter descriptionhere">       </p><h2 id="一个页面目录内的文件"><a href="#一个页面目录内的文件" class="headerlink" title="一个页面目录内的文件"></a><strong>一个页面目录内的文件</strong></h2><h3 id="xx-js"><a href="#xx-js" class="headerlink" title="xx.js"></a><strong>xx.js</strong></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于后台传递数据正常，前端页面不显示的Bug调试思路</title>
      <link href="/2018/12/16/2018-12-06-%E5%85%B3%E4%BA%8E%E5%90%8E%E5%8F%B0%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E6%AD%A3%E5%B8%B8%EF%BC%8C%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84bug%E8%B0%83%E8%AF%95%E6%80%9D%E8%B7%AF/"/>
      <url>/2018/12/16/2018-12-06-%E5%85%B3%E4%BA%8E%E5%90%8E%E5%8F%B0%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E6%AD%A3%E5%B8%B8%EF%BC%8C%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%9A%84bug%E8%B0%83%E8%AF%95%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>第一步：在网页按F12—network—点击list.do—respone<br>发现数据能传递到页面，说明后台代码正常<br>第二步：看页面接收数据的代码，和实体的属性名称一致，也没有问题<br>最后在偶然情况下发现，实体类在自动生成setter、getter代码的时候出现bug，如下</p><pre><code>public void setContent(String content) {        Content = content;    }</code></pre><p>而不是正常的如下代码</p><pre><code>public void setContent(String content) {        this.Content = content;    }</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 调试bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Log4j配置文件</title>
      <link href="/2018/12/14/2018-11-23-log4j%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2018/12/14/2018-11-23-log4j%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<pre><code>### direct log messages to stdout ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n### direct messages to file mylog.log ###log4j.appender.file=org.apache.log4j.FileAppenderlog4j.appender.file.File=c:/mylog.loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n### set log levels - for more verbose logging change &#39;info&#39; to &#39;debug&#39; ###log4j.rootLogger=info, stdout</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用forward隐藏index.jsp</title>
      <link href="/2018/12/14/2018-11-09-%E5%88%A9%E7%94%A8forward%E9%9A%90%E8%97%8Findex.jsp/"/>
      <url>/2018/12/14/2018-11-09-%E5%88%A9%E7%94%A8forward%E9%9A%90%E8%97%8Findex.jsp/</url>
      
        <content type="html"><![CDATA[<p>示例：<br>index.jsp</p><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;jsp:forward page=&quot;index.action&quot;/&gt;</code></pre><p>struts.xml</p><pre><code>        &lt;!-- 配置首页访问的Action --&gt;        &lt;action name=&quot;index&quot; class=&quot;indexAction&quot;&gt;            &lt;result name=&quot;index&quot;&gt;/WEB-INF/jsp/index.jsp&lt;/result&gt;        &lt;/action&gt;</code></pre><p>这样写还不行，还需yaozweb.xml文件中设置struts2拦截forward请求<br>web.xml</p><pre><code> &lt;filter&gt;    &lt;filter-name&gt;struts2&lt;/filter-name&gt;    &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;struts2&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;    &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;  &lt;/filter-mapping&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript实例</title>
      <link href="/2018/12/08/2018-12-06-javaScript%E5%AE%9E%E4%BE%8B/"/>
      <url>/2018/12/08/2018-12-06-javaScript%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p> 脚本可被放置在 HTML 页面的 <code>&lt;body&gt;</code> 和 <code>&lt;head&gt;</code> 部分中  </p><h3 id="输出文本document-write"><a href="#输出文本document-write" class="headerlink" title="输出文本document.write();"></a><strong>输出文本</strong><code>document.write();</code></h3><p><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/33.png" alt="enter descriptionhere"><br><strong>示例代码</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt;&lt;body&gt;&lt;h1&gt;我的第一个 Web 页面&lt;/h1&gt;&lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;script&gt;document.write(Date());&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="修改段落内容document-getElementById-quot-demo-quot-innerHTML-quot-段落已修改。-quot"><a href="#修改段落内容document-getElementById-quot-demo-quot-innerHTML-quot-段落已修改。-quot" class="headerlink" title="修改段落内容document.getElementById(&quot;demo&quot;).innerHTML=&quot;段落已修改。&quot;;"></a>修改段落内容<code>document.getElementById(&quot;demo&quot;).innerHTML=&quot;段落已修改。&quot;;</code></h3><p><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/34.png" alt="enter descriptionhere">     </p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt;&lt;body&gt;&lt;h1&gt;我的第一个 Web 页面&lt;/h1&gt;&lt;p id=&quot;demo&quot;&gt;我的第一个段落。&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;demo&quot;).innerHTML=&quot;段落已修改。&quot;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="引用外部的javaScript函数"><a href="#引用外部的javaScript函数" class="headerlink" title="引用外部的javaScript函数"></a><strong>引用外部的javaScript函数</strong></h2><p><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/36.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt;&lt;body&gt;&lt;h1&gt;我的 Web 页面&lt;/h1&gt;&lt;p id=&quot;demo&quot;&gt;一个段落。&lt;/p&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;myFunction 保存在名为 &quot;myScript.js&quot; 的外部文件中。&lt;/p&gt;&lt;script src=&quot;myScript.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="在页面加载时向-HTML-的-lt-body-gt-写文本，如果要在调用时执行，脚本应该放在function函数中"><a href="#在页面加载时向-HTML-的-lt-body-gt-写文本，如果要在调用时执行，脚本应该放在function函数中" class="headerlink" title="在页面加载时向 HTML 的 &lt;body&gt; 写文本，如果要在调用时执行，脚本应该放在function函数中"></a><strong>在页面加载时向 HTML 的 <code>&lt;body&gt;</code> 写文本，如果要在调用时执行，脚本应该放在function函数中</strong></h3><p><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/38.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;JavaScript 能够直接写入 HTML 输出流中：&lt;/p&gt;&lt;script&gt;document.write(&quot;&lt;h1&gt;这是一个标题&lt;/h1&gt;&quot;);document.write(&quot;&lt;p&gt;这是一个段落。&lt;/p&gt;&quot;);&lt;/script&gt;&lt;p&gt;您只能在 HTML 输出流中使用 &lt;strong&gt;document.write&lt;/strong&gt;。如果您在文档已加载后使用它（比如在函数中），会覆盖整个文档。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="通过按钮调用function来修改页面的内容"><a href="#通过按钮调用function来修改页面的内容" class="headerlink" title="通过按钮调用function来修改页面的内容"></a><strong>通过按钮调用function来修改页面的内容</strong></h2><p><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/39.png" alt="enter descriptionhere"><br><strong>代码1脚本在<code>&lt;head&gt;</code></strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script&gt;function myFunction(){    document.getElementById(&quot;demo&quot;).innerHTML=&quot;我的第一个 JavaScript 函数&quot;;}&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;我的 Web 页面&lt;/h1&gt;&lt;p id=&quot;demo&quot;&gt;一个段落。&lt;/p&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>代码2脚本在<code>&lt;body&gt;</code>中</strong>  </p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;我的 Web 页面&lt;/h1&gt;&lt;p id=&quot;demo&quot;&gt;一个段落&lt;/p&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;尝试一下&lt;/button&gt;&lt;script&gt;function myFunction(){    document.getElementById(&quot;demo&quot;).innerHTML=&quot;我的第一个 JavaScript 函数&quot;;}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>代码3脚本在外部文件中</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script src=&quot;myScript.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>myScript.js</p><pre><code>function myFunction(){    document.getElementById(&quot;demo&quot;).innerHTML=&quot;我的第一个 JavaScript 函数&quot;;}</code></pre><h3 id="警告框alert-quot-你好，我是一个警告框！-quot"><a href="#警告框alert-quot-你好，我是一个警告框！-quot" class="headerlink" title="警告框alert(&quot;你好，我是一个警告框！&quot;);"></a><strong>警告框<code>alert(&quot;你好，我是一个警告框！&quot;);</code></strong></h3><p><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/40.png" alt="enter descriptionhere"><br><strong>代码</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script&gt;function myFunction(){    alert(&quot;你好，我是一个警告框！&quot;);}&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; onclick=&quot;myFunction()&quot; value=&quot;显示警告框&quot; /&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="确认框confirm"><a href="#确认框confirm" class="headerlink" title="确认框confirm"></a><strong>确认框<code>confirm</code></strong></h3><p><strong>效果</strong><br><strong>代码</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;点击按钮，显示确认框。&lt;/p&gt;&lt;button onclick=&quot;myFunction()&quot;&gt;点我&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;function myFunction(){    var x;    var r=confirm(&quot;按下按钮!&quot;);    if (r==true){        x=&quot;你按下了\&quot;确定\&quot;按钮!&quot;;    }    else{        x=&quot;你按下了\&quot;取消\&quot;按钮!&quot;;    }    document.getElementById(&quot;demo&quot;).innerHTML=x;}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="对话框prompt"><a href="#对话框prompt" class="headerlink" title="对话框prompt"></a><strong>对话框<code>prompt</code></strong></h2><p><strong>效果</strong><br><strong>代码</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;点击按钮查看输入的对话框。&lt;/p&gt;&lt;button onclick=&quot;myFunction()&quot;&gt;点我&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;function myFunction(){    var x;    var person=prompt(&quot;请输入你的名字&quot;,&quot;Harry Potter&quot;);    if (person!=null &amp;&amp; person!=&quot;&quot;){        x=&quot;你好 &quot; + person + &quot;! 今天感觉如何?&quot;;        document.getElementById(&quot;demo&quot;).innerHTML=x;    }}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="cookie获取用户名"><a href="#cookie获取用户名" class="headerlink" title="cookie获取用户名"></a><strong>cookie获取用户名</strong></h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;head&gt;&lt;script&gt;function setCookie(cname,cvalue,exdays){    var d = new Date();    d.setTime(d.getTime()+(exdays*24*60*60*1000));    var expires = &quot;expires=&quot;+d.toGMTString();    document.cookie = cname+&quot;=&quot;+cvalue+&quot;; &quot;+expires;}function getCookie(cname){    var name = cname + &quot;=&quot;;    var ca = document.cookie.split(&#39;;&#39;);    for(var i=0; i&lt;ca.length; i++) {        var c = ca[i].trim();        if (c.indexOf(name)==0) { return c.substring(name.length,c.length); }    }    return &quot;&quot;;}function checkCookie(){    var user=getCookie(&quot;username&quot;);    if (user!=&quot;&quot;){        alert(&quot;欢迎 &quot; + user + &quot; 再次访问&quot;);    }    else {        user = prompt(&quot;请输入你的名字:&quot;,&quot;&quot;);          if (user!=&quot;&quot; &amp;&amp; user!=null){            setCookie(&quot;username&quot;,user,30);        }    }}&lt;/script&gt;&lt;/head&gt;&lt;body onload=&quot;checkCookie()&quot;&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="计时器3秒后显示对话框"><a href="#计时器3秒后显示对话框" class="headerlink" title="计时器3秒后显示对话框"></a><strong>计时器3秒后显示对话框</strong></h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;点击按钮，在等待 3 秒后弹出 &quot;Hello&quot;。&lt;/p&gt;&lt;button onclick=&quot;myFunction()&quot;&gt;点我&lt;/button&gt;&lt;script&gt;function myFunction(){    setTimeout(function(){alert(&quot;Hello&quot;)},3000);}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="无穷计时"><a href="#无穷计时" class="headerlink" title="无穷计时"></a><strong>无穷计时</strong></h2><p><strong>代码1</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script&gt;var c=0;var t;var timer_is_on=0;function timedCount(){    document.getElementById(&#39;txt&#39;).value=c;    c=c+1;    t=setTimeout(&quot;timedCount()&quot;,1000);}function doTimer(){    if (!timer_is_on)    {        timer_is_on=1;        timedCount();    }}&lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;form&gt;&lt;input type=&quot;button&quot; value=&quot;开始计数!&quot; onClick=&quot;doTimer()&quot;&gt;&lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt;&lt;/form&gt;&lt;p&gt;单击按钮，输入框将从0开始一直计数。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>代码2</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;head&gt;&lt;script&gt;function timedText(){    var x=document.getElementById(&#39;txt&#39;);    var t1=setTimeout(function(){x.value=&quot;2 秒&quot;},2000);    var t2=setTimeout(function(){x.value=&quot;4 秒&quot;},4000);    var t3=setTimeout(function(){x.value=&quot;6 秒&quot;},6000);}&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt;&lt;input type=&quot;button&quot; value=&quot;显示文本时间!&quot; onclick=&quot;timedText()&quot; /&gt;&lt;input type=&quot;text&quot; id=&quot;txt&quot; /&gt;&lt;/form&gt;&lt;p&gt;点击上面的按钮，输出的文本将告诉你2秒，4秒，6秒已经过去了。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="无穷计时器，有停止按钮"><a href="#无穷计时器，有停止按钮" class="headerlink" title="无穷计时器，有停止按钮"></a><strong>无穷计时器，有停止按钮</strong></h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script&gt;var c=0;var t;var timer_is_on=0;function timedCount(){    document.getElementById(&#39;txt&#39;).value=c;    c=c+1;    t=setTimeout(function(){timedCount()},1000);}function doTimer(){    if (!timer_is_on){        timer_is_on=1;        timedCount();    }}function stopCount(){    clearTimeout(t);    timer_is_on=0;}&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt;&lt;input type=&quot;button&quot; value=&quot;开始计数!&quot; onclick=&quot;doTimer()&quot; /&gt;&lt;input type=&quot;text&quot; id=&quot;txt&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;停止计数!&quot; onclick=&quot;stopCount()&quot; /&gt;&lt;/form&gt;&lt;p&gt;单击开始计数按钮，按下时开始计数，输入框将从0开始一直计数。单击停止计数按钮，按下时停止计数，再次点击开始计数按钮，又再次开始计数。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="时钟计时器"><a href="#时钟计时器" class="headerlink" title="时钟计时器"></a><strong>时钟计时器</strong></h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;script&gt;function startTime(){    var today=new Date();    var h=today.getHours();    var m=today.getMinutes();    var s=today.getSeconds();// 在小于10的数字前加一个‘0’    m=checkTime(m);    s=checkTime(s);    document.getElementById(&#39;txt&#39;).innerHTML=h+&quot;:&quot;+m+&quot;:&quot;+s;    t=setTimeout(function(){startTime()},500);}function checkTime(i){    if (i&lt;10){        i=&quot;0&quot; + i;    }    return i;}&lt;/script&gt;&lt;/head&gt;&lt;body onload=&quot;startTime()&quot;&gt;&lt;div id=&quot;txt&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="javaScript创建对象"><a href="#javaScript创建对象" class="headerlink" title="javaScript创建对象"></a><strong>javaScript创建对象</strong></h2><p><strong>代码1</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;person={firstname:&quot;John&quot;,lastname:&quot;Doe&quot;,age:50,eyecolor:&quot;blue&quot;}document.write(person.firstname + &quot; is &quot; + person.age + &quot; years old.&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>代码2</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;function person(firstname,lastname,age,eyecolor){    this.firstname=firstname;    this.lastname=lastname;    this.age=age;    this.eyecolor=eyecolor;}myFather=new person(&quot;John&quot;,&quot;Doe&quot;,50,&quot;blue&quot;);document.write(myFather.firstname + &quot; is &quot; + myFather.age + &quot; years old.&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电脑故障</title>
      <link href="/2018/12/06/2018-12-06-%E7%94%B5%E8%84%91%E6%95%85%E9%9A%9C/"/>
      <url>/2018/12/06/2018-12-06-%E7%94%B5%E8%84%91%E6%95%85%E9%9A%9C/</url>
      
        <content type="html"><![CDATA[<p>已经不记得多久没有关闭电脑了，今天停电想着没用时把电脑关了省电，网上开机发现连不上网络了    </p><p>打开网络和共享中心—更改适配器设置，发现我的适配器找不到设备，也就是说网卡莫得了，找不到了   </p><h2 id="于是马上反思"><a href="#于是马上反思" class="headerlink" title="于是马上反思"></a><strong>于是</strong>马上反思</h2><p>发现之前我删除linux引导系统时改了系统设置</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h2><p>ctrl+ R     msconfig    回车<br>常规       有选择的启动    加载系统服务和加载启动项打勾  确定<br>重启    ojbk</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> windos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax</title>
      <link href="/2018/12/04/2018-12-06-ajax/"/>
      <url>/2018/12/04/2018-12-06-ajax/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h3><p>在ie5时就有，当时叫DHTML，几年后改名为AJAX<br>ps:<strong>面试问过</strong>：<code>要在不加载整个网页的情况下更新部分网页，应该使用什么技术？</code><br>AJAX 是一种用于创建快速动态网页的技术。<br>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。   </p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h3><p><img src="https://viabcde.github.io/images/201812/43.png" alt="enter descriptionhere"><br>AJAX是基于现有的Internet标准，并且联合使用它们：  </p><p>XMLHttpRequest 对象 (异步的与服务器交换数据)<br>JavaScript/DOM (信息显示/交互)<br>CSS (给数据定义样式)<br>XML (作为转换数据的格式)    </p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script&gt;function loadXMLDoc(){    var xmlhttp;    if (window.XMLHttpRequest)    {        //  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码        xmlhttp=new XMLHttpRequest();    }    else    {        // IE6, IE5 浏览器执行代码        xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);    }    xmlhttp.onreadystatechange=function()    {        if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)        {            document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;        }    }    xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/ajax_info.txt&quot;,true);    xmlhttp.send();}&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;myDiv&quot;&gt;&lt;h2&gt;使用 AJAX 修改该文本内容&lt;/h2&gt;&lt;/div&gt;&lt;button type=&quot;button&quot; onclick=&quot;loadXMLDoc()&quot;&gt;修改内容&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="xmlhttp-open"><a href="#xmlhttp-open" class="headerlink" title="xmlhttp.open"></a><strong>xmlhttp.open</strong></h3><p>xmlhttp.open(“GET”,”/try/ajax/ajax_info.txt”,true);<br>method：请求的类型；GET 或 POST<br>url：文件在服务器上的位置<br>async：true（异步）或 false（同步）<br><strong>method参数</strong>是必须提供的-用于指定你想用来发送请求的HTTP方法(GET，POST，PUT，DELETE或HEAD)。为了把数据发送到服务器，应该使用POST方法；为了从服务器端检索数据，应该使用GET方法<br><strong>uri参数</strong>用于指定XMLHttpRequest对象把请求发送到的服务器相应的URI。<br><strong>async参数</strong>指定是否请求是异步的-缺省值为true。为了发送一个同步请求，需要把这个参数设置为false<br>调用open()方法准备好一个请求之后，你需要把该请求发送到服务器,调用send()方法   </p><h3 id="xmlhttp-readyState"><a href="#xmlhttp-readyState" class="headerlink" title="xmlhttp.readyState"></a><strong>xmlhttp.readyState</strong></h3><p>ReadyState取值 描述<br>0  描述一种”未初始化”状态；此时，已经创建一个XMLHttpRequest对象，但是还没有初始化。<br>1  描述一种”发送”状态；此时，代码已经调用了XMLHttpRequest open()方法并且XMLHttpRequest已经准备好把一个请求发送到服务器。<br>2  描述一种”发送”状态；此时，已经通过send()方法把一个请求发送到服务器端，但是还没有收到一个响应。<br>3  描述一种”正在接收”状态；此时，已经接收到HTTP响应头部信息，但是消息体部分还没有完全接收结束。<br>4  描述一种”已加载”状态；此时，响应已经被完全接收。 </p><h3 id="xmlhttp-send"><a href="#xmlhttp-send" class="headerlink" title="xmlhttp.send()"></a><strong>xmlhttp.send()</strong></h3><p>调用open()方法准备好一个请求之后，你需要把该请求发送到服务器。仅当readyState值为1时，你才可以调用send()方法；否则的话，XMLHttpRequest对象将引发一个异常。<br>将请求发送到服务器。<br>string：仅用于 POST 请求</p><h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a><strong>XMLHttpRequest</strong></h3><p>在不重新加载页面的情况下更新网页<br>在页面已加载后从服务器请求数据<br>在页面已加载后从服务器接收数据<br>在后台向服务器发送数据<br>XMLHttpRequest 对象用于和服务器交换数据。<br>所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。<br>XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。  </p><h3 id="xmlhttp"><a href="#xmlhttp" class="headerlink" title="xmlhttp"></a><strong>xmlhttp</strong></h3><p>所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象<br>IE6及以下版本的不支持<br>所以需要判断window是否有XMLHttpRequest这个对象，没有则使用旧的对象</p><pre><code>if (window.XMLHttpRequest)    {        //  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码        xmlhttp=new XMLHttpRequest();    }    else    {        // IE6, IE5 浏览器执行代码        xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);    }</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程题</title>
      <link href="/2018/12/04/2018-9-16-%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
      <url>/2018/12/04/2018-9-16-%E7%BC%96%E7%A8%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="求二进制中1的个数"><a href="#求二进制中1的个数" class="headerlink" title="求二进制中1的个数"></a>求二进制中1的个数</h3><p>先普及一哈位逻辑运算符的知识  </p><table><thead><tr><th>OP1</th><th>OP2</th><th>&amp;</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>同为1时结果才为1  </p><table><thead><tr><th>OP1</th><th>OP1</th><th>I</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>有1结果才为1  </p><table><thead><tr><th>OP1</th><th>OP2</th><th>^</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>不同时结果才为1  </p><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>n&amp;1的是意思 判断最后一位是否为1</p><pre><code>public class Test{    public static int countOne(int n) {        int count=0;        while(n&gt;0) {            if((n&amp;1)==1)                count++;            n&gt;&gt;=1;        }        return count;    } }</code></pre><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><pre><code>public class Test{    public static int countOne(int n) {        int count=0;        while(n&gt;0) {            if(n!=0)                n=n&amp;(n-1);                count++;        }        return count;    } }</code></pre><h3 id="统计一行字符中有多少个单词"><a href="#统计一行字符中有多少个单词" class="headerlink" title="统计一行字符中有多少个单词"></a>统计一行字符中有多少个单词</h3><p>判断每个字符是否为空 空则count+1 不空则继续往后判断</p><pre><code>public class Test_plus {    public static int wordCount(String s) {        int word=0;        int count=0;        for(int i=0;i&lt;s.length();i++) {            if(s.charAt(i)==&#39; &#39;)                word=0;            else if(word==0) {//非空格且 word不等于0则word设为1                 word=1;                count++;            }        }        return count;    }}</code></pre><h3 id="判断一个数是否是2的n次方"><a href="#判断一个数是否是2的n次方" class="headerlink" title="判断一个数是否是2的n次方"></a>判断一个数是否是2的n次方</h3><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>从1即2^0 开始与n比较 相等则返回true  每次往左移一位 2^1 2^2依次比较</p><pre><code>public class Test{    public static boolean isPower(int n) {        if(n&lt;1)return false;        int i=1;        while(i&lt;=n) {            if(i==n)return true;            i&lt;&lt;=1;        }        return false;    }}</code></pre><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><pre><code>public class Test{    public static boolean isPower(int n) {    if(n&lt;1)return false;    int m=n&amp;(n-1);    return m==0;    }}</code></pre><h3 id="不用比较运算得到2个数中的较大或较小的值"><a href="#不用比较运算得到2个数中的较大或较小的值" class="headerlink" title="不用比较运算得到2个数中的较大或较小的值"></a>不用比较运算得到2个数中的较大或较小的值</h3><p>a+b加上差值 或减去差值 再除以2 妙不可言！牛批！</p><pre><code>public class Test_plus {    public static int max(int a,int b) {        return (a+b+Math.abs(a-b))/2;    }    public static int min(int a,int b) {        return(a+b-Math.abs(a-b))/2;    }}</code></pre><h3 id="移位运算实现最快乘法"><a href="#移位运算实现最快乘法" class="headerlink" title="移位运算实现最快乘法"></a>移位运算实现最快乘法</h3><pre><code>public calss Muti{//n表示左移的次数 ，用循环来控制左移 每次左移一次    public static int powerN(int m,int n){        for(int i=0;i&lt;n;i++)            m=m&lt;&lt;1;            return m;    }    public static void main(String[] args){        System.out.println(&quot;3 * 8 = &quot;+powerN(3,3));    }}</code></pre><h3 id="古典问题有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第四个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？"><a href="#古典问题有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第四个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？" class="headerlink" title="古典问题有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第四个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？"></a>古典问题有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第四个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？</h3><p>程序分析：   兔子的规律为数列1,1,2,3,5,8,13,21….<br>因此，可以使用递归 除了前2个返回是1要单独写之外 从第3个开始递归 该位置的值等于其前2个的值加和</p><pre><code>public class exp2{    public static void main(String args[]){        int i=0;        math mymath = new math();        for(i=1;i&lt;=20;i++)            System.out.println(mymath.f(i));    }}class math{    public int f(int x)    {        if(x==1 || x==2)            return 1;        else            return f(x-1)+f(x-2);    }}</code></pre><h3 id="打印出所有的-“水仙花数-“，所谓-“水仙花数-“是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个-“水仙花数-“，因为153-1的三次方＋5的三次方＋3的三次方。"><a href="#打印出所有的-“水仙花数-“，所谓-“水仙花数-“是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个-“水仙花数-“，因为153-1的三次方＋5的三次方＋3的三次方。" class="headerlink" title="打印出所有的 “水仙花数 “，所谓 “水仙花数 “是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个 “水仙花数 “，因为153=1的三次方＋5的三次方＋3的三次方。"></a>打印出所有的 “水仙花数 “，所谓 “水仙花数 “是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个 “水仙花数 “，因为153=1的三次方＋5的三次方＋3的三次方。</h3><p>1.程序分析：利用for循环控制100-999个数，每个数分解出个位，十位，百位。<br>     取百位数 ：小数点后的数省略  i=x / 100;</p><p>  取十位数 ：先取余数再省略小数点后的数     j=(x % 100) /10;</p><p> 取个位数 ：      k=x % 10;</p><pre><code>public class exp2{    public static void main(String args[]){       int i=0;       math mymath = new math();       for(i=100;i&lt;=999;i++)           if(mymath.shuixianhua(i)==true)           System.out.println(i);    }}class math{    public boolean shuixianhua(int x)    {       int i=0,j=0,k=0;       i=x / 100;       j=(x % 100) /10;       k=x % 10;       if(x==i*i*i+j*j*j+k*k*k)          return true;       else          return false;    }}</code></pre><h3 id="将一个正整数分解质因数。例如：输入90-打印出90-233-5。【不是很懂】"><a href="#将一个正整数分解质因数。例如：输入90-打印出90-233-5。【不是很懂】" class="headerlink" title="将一个正整数分解质因数。例如：输入90,打印出90=233*5。【不是很懂】"></a>将一个正整数分解质因数。例如：输入90,打印出90=2<em>3</em>3*5。【不是很懂】</h3><p>程序分析：对n进行分解质因数，应先找到一个最小的质数k，然后按下述步骤完成：</p><p>(1)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。</p><p>(2)如果n &lt;&gt; k，但n能被k整除，则应打印出k的值，并用n除以k的商,作为新的正整数你,重复执行第一步。</p><p>(3)如果n不能被k整除，则用k+1作为k的值,重复执行第一步。</p><pre><code>public class exp2{    public exp2(){}    public void fengjie(int n){        for(int i=2;i&lt;=n/2;i++){            if(n%i==0){                System.out.print(i+&quot;*&quot;);                fengjie(n/i);                }        }        System.out.print(n);        System.exit(0);///不能少这句，否则结果会出错        }        public static void main(String[] args){             String str=&quot;&quot;;             exp2 c=new exp2();             str=javax.swing.JOptionPane.showInputDialog(&quot;请输入N的值（输入exit退出）：&quot;);             int N;             N=0;             try{                     N=Integer.parseInt(str);                     }catch(NumberFormatException e){                         e.printStackTrace();                         }            System.out.print(N+&quot;分解质因数：&quot;+N+&quot;=&quot;);            c.fengjie(N);        }   }</code></pre><h3 id="【算法真的是妙不可言啊！】利用条件运算符的嵌套来完成此题：学习成绩-gt-90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。"><a href="#【算法真的是妙不可言啊！】利用条件运算符的嵌套来完成此题：学习成绩-gt-90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。" class="headerlink" title="【算法真的是妙不可言啊！】利用条件运算符的嵌套来完成此题：学习成绩&gt; =90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。"></a>【算法真的是妙不可言啊！】利用条件运算符的嵌套来完成此题：学习成绩&gt; =90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。</h3><p>1.程序分析：(a&gt; b)?a:b这是条件运算符的基本例子。</p><pre><code>import javax.swing.*;public class ex5 {        public static void main(String[] args){             String str=&quot;&quot;;             str=JOptionPane.showInputDialog(&quot;请输入N的值（输入exit退出）：&quot;);             int N;             N=0;             try{                N=Integer.parseInt(str);              }             catch(NumberFormatException e){                e.printStackTrace();               }             str=(N&gt;90?&quot;A&quot;:(N&gt;60?&quot;B&quot;:&quot;C&quot;));             System.out.println(str);        }  }</code></pre><h3 id="输入两个正整数m和n，求其最大公约数和最小公倍数。"><a href="#输入两个正整数m和n，求其最大公约数和最小公倍数。" class="headerlink" title="输入两个正整数m和n，求其最大公约数和最小公倍数。"></a>输入两个正整数m和n，求其最大公约数和最小公倍数。</h3><p>1.程序分析：利用辗除法。 </p><pre><code>最大公约数：public class CommonDivisor{    public static void main(String args[])    {        commonDivisor(24,32);    }    static int commonDivisor(int M, int N)    {        if(N&lt;0||M&lt;0)        {            System.out.println(&quot;ERROR!&quot;);            return -1;        }        if(N==0)        {            System.out.println(&quot;the biggest common divisor is :&quot;+M);            return M;        }        return commonDivisor(N,M%N);    }}最小公倍数和最大公约数：import java.util.Scanner;public class CandC{//下面的方法是求出最大公约数public static int gcd(int m, int n) {while (true) {if ((m = m % n) == 0)return n;if ((n = n % m) == 0)return m;}}public static void main(String args[]) throws Exception{//取得输入值//Scanner chin = new Scanner(System.in);//int a = chin.nextInt(), b = chin.nextInt();int a=23; int b=32;int c = gcd(a, b);System.out.println(&quot;最小公倍数：&quot; + a * b / c + &quot;\n最大公约数：&quot; + c);}}</code></pre><h3 id="【正则表达式matches】输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。"><a href="#【正则表达式matches】输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。" class="headerlink" title="【正则表达式matches】输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。"></a>【正则表达式matches】输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。</h3><p>1.程序分析：利用while语句,条件为输入的字符不为 ‘\n ‘. </p><pre><code>import java.util.Scanner;public class ex7 {     public static void main(String args[])     {      System.out.println(&quot;请输入字符串：&quot;);      Scanner scan=new Scanner(System.in);      String str=scan.next();      String E1=&quot;[\u4e00-\u9fa5]&quot;;      String E2=&quot;[a-zA-Z]&quot;;      int countH=0;      int countE=0;      char[] arrChar=str.toCharArray();      String[] arrStr=new String[arrChar.length];      for (int i=0;i&lt;arrChar.length ;i++ )      {       arrStr[i]=String.valueOf(arrChar[i]);      }      for (String i: arrStr )      {       if (i.matches(E1))       {        countH++;       }       if (i.matches(E2))       {        countE++;       }      }      System.out.println(&quot;汉字的个数&quot;+countH);      System.out.println(&quot;字母的个数&quot;+countE);     }    }</code></pre><h3 id="求s-a-aa-aaa-aaaa-aa…a的值，其中a是一个数字。例如2-22-222-2222-22222-此时共有5个数相加-，几个数相加有键盘控制。"><a href="#求s-a-aa-aaa-aaaa-aa…a的值，其中a是一个数字。例如2-22-222-2222-22222-此时共有5个数相加-，几个数相加有键盘控制。" class="headerlink" title="求s=a+aa+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制。"></a>求s=a+aa+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制。</h3><p>1.程序分析：关键是计算出每一项的值。 </p><pre><code>import java.io.*;public class Sumloop {  public static void main(String[] args) throws IOException  {      int s=0;      String output=&quot;&quot;;      BufferedReader stadin = new BufferedReader(new InputStreamReader(System.in));      System.out.println(&quot;请输入a的值&quot;);      String input =stadin.readLine();      for(int i =1;i&lt;=Integer.parseInt(input);i++)      {          output+=input;          int a=Integer.parseInt(output);          s+=a;      }      System.out.println(s);  }}另解:import java.io.*;public class Sumloop {  public static void main(String[] args) throws IOException  {      int s=0;      int n;      int t=0;      BufferedReader stadin = new BufferedReader(new InputStreamReader(System.in));      String input = stadin.readLine();      n=Integer.parseInt(input);      for(int i=1;i&lt;=n;i++){       t=t*10+n;       s=s+t;       System.out.println(t);      }      System.out.println(s);     }}</code></pre><h3 id="一个数如果恰好等于它的因子之和，这个数就称为-“完数-“。例如6-1＋2＋3-编程-找出1000以内的所有完数。"><a href="#一个数如果恰好等于它的因子之和，这个数就称为-“完数-“。例如6-1＋2＋3-编程-找出1000以内的所有完数。" class="headerlink" title="一个数如果恰好等于它的因子之和，这个数就称为 “完数 “。例如6=1＋2＋3.编程   找出1000以内的所有完数。"></a>一个数如果恰好等于它的因子之和，这个数就称为 “完数 “。例如6=1＋2＋3.编程   找出1000以内的所有完数。</h3><pre><code>public class Wanshu { public static void main(String[] args) {     int s;     for(int i=1;i&lt;=1000;i++)     {         s=0;         for(int j=1;j&lt;i;j++)         //如果余数为0说明 该除数是被除数的因子             if(i % j==0)                 s=s+j;            if(s==i)                System.out.print(i+&quot; &quot;);     }     System.out.println(); }}</code></pre><h3 id="一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在-第10次落地时，共经过多少米？第10次反弹多高？"><a href="#一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在-第10次落地时，共经过多少米？第10次反弹多高？" class="headerlink" title="一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在   第10次落地时，共经过多少米？第10次反弹多高？"></a>一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在   第10次落地时，共经过多少米？第10次反弹多高？</h3><pre><code>public class Ex10 { public static void main(String[] args) {     double s=0;     double t=100;     for(int i=1;i&lt;=10;i++)     {         s+=t;         t=t/2;     }     System.out.println(s);     System.out.println(t); }}</code></pre><h3 id="【妙不可言】有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"><a href="#【妙不可言】有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？" class="headerlink" title="【妙不可言】有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"></a>【妙不可言】有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</h3><p>1.程序分析：可填在百位、十位、个位的数字都是1、2、3、4。组成所有的排列后再去   掉不满足条件的排列。</p><pre><code>public class Wanshu { public static void main(String[] args) {    int i=0;    int j=0;    int k=0;    int t=0;    for(i=1;i&lt;=4;i++)        for(j=1;j&lt;=4;j++)            for(k=1;k&lt;=4;k++)                if(i!=j &amp;&amp; j!=k &amp;&amp; i!=k)                {t+=1;                    System.out.println(i*100+j*10+k); }     System.out.println (t);    }}</code></pre><h3 id="企业发放的奖金根据利润提成。利润-I-低于或等于10万元时，奖金可提10-；利润高于10万元，低于20万元时，低于10万元的部分按10-提成，高于10万元的部分，可提成7-5-；20万到40万之间时，高于20万元的部分，可提成5-；40万到60万之间时高于40万元的部分，可提成3-；60万到100万之间时，高于60万元的部分，可提成1-5-，高于100万元时，超过100万元的部分按1-提成，从键盘输入当月利润I，求应发放奖金总数？"><a href="#企业发放的奖金根据利润提成。利润-I-低于或等于10万元时，奖金可提10-；利润高于10万元，低于20万元时，低于10万元的部分按10-提成，高于10万元的部分，可提成7-5-；20万到40万之间时，高于20万元的部分，可提成5-；40万到60万之间时高于40万元的部分，可提成3-；60万到100万之间时，高于60万元的部分，可提成1-5-，高于100万元时，超过100万元的部分按1-提成，从键盘输入当月利润I，求应发放奖金总数？" class="headerlink" title="企业发放的奖金根据利润提成。利润(I)低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%，高于100万元时，超过100万元的部分按1%提成，从键盘输入当月利润I，求应发放奖金总数？"></a>企业发放的奖金根据利润提成。利润(I)低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%，高于100万元时，超过100万元的部分按1%提成，从键盘输入当月利润I，求应发放奖金总数？</h3><p>1.程序分析：请利用数轴来分界，定位。注意定义时需把奖金定义成长整型。 </p><pre><code>import java .util.*;public class test {    public static void main (String[]args){        double sum;//声明要储存的变量应发的奖金        Scanner input =new Scanner (System.in);//导入扫描器        System.out.print (&quot;输入当月利润&quot;);        double lirun=input .nextDouble();//从控制台录入利润        if(lirun&lt;=100000){            sum=lirun*0.1;        }else if (lirun&lt;=200000){            sum=10000+lirun*0.075;        }else if (lirun&lt;=400000){            sum=17500+lirun*0.05;        }else if (lirun&lt;=600000){            sum=lirun*0.03;        }else if (lirun&lt;=1000000){            sum=lirun*0.015;        } else{            sum=lirun*0.01;        }        System.out.println(&quot;应发的奖金是&quot;+sum);        }}</code></pre><h3 id="一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？"><a href="#一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？" class="headerlink" title="一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？"></a>一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？</h3><p>1.程序分析：在10万以内判断，先将该数加上100后再开方，再将该数加上268后再开方，如果开方后的结果满足如下条件，即是结果。请看具体分析： </p><pre><code>public class test {    public static void main (String[]args){    long k=0;    for(k=1;k&lt;=100000l;k++)        if(Math.floor(Math.sqrt(k+100))==Math.sqrt(k+100) &amp;&amp; Math.floor(Math.sqrt(k+168))==Math.sqrt(k+168))            System.out.println(k);    }}</code></pre><h3 id="输入某年某月某日，判断这一天是这一年的第几天？"><a href="#输入某年某月某日，判断这一天是这一年的第几天？" class="headerlink" title="输入某年某月某日，判断这一天是这一年的第几天？"></a>输入某年某月某日，判断这一天是这一年的第几天？</h3><p>1.程序分析：以3月5日为例，应该先把前两个月的加起来，然后再加上5天即本年的第几天，特殊情况，闰年且输入月份大于3时需考虑多加一天。 </p><pre><code>import java.util.*;public class test {    public static void main (String[]args){        int day=0;        int month=0;        int year=0;        int sum=0;        int leap;          System.out.print(&quot;请输入年,月,日\n&quot;);          Scanner input = new Scanner(System.in);        year=input.nextInt();        month=input.nextInt();        day=input.nextInt();        switch(month) /*先计算某月以前月份的总天数*/         {          case 1:            sum=0;break;          case 2:            sum=31;break;          case 3:            sum=59;break;          case 4:            sum=90;break;          case 5:            sum=120;break;          case 6:            sum=151;break;          case 7:            sum=181;break;          case 8:            sum=212;break;          case 9:            sum=243;break;          case 10:            sum=273;break;          case 11:            sum=304;break;          case 12:            sum=334;break;          default:            System.out.println(&quot;data error&quot;);break;        }          sum=sum+day; /*再加上某天的天数*/         if(year%400==0||(year%4==0&amp;&amp;year%100!=0))/*判断是不是闰年*/             leap=1;          else             leap=0;          if(leap==1 &amp;&amp; month&gt;2)/*如果是闰年且月份大于2,总天数应该加一天*/             sum++;          System.out.println(&quot;It is the the day:&quot;+sum);        }}</code></pre><h3 id="输入三个整数x-y-z，请把这三个数由小到大输出。"><a href="#输入三个整数x-y-z，请把这三个数由小到大输出。" class="headerlink" title="输入三个整数x,y,z，请把这三个数由小到大输出。"></a>输入三个整数x,y,z，请把这三个数由小到大输出。</h3><p>1.程序分析：我们想办法把最小的数放到x上，先将x与y进行比较，如果x&gt; y则将x与y的值进行交换，然后再用x与z进行比较，如果x&gt; z则将x与z的值进行交换，这样能使x最小</p><pre><code>import java.util.*;public class test {    public static void main (String[]args){        int i=0;        int j=0;        int k=0;        int x=0;        System.out.print(&quot;请输入三个数\n&quot;);          Scanner input = new Scanner(System.in);        i=input.nextInt();        j=input.nextInt();        k=input.nextInt();        if(i&gt;j)        {          x=i;          i=j;          j=x;        }        if(i&gt;k)        {          x=i;          i=k;          k=x;        }        if(j&gt;k)        {          x=j;          j=k;          k=x;        }        System.out.println(i+&quot;, &quot;+j+&quot;, &quot;+k);    }}</code></pre><h3 id="输出9-9口诀。"><a href="#输出9-9口诀。" class="headerlink" title="输出9*9口诀。"></a>输出9*9口诀。</h3><p>1.程序分析：分行与列考虑，共9行9列，i控制行，j控制列。</p><pre><code>public class jiujiu {public static void main(String[] args){    int i=0;    int j=0;    for(i=1;i&lt;=9;i++)    {   for(j=1;j&lt;=9;j++)            System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+i*j+&quot;\t&quot;);            System.out.println();    }}}不出现重复的乘积(下三角)public class jiujiu {public static void main(String[] args){    int i=0;    int j=0;    for(i=1;i&lt;=9;i++)    {   for(j=1;j&lt;=i;j++)            System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+i*j+&quot;\t&quot;);            System.out.println();    }}}上三角public class jiujiu {public static void main(String[] args){    int i=0;    int j=0;    for(i=1;i&lt;=9;i++)    {   for(j=i;j&lt;=9;j++)            System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+i*j+&quot;\t&quot;);            System.out.println();    }}}</code></pre><h3 id="猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个-第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下-的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。"><a href="#猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个-第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下-的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。" class="headerlink" title="猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个   第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下   的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。"></a>猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个   第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下   的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。</h3><p>1.程序分析：采取逆向思维的方法，从后往前推断。</p><pre><code>public class 猴子吃桃 {    static int total(int day){         if(day == 10){          return 1;         }         else{          return (total(day+1)+1)*2;         }        }public static void main(String[] args){    System.out.println(total(1));}}</code></pre><h3 id="两个乒乓球队进行比赛，各出三人。甲队为a-b-c三人，乙队为x-y-z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x-z比，请编程序找出三队赛手的名单。"><a href="#两个乒乓球队进行比赛，各出三人。甲队为a-b-c三人，乙队为x-y-z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x-z比，请编程序找出三队赛手的名单。" class="headerlink" title="两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。"></a>两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。</h3><p>1.程序分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除，   则表明此数不是素数，反之是素数。</p><pre><code>import java.util.ArrayList;public class pingpang {     String a,b,c;     public static void main(String[] args) {      String[] op = { &quot;x&quot;, &quot;y&quot;, &quot;z&quot; };      ArrayList&lt;pingpang&gt; arrayList=new ArrayList&lt;pingpang&gt;();      for (int i = 0; i &lt; 3; i++)       for (int j = 0; j &lt; 3; j++)        for (int k = 0; k &lt; 3; k++) {            pingpang a=new pingpang(op[i],op[j],op[k]);         if(!a.a.equals(a.b)&amp;&amp;!a.b.equals(a.c)&amp;&amp;!a.a.equals(&quot;x&quot;)           &amp;&amp;!a.c.equals(&quot;x&quot;)&amp;&amp;!a.c.equals(&quot;z&quot;)){          arrayList.add(a);         }        }      for(Object a:arrayList){      System.out.println(a);      }     }     public pingpang(String a, String b, String c) {      super();      this.a = a;      this.b = b;      this.c = c;     }     @Override     public String toString() {      // TODO Auto-generated method stub      return &quot;a的对手是&quot;+a+&quot;,&quot;+&quot;b的对手是&quot;+b+&quot;,&quot;+&quot;c的对手是&quot;+c+&quot;\n&quot;;     }}</code></pre><h3 id="有一分数序列：2-1，3-2，5-3，8-5，13-8，21-13…求出这个数列的前20项之和。"><a href="#有一分数序列：2-1，3-2，5-3，8-5，13-8，21-13…求出这个数列的前20项之和。" class="headerlink" title="有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13…求出这个数列的前20项之和。"></a>有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13…求出这个数列的前20项之和。</h3><p>1.程序分析：请抓住分子与分母的变化规律。</p><pre><code>public class test20 { public static void main(String[] args) {  float fm = 1f;  float fz = 1f;  float temp;  float sum = 0f;  for (int i=0;i&lt;20;i++){   temp = fm;   fm = fz;   fz = fz + temp;   sum += fz/fm;   //System.out.println(sum);  }  System.out.println(sum); }}</code></pre><h3 id="求1-2-3-…-20-的和"><a href="#求1-2-3-…-20-的和" class="headerlink" title="求1+2!+3!+…+20!的和"></a>求1+2!+3!+…+20!的和</h3><p>1.程序分析：此程序只是把累加变成了累乘。 </p><pre><code>public class Ex21 {    static long sum = 0;    static long fac = 0;    public static void main(String[] args) {       long sum = 0;       long fac = 1;       for(int i=1; i&lt;=10; i++) {        fac = fac * i;        sum += fac;       }       System.out.println(sum);    }    }</code></pre><h3 id="利用递归方法求5-。"><a href="#利用递归方法求5-。" class="headerlink" title="利用递归方法求5!。"></a>利用递归方法求5!。</h3><p>1.程序分析：递归公式：fn=fn_1*4! </p><pre><code>import java.util.Scanner;public class Ex22 {public static void main(String[] args) {   Scanner s = new Scanner(System.in);   int n = s.nextInt();   Ex22 tfr = new Ex22();   System.out.println(tfr.recursion(n));}public long recursion(int n) {   long value = 0 ;   if(n ==1 || n == 0) {    value = 1;   } else if(n &gt; 1) {    value = n * recursion(n-1);   }   return value;}}</code></pre><h3 id="有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后问第一个人，他说是10岁。请问第五个人多大？"><a href="#有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后问第一个人，他说是10岁。请问第五个人多大？" class="headerlink" title="有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后问第一个人，他说是10岁。请问第五个人多大？"></a>有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后问第一个人，他说是10岁。请问第五个人多大？</h3><p>1.程序分析：利用递归的方法，递归分为回推和递推两个阶段。要想知道第五个人岁数，需知道第四人的岁数，依次类推，推到第一人（10岁），再往回推。</p><pre><code>public class Ex23 {     static int getAge(int n){      if (n==1){       return 10;      }      return 2 + getAge(n-1);     }     public static void main(String[] args) {      System.out.println(&quot;第五个的年龄为:&quot;+getAge(5));     }    }</code></pre><h3 id="给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。"><a href="#给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。" class="headerlink" title="给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。"></a>给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。</h3><pre><code>import java.util.Scanner;public class Ex24 {public static void main(String[] args) {   Ex24 tn = new Ex24();   Scanner s = new Scanner(System.in);   long a = s.nextLong();   if(a &lt; 0 || a &gt; 100000) {    System.out.println(&quot;Error Input, please run this program Again&quot;);    System.exit(0);   }    if(a &gt;=0 &amp;&amp; a &lt;=9) {    System.out.println( a + &quot;是一位数&quot;);    System.out.println(&quot;按逆序输出是&quot; + &#39;\n&#39; + a);   } else if(a &gt;= 10 &amp;&amp; a &lt;= 99) {    System.out.println(a + &quot;是二位数&quot;);    System.out.println(&quot;按逆序输出是&quot; );    tn.converse(a);   } else if(a &gt;= 100 &amp;&amp; a &lt;= 999) {    System.out.println(a + &quot;是三位数&quot;);    System.out.println(&quot;按逆序输出是&quot; );    tn.converse(a);   } else if(a &gt;= 1000 &amp;&amp; a &lt;= 9999) {    System.out.println(a + &quot;是四位数&quot;);    System.out.println(&quot;按逆序输出是&quot; );    tn.converse(a);   } else if(a &gt;= 10000 &amp;&amp; a &lt;= 99999) {    System.out.println(a + &quot;是五位数&quot;);    System.out.println(&quot;按逆序输出是&quot; );    tn.converse(a);   }}public void converse(long l) {   String s = Long.toString(l);   char[] ch = s.toCharArray();   for(int i=ch.length-1; i&gt;=0; i--) {    System.out.print(ch[i]);   }}}</code></pre><h3 id="一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。"><a href="#一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。" class="headerlink" title="一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。"></a>一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。</h3><pre><code>import java.util.Scanner; public class Ex25 {     static int[] a = new int[5];     static int[] b = new int[5];     public static void main(String[] args) {         boolean is =false;         Scanner s = new Scanner(System.in);         long l = s.nextLong();         if (l &gt; 99999 || l &lt; 10000) {             System.out.println(&quot;Input error, please input again!&quot;);             l = s.nextLong();         }         for (int i = 4; i &gt;= 0; i--) {             a[i] = (int) (l / (long) Math.pow(10, i));            l =(l % ( long) Math.pow(10, i));             System.out.println();         for(int i=0,j=0; i&lt;5; i++, j++) {             b[j] = a[i];         }         for(int i=0,j=4; i&lt;5; i++, j--) {             if(a[i] != b[j]) {                 is = false; break;             } else {                is = true;              }          }         if(is == false) {              System.out.println(&quot;is not a Palindrom!&quot;);          } else if(is == true) {          System.out.println(&quot;is a Palindrom!&quot;);            }        }    }</code></pre><h3 id="请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续-判断第二个字母。"><a href="#请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续-判断第二个字母。" class="headerlink" title="请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续   判断第二个字母。"></a>请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续   判断第二个字母。</h3><p>1.程序分析：用情况语句比较好，如果第一个字母一样，则判断用情况语句或if语句判断第二个字母。  </p><pre><code>import java.util.Scanner;public class Ex26 { public static void main(String[] args){  //保存用户输入的第二个字母  char weekSecond;  //将Scanner类示例化为input对象，用于接收用户输入  Scanner input = new Scanner(System.in);  //开始提示并接收用户控制台输入  System.out.print(&quot;请输入星期值英文的第一个字母，我来帮您判断是星期几：&quot;);  String letter = input.next();  //判断用户控制台输入字符串长度是否是一个字母  if (letter.length() == 1){   //利用取第一个索引位的字符来实现让Scanner接收char类型输入   char weekFirst = letter.charAt(0);   switch (weekFirst){  case &#39;m&#39;:     //当输入小写字母时，利用switch结构特性执行下一个带break语句的case分支，以实现忽略用户控制台输入大小写敏感的功能    case &#39;M&#39;:      System.out.println(&quot;星期一(Monday)&quot;);     break;     case &#39;t&#39;:     //当输入小写字母时，利用switch结构特性执行下一个带break语句的case分支，以实现忽略用户控制台输入大小写敏感的功能    case &#39;T&#39;:      System.out.print(&quot;由于星期二(Tuesday)与星期四(Thursday)均以字母T开头，故需输入第二个字母才能正确判断：&quot;);     letter = input.next();     //判断用户控制台输入字符串长度是否是一个字母     if (letter.length() == 1){      //利用取第一个索引位的字符来实现让Scanner接收char类型输入      weekSecond = letter.charAt(0);      //利用或（||）运算符来实现忽略用户控制台输入大小写敏感的功能      if (weekSecond == &#39;U&#39; || weekSecond == &#39;u&#39;){       System.out.println(&quot;星期二(Tuesday)&quot;);       break;      //利用或（||）运算符来实现忽略用户控制台输入大小写敏感的功能      } else if (weekSecond == &#39;H&#39; || weekSecond == &#39;h&#39;){       System.out.println(&quot;星期四(Thursday)&quot;);       break;      //控制台错误提示      } else{       System.out.println(&quot;输入错误，不能识别的星期值第二个字母，程序结束！&quot;);       break;      }     } else {      //控制台错误提示      System.out.println(&quot;输入错误，只能输入一个字母，程序结束！&quot;);      break;     }    case &#39;w&#39;:     //当输入小写字母时，利用switch结构特性执行下一个带break语句的case分支，以实现忽略用户控制台输入大小写敏感的功能    case &#39;W&#39;:     System.out.println(&quot;星期三(Wednesday)&quot;);     break;    case &#39;f&#39;:     //当输入小写字母时，利用switch结构特性执行下一个带break语句的case分支，以实现忽略用户控制台输入大小写敏感的功能    case &#39;F&#39;:     System.out.println(&quot;星期五(Friday)&quot;);     break;    case &#39;s&#39;:     //当输入小写字母时，利用switch结构特性执行下一个带break语句的case分支，以实现忽略用户控制台输入大小写敏感的功能    case &#39;S&#39;:     System.out.print(&quot;由于星期六(Saturday)与星期日(Sunday)均以字母S开头，故需输入第二个字母才能正确判断：&quot;);     letter = input.next();     //判断用户控制台输入字符串长度是否是一个字母     if (letter.length() == 1){      //利用取第一个索引位的字符来实现让Scanner接收char类型输入      weekSecond = letter.charAt(0);      //利用或（||）运算符来实现忽略用户控制台输入大小写敏感的功能      if (weekSecond == &#39;A&#39; || weekSecond == &#39;a&#39;){       System.out.println(&quot;星期六(Saturday)&quot;);       break;      //利用或（||）运算符来实现忽略用户控制台输入大小写敏感的功能      } else if (weekSecond == &#39;U&#39; || weekSecond == &#39;u&#39;){       System.out.println(&quot;星期日(Sunday)&quot;);       break;      //控制台错误提示      } else{       System.out.println(&quot;输入错误，不能识别的星期值第二个字母，程序结束！&quot;);       break;      }     } else{      //控制台错误提示      System.out.println(&quot;输入错误，只能输入一个字母，程序结束！&quot;);      break;     }    default:     //控制台错误提示     System.out.println(&quot;输入错误，不能识别的星期值第一个字母，程序结束！&quot;);     break;   }  } else{   //控制台错误提示   System.out.println(&quot;输入错误，只能输入一个字母，程序结束！&quot;);  } }}</code></pre><h3 id="打印出如下图案（菱形）"><a href="#打印出如下图案（菱形）" class="headerlink" title="打印出如下图案（菱形）"></a>打印出如下图案（菱形）</h3><p>_*   </p><p>_***   </p><p>_<strong>**</strong>   </p><p>_<strong><em>**</em></strong>   </p><p>_<strong>**</strong>   </p><p>_***   </p><p>_*   </p><p>1.程序分析：先把图形分成两部分来看待，前四行一个规律，后三行一个规律，利用双重   for循环，第一层控制行，第二层控制列。 </p><pre><code>三角形：public class StartG {   public static void main(String [] args)   {       int i=0;       int j=0;       for(i=1;i&lt;=4;i++)       {   for(j=1;j&lt;=2*i-1;j++)               System.out.print(&quot;*&quot;);            System.out.println(&quot;&quot;);          }       for(i=4;i&gt;=1;i--)       { for(j=1;j&lt;=2*i-3;j++)               System.out.print(&quot;*&quot;);                System.out.println(&quot;&quot;);          }   } }菱形：public class StartG {   public static void main(String [] args)   {       int i=0;       int j=0;       for(i=1;i&lt;=4;i++)       {           for(int k=1; k&lt;=4-i;k++)             System.out.print(&quot; &quot;);           for(j=1;j&lt;=2*i-1;j++)               System.out.print(&quot;*&quot;);           System.out.println(&quot;&quot;);          }       for(i=4;i&gt;=1;i--)       {           for(int k=1; k&lt;=5-i;k++)                 System.out.print(&quot; &quot;);           for(j=1;j&lt;=2*i-3;j++)               System.out.print(&quot;*&quot;);            System.out.println(&quot;&quot;);          }   } }</code></pre><h3 id="题目：打印出杨辉三角形（要求打印出10行如下图）"><a href="#题目：打印出杨辉三角形（要求打印出10行如下图）" class="headerlink" title="题目：打印出杨辉三角形（要求打印出10行如下图）"></a>题目：打印出杨辉三角形（要求打印出10行如下图）</h3><p>1.程序分析：  </p><p>1  </p><p>1   1  </p><p>1   2   1  </p><p>1   3   3   1  </p><p>1   4   6   4   1  </p><p>1   5   10   10   5   1  </p><pre><code>public class Ex33 {    public static void main(String args[]){           int i,j;           int a[][];           a=new int[8][8];          for(i=0;i&lt;8;i++){             a[i][i]=1;             a[i][0]=1;            }          for(i=2;i&lt;8;i++){           for(j=1;j&lt;=i-1;j++){          a[i][j]=a[i-1][j-1]+a[i-1][j];           }          }           for(i=0;i&lt;8;i++){          for(j=0;j&lt;i;j++){            System.out.printf(&quot;  &quot;+a[i][j]);           }          System.out.println();          }         }}</code></pre><h3 id="求100之内的素数"><a href="#求100之内的素数" class="headerlink" title="求100之内的素数"></a>求100之内的素数</h3><pre><code>public class Ex27 { public static void main(String args[]) {  int sum,i;  for(sum=2;sum&lt;=100;sum++)  {   for(i=2;i&lt;=sum/2;i++)   {    if(sum%i==0)     break;   }   if(i&gt;sum/2)    System.out.println(sum+&quot;是素数&quot;);  } }}</code></pre><h3 id="输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组"><a href="#输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组" class="headerlink" title="输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组"></a>输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组</h3><pre><code>import java.util.*;public class Ex35 {public static void main(String[] args) {int i, min, max, n, temp1, temp2;int a[];System.out.println(&quot;输入数组的长度:&quot;);Scanner keyboard = new Scanner(System.in);n = keyboard.nextInt();a = new int[n];for (i = 0; i &lt; n; i++) {System.out.print(&quot;输入第&quot; + (i + 1) + &quot;个数据&quot;);a[i] = keyboard.nextInt();}//以上是输入整个数组max = 0;min = 0;//设置两个标志,开始都指向第一个数for (i = 1; i &lt; n; i++) {if (a[i] &gt; a[max])max = i; //遍历数组,如果大于a[max]，就把他的数组下标赋给maxif (a[i] &lt; a[min])min = i; //同上，如果小于a[min],就把他的数组下标赋给min}//以上for循环找到最大值和最小值，max是最大值的下标，min是最小值的下标temp1 = a[0];temp2 = a[min]; //这两个temp只是为了在交换时使用a[0] = a[max];a[max] = temp1; //首先交换a[0]和最大值a[max]if (min != 0) { //如果最小值不是a[0]，执行下面a[min] = a[n - 1];a[n - 1] = temp2; //交换a[min]和a[n-1]} else {       //如果最小值是a[0],执行下面a[max] = a[n - 1];a[n - 1] = temp1;}for (i = 0; i &lt; n; i++) { //输出数组System.out.print(a[i] + &quot; &quot;);}}}</code></pre><h3 id="海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子凭据分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？"><a href="#海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子凭据分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？" class="headerlink" title="海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子凭据分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？"></a>海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子凭据分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？</h3><pre><code>public class Dg {static int ts=0;//桃子总数int fs=1;//记录分的次数static int hs=5;//猴子数...int tsscope=5000;//桃子数的取值范围.太大容易溢出.public int fT(int t){if(t==tsscope){//当桃子数到了最大的取值范围时取消递归System.out.println(&quot;结束&quot;);return 0;}else{if((t-1)%hs==0 &amp;&amp; fs &lt;=hs){if(fs==hs){System.out.println(&quot;桃子数 = &quot;+ts +&quot; 时满足分桃条件&quot;);}   fs+=1;   return fT((t-1)/5*4);// 返回猴子拿走一份后的剩下的总数}else{//没满足条件fs=1;//分的次数重置为1return fT(ts+=1);//桃子数加+1}}}public static void main(String[] args) {new Dg().fT(0);}}</code></pre><h3 id="输入3个数a-b-c，按大小顺序输出。"><a href="#输入3个数a-b-c，按大小顺序输出。" class="headerlink" title="输入3个数a,b,c，按大小顺序输出。"></a>输入3个数a,b,c，按大小顺序输出。</h3><p>1.程序分析：利用指针方法。</p><pre><code>public class Ex34 {    public static void main(String[] args)    {    int []arrays = {800,56,500};    for(int i=arrays.length;--i&gt;=0;)    {    for(int j=0;j&lt;i;j++)    {    if(arrays[j]&gt;arrays[j+1])    {    int temp=arrays[j];    arrays[j]=arrays[j+1];    arrays[j+1]=temp;    }    }    }    for(int n=0;n&lt;arrays.length;n++)    System.out.println(arrays[n]);    }}</code></pre><h3 id="有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位"><a href="#有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位" class="headerlink" title="有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位"></a>有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位</h3><pre><code>import java.util.Scanner;public class Ex37 {    public static void main(String[] args) {           Scanner s = new Scanner(System.in);           int n = s.nextInt();           boolean[] arr = new boolean[n];           for(int i=0; i&lt;arr.length; i++) {            arr[i] = true;//下标为TRUE时说明还在圈里           }           int leftCount = n;           int countNum = 0;           int index = 0;           while(leftCount &gt; 1) {            if(arr[index] == true) {//当在圈里时             countNum ++; //报数递加             if(countNum == 3) {//报道3时              countNum =0;//从零开始继续报数              arr[index] = false;//此人退出圈子              leftCount --;//剩余人数减一             }            }            index ++;//每报一次数，下标加一            if(index == n) {//是循环数数，当下标大于n时，说明已经数了一圈，             index = 0;//将下标设为零重新开始。            }           }           for(int i=0; i&lt;n; i++) {            if(arr[i] == true) {             System.out.println(i);            }           }     }}</code></pre><h3 id="写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度"><a href="#写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度" class="headerlink" title="写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度"></a>写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度</h3><pre><code>import java.util.Scanner;public class Ex38 {public static void main(String [] args){    Scanner s = new Scanner(System.in);    System.out.println(&quot;请输入一个字符串&quot;);    String mys= s.next();    System.out.println(str_len(mys));}  public static int str_len(String x)  {      return x.length();  }}</code></pre><h3 id="取一个整数a从右端开始的4～7位。"><a href="#取一个整数a从右端开始的4～7位。" class="headerlink" title="取一个整数a从右端开始的4～7位。"></a>取一个整数a从右端开始的4～7位。</h3><p>程序分析：可以这样考虑：<br>(1)先使a右移4位。<br>(2)设置一个低4位全为1,其余全为0的数。可用~(~0 &lt; &lt;4)<br>(3)将上面二者进行&amp;运算。  </p><pre><code>import java.util.Random;public class ArraySort {  public static void main(String[] args)  {  int temp=0;      int myarr[] = new int[12];      Random r=new Random();      for(int i=1;i&lt;=10;i++)        myarr[i]=r.nextInt(1000);      for (int k=1;k&lt;=10;k++)      System.out.print(myarr[k]+&quot;,&quot;);      for(int i=1;i&lt;=9;i++)          for(int k=i+1;k&lt;=10;k++)              if(myarr[i]&gt;myarr[k])              {                  temp=myarr[i];                  myarr[i]=myarr[k];                  myarr[k]=temp;              }      System.out.println(&quot;&quot;);      for (int k=1;k&lt;=10;k++)          System.out.print(myarr[k]+&quot;,&quot;);       myarr[11]=r.nextInt(1000);       for(int k=1;k&lt;=10;k++)           if(myarr[k]&gt;myarr[11])           {               temp=myarr[11];               for(int j=11;j&gt;=k+1;j--)                   myarr[j]=myarr[j-1];               myarr[k]=temp;           }         System.out.println(&quot;&quot;);         for (int k=1;k&lt;=11;k++)              System.out.print(myarr[k]+&quot;,&quot;);  }}</code></pre><h3 id="对10个数进行排序"><a href="#对10个数进行排序" class="headerlink" title="对10个数进行排序"></a>对10个数进行排序</h3><p>1.程序分析：可以利用选择法，即从后9个比较过程中，选择一个最小的与第一个元素交换，<br>依次类推，即用第二个元素与后8个进行比较，并进行交换。  </p><pre><code>import java.util.Arrays;import java.util.Random;import java.util.Scanner;public class Ex28 { public static void main(String[] args) {  int arr[] = new int[11];  Random r=new Random();  for(int i=0;i&lt;10;i++){   arr[i]=r.nextInt(100)+1;//得到10个100以内的整数  }  Arrays.sort(arr);  for(int i=0;i&lt;arr.length;i++){   System.out.print(arr[i]+&quot;\t&quot;);  }  System.out.print(&quot;\nPlease Input a int number: &quot;);  Scanner sc=new Scanner(System.in);  arr[10]=sc.nextInt();//输入一个int值  Arrays.sort(arr);  for(int i=0;i&lt;arr.length;i++){   System.out.print(arr[i]+&quot;\t&quot;);  } }}</code></pre><h3 id="有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。"><a href="#有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。" class="headerlink" title="有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。"></a>有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。</h3><ol><li>程序分析：首先判断此数是否大于最后一个数，然后再考虑插入中间的数的情况，<br>插入后此元素之后的数，依次后移一个位置。   </li></ol><pre><code>import java.util.Random;public class ArraySort {  public static void main(String[] args)  {  int temp=0;      int myarr[] = new int[12];      Random r=new Random();      for(int i=1;i&lt;=10;i++)        myarr[i]=r.nextInt(1000);      for (int k=1;k&lt;=10;k++)      System.out.print(myarr[k]+&quot;,&quot;);      for(int i=1;i&lt;=9;i++)          for(int k=i+1;k&lt;=10;k++)              if(myarr[i]&gt;myarr[k])              {                  temp=myarr[i];                  myarr[i]=myarr[k];                  myarr[k]=temp;              }      System.out.println(&quot;&quot;);      for (int k=1;k&lt;=10;k++)          System.out.print(myarr[k]+&quot;,&quot;);       myarr[11]=r.nextInt(1000);       for(int k=1;k&lt;=10;k++)           if(myarr[k]&gt;myarr[11])           {               temp=myarr[11];               for(int j=11;j&gt;=k+1;j--)                   myarr[j]=myarr[j-1];               myarr[k]=temp;           }         System.out.println(&quot;&quot;);         for (int k=1;k&lt;=11;k++)              System.out.print(myarr[k]+&quot;,&quot;);  }}</code></pre><h3 id="列出目录下的所有的目录和文件"><a href="#列出目录下的所有的目录和文件" class="headerlink" title="列出目录下的所有的目录和文件"></a><strong>列出目录下的所有的目录和文件</strong></h3><pre><code>import java.io.File;public class Test {    public static void main(String[] args) {        File file = new File(&quot;C:\\testDir&quot;);        //判断目录是否存在        if(!file.exists()) {            System.out.println(&quot;dirctory is empty&quot;);            return;        }        File[] fileList = file.listFiles();        for(int i = 0;i&lt;fileList.length;i++) {            if(fileList[i].isDirectory()) {                System.out.println(&quot;dirctory is:&quot;+fileList[i].getName());            }else {                System.out.println(&quot;file is:&quot;+fileList[i].getName());            }        }    }}</code></pre><h3 id="获得回文字符串"><a href="#获得回文字符串" class="headerlink" title="获得回文字符串"></a><strong>获得回文字符串</strong></h3><h3 id="去除字符串的n个字符得到回文字符串-返回n"><a href="#去除字符串的n个字符得到回文字符串-返回n" class="headerlink" title="去除字符串的n个字符得到回文字符串 返回n"></a>去除字符串的n个字符得到回文字符串 返回n</h3><pre><code>/* * 用动态规划 先反转字符串，从（1，1）开始赋值同位比较相等则=左上角+1 不等则=左侧和上方中的较大值 * */import java.util.*;public class demo0920 {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        while (sc.hasNext()) {            String s1 = sc.next();            String s2 = new StringBuilder(s1).reverse().toString();            int[][] dp = new int[s1.length() + 1][s2.length() + 1];            for (int i = 1; i &lt; dp.length; i ++ ) {                for (int j = 1; j &lt; dp[0].length; j ++ ) {                    dp[i][j] = s1.charAt(i - 1) == s2.charAt(j - 1) ? dp[i - 1][j - 1] + 1 : Math.max(dp[i - 1][j], dp[i][j - 1]);                }            }            System.out.println(s1.length() - dp[s1.length()][s2.length()]);        }    }}</code></pre><p><img src="https://viabcde.github.io/images/2018-09-20/2018092001.png" alt="">  </p><h3 id="将字符串中的大写字符放到最后"><a href="#将字符串中的大写字符放到最后" class="headerlink" title="将字符串中的大写字符放到最后"></a><strong>将字符串中的大写字符放到最后</strong></h3><pre><code>import java.util.*;public class demo092001{    public static void main(String[] args){        Scanner scan = new Scanner(System.in);        while(scan.hasNext()){            String str = scan.nextLine();            System.out.println(getResult(str));        }    }    public static String getResult(String str){        //Aaaa 把大写的去除 变成 aaa 把小写的去除变成A 两者拼接aaaA        return str.replaceAll(&quot;[A-Z]&quot;,&quot;&quot;)+str.replaceAll(&quot;[a-z]&quot;,&quot;&quot;);    }}</code></pre><h3 id="奇偶倒推"><a href="#奇偶倒推" class="headerlink" title="奇偶倒推"></a><strong>奇偶倒推</strong></h3><p>有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。<br>魔法机器1:如果投入x个魔法币,魔法机器会将其变为2x+1个魔法币<br>魔法机器2:如果投入x个魔法币,魔法机器会将其变为2x+2个魔法币<br>采购魔法神器总共需要n个魔法币,所以只能通过两台魔法机器产生恰好n个魔法币,<br>设计一个投入方案最后恰好拥有n个魔法币。</p><p>2台机器1台只能产生奇数，1台只能产生偶数<br>可以通过判断结果是奇数还是偶数倒推上一次的结果，再倒推至0即可退出<br>使用StringBuiler一来大量字符串拼接效率更高，另一方面倒推的操作输出需要反向，sb有reverse可以直接调用</p><pre><code>import java.util.Scanner;public class Main {    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        while (in.hasNext()) {            int coinCount = in.nextInt();            StringBuilder sb = new StringBuilder();            while (coinCount &gt; 0) {                if (coinCount % 2 == 0) {                    //偶数                    coinCount = (coinCount - 2) / 2;                    sb.append(&quot;2&quot;);                } else {                    //奇数                    coinCount = (coinCount - 1) / 2;                    sb.append(&quot;1&quot;);                }            }            System.out.println(sb.reverse().toString());        }    }}</code></pre><h3 id="三角"><a href="#三角" class="headerlink" title="三角"></a><strong>三角</strong></h3><pre><code>public class demo0919 {    public static void main(String[] args) {        for(int y=0;y&lt;4;y++){            for(int x=0;x&lt;4;x++){                if(x&gt;y){                    System.out.print(&quot; &quot;);                }else{                    System.out.print(&quot;1&quot;);                }            }            System.out.println();        }        System.out.println(&quot;---------------------------------&quot;);        for(int y=0;y&lt;4;y++){            for(int x=0;x&lt;4;x++){                if(x&lt;3-y){                    System.out.print(&quot; &quot;);                }else{                    System.out.print(&quot;1&quot;);                }            }            System.out.println();        }        System.out.println(&quot;---------------------------------&quot;);        for(int y=0;y&lt;4;y++){            for(int x=0;x&lt;4;x++){                if(x&lt;y){                    System.out.print(&quot; &quot;);                }else{                    System.out.print(&quot;1&quot;);                }            }            System.out.println();        }        System.out.println(&quot;---------------------------------&quot;);        for(int y=0;y&lt;4;y++){            for(int x=0;x&lt;4;x++){                if(x&gt;3-y){                    System.out.print(&quot; &quot;);                }else{                    System.out.print(&quot;1&quot;);                }            }            System.out.println();        }        System.out.println(&quot;---------------------------------&quot;);        for(int y=0;y&lt;4;y++){            for(int x=0;x&lt;7;x++){                if(x&lt;3-y||x&gt;3+y){                    System.out.print(&quot; &quot;);                }else{                    System.out.print(&quot;1&quot;);                }            }            System.out.println();        }        System.out.println(&quot;---------------------------------&quot;);        for(int y=0;y&lt;4;y++){            for(int x=0;x&lt;7;x++){                if(x&lt;y||x&gt;6-y){                    System.out.print(&quot; &quot;);                }else{                    System.out.print(&quot;1&quot;);                }            }            System.out.println();        }        System.out.println(&quot;---------------------------------&quot;);    }}</code></pre><p><img src="https://viabcde.github.io/images/2018-09-21/三角形.png" alt="enter description here"><br>第一象限 x&gt;y<br>第二象限 x&lt;3-y 内层-1<br>第三象限 x<y 第四象限="" x="">3-y 内层-1<br>左右(上) x&lt;3-y||x&gt;3+y 内层-1<br>左右(下) x&lt;y||x&gt;6-y 外层-1</y></p><h3 id="StringBuiler的字符串反转"><a href="#StringBuiler的字符串反转" class="headerlink" title="StringBuiler的字符串反转"></a><strong>StringBuiler的字符串反转</strong></h3><p>为了得到一个数的”相反数”,我们将这个数的数字顺序颠倒,然后再加上原先的数得到”相反数”。例如,为了得到1325的”相反数”,首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1.</p><pre><code>import java.util.Scanner;public class Main {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        String s = sc.next();        System.out.println(Integer.parseInt(new StringBuilder(s).reverse().toString())+Integer.parseInt(s));        sc.close();    }}</code></pre><h3 id="字符串碎片的平均长度"><a href="#字符串碎片的平均长度" class="headerlink" title="字符串碎片的平均长度"></a><strong>字符串碎片的平均长度</strong></h3><p>一个由小写字母组成的字符串可以看成一些同一字母的最大碎片组成的。例如,”aaabbaaac”是由下面碎片组成的:’aaa’,’bb’,’c’。牛牛现在给定一个字符串,请你帮助计算这个字符串的所有碎片的平均长度是多少。</p><pre><code>public static void main(String[] args) {    Scanner sc = new Scanner(System.in);    while (sc.hasNext()) {        String s = sc.next();        float len = s.length();//总长        int count = 1;//个数至少为一个        for (int i = 0; i &lt; len - 1; i++) {            if (s.charAt(i) != s.charAt(i + 1)) {                count++;            }        }        System.out.println(len / count);    }}</code></pre><h3 id="兔子的规律为数列1-1-2-3-5-8-13-21…"><a href="#兔子的规律为数列1-1-2-3-5-8-13-21…" class="headerlink" title="兔子的规律为数列1,1,2,3,5,8,13,21…."></a>兔子的规律为数列1,1,2,3,5,8,13,21….</h3><pre><code>        if(x==1 || x==2)            return 1;        else            return f(x-1)+f(x-2);</code></pre><h3 id="水仙花数"><a href="#水仙花数" class="headerlink" title="水仙花数"></a>水仙花数</h3><pre><code>       int i=0,j=0,k=0;       i=x / 100;       j=(x % 100) /10;       k=x % 10;       if(x==i*i*i+j*j*j+k*k*k)          return true;       else          return false;</code></pre><h3 id="学习成绩-gt-90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示"><a href="#学习成绩-gt-90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示" class="headerlink" title="学习成绩&gt; =90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示"></a>学习成绩&gt; =90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示</h3><p>str=(N&gt;90?”A”:(N&gt;60?”B”:”C”));</p><h3 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h3><pre><code>    static int commonDivisor(int M, int N)    {        if(N&lt;0||M&lt;0)        {            System.out.println(&quot;ERROR!&quot;);            return -1;        }        if(N==0)        {            return M;        }        return commonDivisor(N,M%N);    }</code></pre><p>辗转相除法原理：用较大的除以较小的 用较小的去除以余数</p><p><img src="https://viabcde.github.io/images/2018-09-27/2018092701.png" alt="enter description here"></p><pre><code>public static int gcd(int m, int n) {while (true) {if ((m = m % n) == 0)return n;if ((n = n % m) == 0)return m;}}</code></pre><p>最小公倍数=( m*n)/最大公约数</p><h3 id="求s-a-aa-aaa-aaaa-aa…a的值，其中a是一个数字。例如2-22-222-2222-22222-此时共有5个数相加-，几个数相加有键盘控制"><a href="#求s-a-aa-aaa-aaaa-aa…a的值，其中a是一个数字。例如2-22-222-2222-22222-此时共有5个数相加-，几个数相加有键盘控制" class="headerlink" title="求s=a+aa+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制"></a>求s=a+aa+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制</h3><pre><code>      int s=0;      String output=&quot;&quot;;      BufferedReader stadin = new BufferedReader(new InputStreamReader(System.in));      System.out.println(&quot;请输入a的值&quot;);      String input =stadin.readLine();      for(int i =1;i&lt;=Integer.parseInt(input);i++)      {          output+=input;          int a=Integer.parseInt(output);          s+=a;      }</code></pre><h3 id="有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"><a href="#有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？" class="headerlink" title="有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"></a>有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</h3><pre><code>public static void main(String[] args) {    int i=0;    int j=0;    int k=0;    int t=0;    for(i=1;i&lt;=4;i++)        for(j=1;j&lt;=4;j++)            for(k=1;k&lt;=4;k++)                if(i!=j &amp;&amp; j!=k &amp;&amp; i!=k)                {t+=1;                    System.out.println(i*100+j*10+k); }     System.out.println (t);    }</code></pre><h3 id="输入某年某月某日，判断这一天是这一年的第几天？-1"><a href="#输入某年某月某日，判断这一天是这一年的第几天？-1" class="headerlink" title="输入某年某月某日，判断这一天是这一年的第几天？"></a>输入某年某月某日，判断这一天是这一年的第几天？</h3><p>if(year%400==0||(year%4==0&amp;&amp;year%100!=0))/<em>判断是不是闰年</em>/</p><h3 id="九九乘法"><a href="#九九乘法" class="headerlink" title="九九乘法"></a>九九乘法</h3><pre><code>int i=0;    int j=0;    for(i=1;i&lt;=9;i++)    {   for(j=1;j&lt;=i;j++)            System.out.print(j+&quot;*&quot;+i+&quot;=&quot;+i*j+&quot;\t&quot;);            System.out.println();    }</code></pre><h3 id="用递归实现阶乘"><a href="#用递归实现阶乘" class="headerlink" title="用递归实现阶乘"></a>用递归实现阶乘</h3><pre><code>public static long fac(int n){        if(n&lt;=0) return 0;        else if(n==1)    return 1;        else return n*fac(n-1);    }    public static void main(String [] args) {        System.out.println(fac(6));    }</code></pre><h3 id="编写一个程序，有1，2-3-4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"><a href="#编写一个程序，有1，2-3-4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？" class="headerlink" title="编写一个程序，有1，2,3,4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"></a>编写一个程序，有1，2,3,4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</h3><pre><code>public class T {    public static void main(String [] args) {           int i, j, k;           int m=0;           for(i=1;i&lt;=4;i++)              for(j=1;j&lt;=4;j++)                for(k=1;k&lt;=4;k++){                   if(i!=j&amp;&amp;k!=j&amp;&amp;i!=k){                     //双引号的作用是把打印的内容当做字符串输出 后面加的数字都自动转为字符串                       System.out.println(&quot;&quot;+i+j+k);                     m++;                   }                }            System.out.println(&quot;能组成：&quot;+m+&quot;个&quot;);    }}</code></pre><h3 id="639172每个位数上的数字都是不同的，且平方后所得数字的所有位数都不会出现组成它自身的数字。（639172-639172-408540845584），类似于639172这样的6位数还有几个？分别是什么？"><a href="#639172每个位数上的数字都是不同的，且平方后所得数字的所有位数都不会出现组成它自身的数字。（639172-639172-408540845584），类似于639172这样的6位数还有几个？分别是什么？" class="headerlink" title="639172每个位数上的数字都是不同的，且平方后所得数字的所有位数都不会出现组成它自身的数字。（639172*639172=408540845584），类似于639172这样的6位数还有几个？分别是什么？"></a>639172每个位数上的数字都是不同的，且平方后所得数字的所有位数都不会出现组成它自身的数字。（639172*639172=408540845584），类似于639172这样的6位数还有几个？分别是什么？</h3><pre><code>public void selectNum(){          for(long n = 100000; n &lt;= 999999;n++){               if(isSelfRepeat(n))                    //有相同的数字，则跳过                continue;               else if(isPingFangRepeat(n*n,n)){    //该数的平方中是否有与该数相同的数字                continue;               }            else{                                //符合条件，则打印                   System.out.println(n);             }           }      }    public boolean isSelfRepeat(long n){        HashMap&lt;Long,String&gt; m=new HashMap&lt;Long,String&gt;();        //存储的时候判断有无重复值 每次取最后一位数判断是否已重复 没有则放入hashmap//再利用/去掉最后一位数 再重新对新的最后一位数进行判断        while(n!=0){            if(m.containsKey(n%10)){                return true;            }            else{                m.put(n%10,&quot;1&quot;);            }            n=n/10;        }        return false;    }    public boolean isPingFangRepeat(long pingfang,long n){        HashMap&lt;Long,String&gt; m=new HashMap&lt;Long,String&gt;();        while(n!=0){            m.put(n%10,&quot;1&quot;);            n=n/10;        }        while(pingfang!=0){            if(m.containsKey(pingfang%10)){                return true;            }            pingfang=pingfang/10;        }        return false;    }    public static void main(String args[]){        new test().selectNum();    }</code></pre><p><img src="https://viabcde.github.io/images/2018-09-27/2018092702.png" alt="enter description here"></p><pre><code>public class testClockwiseOutput {     //顺时针打印一个矩阵     @Test public void test(){ //初始化矩阵        int[][] num = new int[100][100];         int n = 4;         int count =1;         for(int i=0;i&lt;n;i++){             for(int j =0;j&lt;n;j++){                 num[i][j]=count++;             }         }         output(num,0,n-1);     }     //使用递归每次递归输出一圈    public void output(int[][] num,int start,int end){         if(start&gt;=end || end&lt;=0)return;         //输出上面的一行        for(int i=start;i&lt;=end;i++){             System.out.println(num[start][i]);         }         //输出右侧一列        for(int i=start+1;i&lt;=end;i++){             System.out.println(num[i][end]);         }          //输出下面一行 for(int i=end-1;i&gt;=start;i--){             System.out.println(num[end][i]);         }         //输出左侧一列for(int i=end-1;i&gt;start;i--){             System.out.println(num[i][start]);         }         //递归重复操作        output(num,start+1,end-1);     } }</code></pre><h3 id="给出一个排序好的数组和一个数，求数组中连续元素的和等于所给数-并输出该子数组"><a href="#给出一个排序好的数组和一个数，求数组中连续元素的和等于所给数-并输出该子数组" class="headerlink" title="给出一个排序好的数组和一个数，求数组中连续元素的和等于所给数 并输出该子数组"></a>给出一个排序好的数组和一个数，求数组中连续元素的和等于所给数 并输出该子数组</h3><pre><code>@Test public void test(){ //初始化        int[] num = {1,2,2,3,4,5,6,7,8,9};         int sum = 7;         findSum(num,sum);     }     public void findSum(int[] num,int sum){         int left=0;         int right=0;         for(int i=0;i&lt;num.length;i++){             int curSum = 0;             left = i;             right = i;             //把当前数组从左开始累加至大于给定的数即停止while(curSum&lt;sum){                 curSum += num[right++];             }            //停止后判断是否与给定数相等 不等则继续循环从左侧第2个数开始累加            if(curSum==sum){                 for(int j=left;j&lt;right;j++){                     System.out.print(num[j]+&quot; &quot;);                 }                 System.out.println();             }         }     }</code></pre><h3 id="用二分法查找已排序好的字母中的随机一个字母的下标"><a href="#用二分法查找已排序好的字母中的随机一个字母的下标" class="headerlink" title="用二分法查找已排序好的字母中的随机一个字母的下标"></a>用二分法查找已排序好的字母中的随机一个字母的下标</h3><pre><code>public class Test5{    public static int binarySearch(char[] b,char c){        int min=0,max=b.length-1,mid=0;        while(min&lt;=max){         mid=(max+min)/2;            if(c&lt;b[mid])                max=mid-1;            else if(c&gt;b[mid]){                min=mid+1;            System.out.println(&quot;hello&quot;);}            else                break;                                    }        return mid;    }    public static void main(String[] args) {        char[] a={&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;};        System.out.println(&quot;g在数组中的下标是&quot;+binarySearch(a,&#39;g&#39;));    }}</code></pre><h3 id="编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串，但要保证汉字不被截取半个，-如“我ABC”，4，应该截取“我AB”，输入“我ABC汉DEF”，6，应该输出“我ABC”，而不是“我ABC-汉的半个”。"><a href="#编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串，但要保证汉字不被截取半个，-如“我ABC”，4，应该截取“我AB”，输入“我ABC汉DEF”，6，应该输出“我ABC”，而不是“我ABC-汉的半个”。" class="headerlink" title="编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串，但要保证汉字不被截取半个， 如“我ABC”，4，应该截取“我AB”，输入“我ABC汉DEF”，6，应该输出“我ABC”，而不是“我ABC+汉的半个”。"></a>编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串，但要保证汉字不被截取半个， 如“我ABC”，4，应该截取“我AB”，输入“我ABC汉DEF”，6，应该输出“我ABC”，而不是“我ABC+汉的半个”。</h3><p>分析：字符串打散成字节之后输出的字节值变成了正数和负数，字符为一个正数，汉字为两个负数<br>所以为了不输出半个汉字，可以判断负数的个数，然后确定截取数到底是多少，通过new String(buf,0,len)的构造方法把字节转换成字符串</p><pre><code>import java.util.Scanner;public class T {    public static void main(String[] args) {        Scanner scan=new Scanner(System.in);        while(true) {            System.out.println(&quot;请输入一个带中文的字符串，和要截取的字节数：&quot;);            String str=scan.next();            int num=scan.nextInt();            byte[] buf=str.getBytes();            if(num&lt;=buf.length) {                System.out.println(&quot;输入正确，即将截取字符串...&quot;);                int times=0;                for(int i=0;i&lt;num;i++) {                    System.out.println(buf[i]);                    if(buf[i]&lt;0) {                        times++;                    }                }                if(times%2==1) {                    num--;                }                String out=new String(buf,0,num);//字节转成字符串                System.out.println(&quot;截取的字符串是：&quot;+out);                System.out.println();            }else {                try {                    throw new MyException(&quot;截取字节数超出字符串长度．．．&quot;);                } catch (MyException e) {                    e.printStackTrace();                }            }        }    }}class MyException extends Exception{    public MyException(String msg) {        super(msg);    }}</code></pre><h3 id="数组中相加等于20的组合-的集合"><a href="#数组中相加等于20的组合-的集合" class="headerlink" title="数组中相加等于20的组合 的集合"></a>数组中相加等于20的组合 的集合</h3><pre><code>import java.util.Arrays;import java.util.HashMap;import java.util.Iterator;import java.util.Map;/**先从小到大排序 首尾相加若小于20则把小的去除（即begin指针往前(右边)移）*首尾相加若大于20则把小的去除（即end指针往前（左边）移）*/public class Test_plus {    public static void findSum(int[] a,int sum) {        Arrays.sort(a);        int begin=0;        int end=a.length-1;        while(begin&lt;end) {            if(a[begin]+a[end]&lt;sum)                begin++;            else if(a[begin]+a[end]&gt;sum)                end--;            else {                System.out.println(a[begin]+&quot;,&quot;+a[end]);                begin++;                end--;            }        }    }    public static void main(String[] args) {        int array[]= {1,7,17,2,6,3,14};        findSum(array, 20);    }}</code></pre><h3 id="取出数组中重复最多的数"><a href="#取出数组中重复最多的数" class="headerlink" title="取出数组中重复最多的数"></a>取出数组中重复最多的数</h3><pre><code>思路：把数组中的每个元素作为key存到map中 如果map没有value 设为1 有则value+1然后用类似于选择排序的算法取出value 最大的那个value 的key即可import java.util.HashMap;import java.util.Iterator;import java.util.Map;/**利用map key唯一性 唯一来存储数组的原数，而每遍历map中判断出已有key（即已有相同元素）存在，则key对应的value+1*若没有，则把元素设为key，value设为1*/public class Test_plus {    public static int findMostFrequentInArray(int[] a) {        int result = 0;        int size = a.length;        if(size==0)            return Integer.MAX_VALUE;        Map&lt;Integer,Integer&gt;m=new HashMap&lt;Integer,Integer&gt;();        //开始遍历数组，往map中设置数组中每个元素(对应map中的key)对应出现的次数(对应map中的value)        for(int i=0;i&lt;size;i++) {            if(m.containsKey(a[i])) {                m.put(a[i], m.get(a[i])+1);            }            else {                m.put(a[i], 1);            }        }        int most=0;        Iterator iter = m.entrySet().iterator();        //开始遍历 比较map中每个key对应的value，取最大值，返回        while(iter.hasNext()) {            Map.Entry entry = (Map.Entry) iter.next();            int key=(Integer)entry.getKey();            int val=(Integer)entry.getValue();            if(val&gt;most) {                result=key;                most=val;            }        }        return result;    }    public static void main(String[] args) {        int[] array= {1,5,4,3,4,4,5,4,5,5,6,6,6,6,6};        int maxFrequenceNum=findMostFrequentInArray(array);        System.out.println(maxFrequenceNum);    }}</code></pre><h3 id="将数组移k位右"><a href="#将数组移k位右" class="headerlink" title="将数组移k位右"></a>将数组移k位右</h3><pre><code>思路 ： 反转的算法 *3次即可先把 第 k-n-1 反转把0 -k-1 反转整体反转 即可//把数组循环右移K位public class Test_plus {    /*    *数组倒序算法，循环首尾互换    */    public static void reverse(int[] a,int b,int e) {        for(;b&lt;e;b++,e--) {            int temp=a[e];            a[e]=a[b];            a[b]=temp;        }    }    public static void shift_k(int[] a,int k) {        int n=a.length;        //右移k位和右移n+k位等价        k=k%n;        //将倒数第k个和最后一个之间的数组段对换循环        reverse(a,n-k,n-1);        //将第一个和第倒数第k-1个数对换        reverse(a,0,n-k-1);        //将第一个数和最后一个数之间的数对换        reverse(a,0,n-1);    }    public static void main(String[] args) {        int array[]= {1,2,3,4,5,6,7,8};        shift_k(array, 2);        for(int i=0;i&lt;array.length;i++) {            System.out.println(array[i]+&quot;&quot;);        }    }}</code></pre><h3 id="判断两个字符串是否有相同字符（每个字母的个数也相同）组成"><a href="#判断两个字符串是否有相同字符（每个字母的个数也相同）组成" class="headerlink" title="判断两个字符串是否有相同字符（每个字母的个数也相同）组成"></a>判断两个字符串是否有相同字符（每个字母的个数也相同）组成</h3><pre><code>初始化一个字符串数组 每个位赋值为0 即 0000 0000 0000 0000...对第一个字符串 s1 转成的每个字节 如425154 在对应位置上加1 如4则在 第四的位置加1 0001 0000 0000 0000 ...对第二个字符串 s2 转成的每个字节 如425154 在对应位置上则减1最后只要 这个数组有一个元素不等于0 则说明 2个字符串不相等import java.util.Arrays;//空间换时间public class Test_plus {    public static void compare(String s1,String s2) {        byte[]b1=s1.getBytes();        byte[]b2=s2.getBytes();        int[]bCount=new int[256];        for(int i=0;i&lt;256;i++) {            bCount[i]=0;        }        for(int i=0;i&lt;b1.length;i++)            bCount[b1[i]-&#39;0&#39;]++;        for(int i=0;i&lt;b2.length;i++)            bCount[b2[i]-&#39;0&#39;]--;        for(int i=0;i&lt;256;i++)            if(bCount[i]!=0) {                System.out.println(&quot;not equal&quot;);                return;            }        System.out.println(&quot;equal&quot;);    }    public static void main(String[] args) {        String s1=&quot;aaabbc&quot;;        String s2=&quot;abcbaaa&quot;;        compare(s1, s2);        s1=&quot;aaaabbc&quot;;        s2=&quot;abcbaab&quot;;        compare(s1, s2);    }}</code></pre><h3 id="找出数组中只出现1次的数"><a href="#找出数组中只出现1次的数" class="headerlink" title="找出数组中只出现1次的数"></a>找出数组中只出现1次的数</h3><pre><code>任何数字异或自己都等于0，两次重复的数字异或之后抵消，最后剩下只有1个的数字知识点：任何数字异或0等于自身按位与 a&amp;b 只有双方为1 才为1 按位或 | 其中一方有1 才为1按位异或 ^ 双方相同 为0 不同为 1注意：本方法只适合于其他数字都出现偶次数才能用public class Test_plus {    public static int findNotDouble(int[] a) {        int n=a.length;        int result=a[0];        int i;        for(i=1;i&lt;n;++i)            result ^= a[i];        return result;    }    public static void main(String[] args) {        int array[]= {1,2,3,2,4,3,5,4,1};        int num = findNotDouble(array);        System.out.println(num);    }}</code></pre><h3 id="单词反转"><a href="#单词反转" class="headerlink" title="单词反转"></a>单词反转</h3><pre><code>思路：实现字符串首尾反转 即对how are you 全反转 uoy era woh再对每一个单词进行单独反转 （每读取到 &#39; &#39; 即对前面的字符串进行反转一次）因为最后一个单词的后面没有 &#39; &#39; 所以需要单独反转//数组中只有一个数组出现过1次，其他的都出现了3次public class s {    //把数组首尾元素交换    public void swap(char[] cArr,int front,int end) {        while(front&lt;end) {            char tmp=cArr[end];            cArr[end]=cArr[front];            cArr[front]=tmp;            front++;            end--;        }    }    public String swapWords(String s) {        //对how are you 全反转 uoy era woh        char[] cArr=s.toCharArray();        swap(cArr,0,cArr.length-1);        //对 当个单词进行反转 uoy - you; era - are ; woh -how(找不到 &#39; &#39;  无法反转)        int begin=0;        for(int i=1;i&lt;cArr.length;i++) {        if(cArr[i]==&#39; &#39;) {            swap(cArr,begin,i-1);            begin=i+1;        }    }        //所以要把最后一个单词单独反转 woh -how    swap(cArr,begin,cArr.length-1);    return new String(cArr);    }    public static void main(String[] args) {        String str=&quot;how are you&quot;;            System.out.println(new s().swapWords(str));    }}</code></pre><h3 id="数组中2个元素的最小距离"><a href="#数组中2个元素的最小距离" class="headerlink" title="数组中2个元素的最小距离"></a>数组中2个元素的最小距离</h3><pre><code># 思路 ： 当同时找到2个元素时才开始比较两者之间的距离 使用最新的下标进行比较import java.util.concurrent.atomic.AtomicInteger;//数组中只有一个数组出现过1次，其他的都出现了3次public class s {    private static int min(int a,int b) {        return a&gt;b?b:a;    }    public static int minDistance(int[] a,int n1,int n2) {        if(a==null)            return Integer.MIN_VALUE;        int len=a.length;        int n1_index=-1;        int n2_index=-1;        int min_dist=Integer.MIN_VALUE+1;        System.out.println(min_dist);        System.out.println(Math.abs(min_dist));        for(int i=0;i&lt;len;++i) {            //当首次第一个元素与第二个元素同时存在时才执行下面语句            if(a[i]==n1) {                n1_index=i;                if(n2_index&gt;=0)                    min_dist=min(Math.abs(min_dist),Math.abs(n1_index-n2_index));                System.out.println(min_dist);            }            if(a[i]==n2) {                n2_index=i;                if(n1_index&gt;=0)                    min_dist=min(Math.abs(min_dist),Math.abs(n2_index-n1_index));                System.out.println(min_dist);            }        }        return min_dist;    }    public static void main(String[] args) {        int[] a= {0,1,2,3,4,5,6,7,8};        System.out.println(minDistance(a, 0, 7));    }}</code></pre><h3 id="求数组第二大的数（选择排序）"><a href="#求数组第二大的数（选择排序）" class="headerlink" title="求数组第二大的数（选择排序）"></a>求数组第二大的数（选择排序）</h3><pre><code>定义一个最大 和第二大的数 每次循环都判断数组中是否有比最大的数大的有则交换两者的值同时 把原来最大数的值赋值给第二大的public class SecondMax {    public static int FindSecMax(int[] data) {        int count = data.length;        int maxnumber = data[0];        int sec_max = Integer.MIN_VALUE;        for(int i = 1;i&lt;count;i++) {            if(data[i]&gt;maxnumber) {                sec_max = maxnumber;                maxnumber=data[i];            }            else {                if(data[i]&gt;sec_max)                    sec_max = data[i];            }        }        return sec_max;    }    public static void main(String[] args) {        // TODO Auto-generated method stub        int[] array = {7,3,19,40,4,7,1};        System.out.println(FindSecMax(array));    }}</code></pre><h3 id="反射机制示例"><a href="#反射机制示例" class="headerlink" title="反射机制示例"></a>反射机制示例</h3><pre><code>/*获取class类*/*class.forName(&quot;类的路径&quot;)*类名.class*实例名.getClass()*/class Base {     public void f() {         System.out.println(&quot;Base&quot;);     }}class Sub extends Base{     public void f() {         System.out.println(&quot;Sub&quot;);     }}public class Test_Base {    public static void main(String[] args) {        try {            Class c = Class.forName(&quot;Sub&quot;);            Base b = (Base)c.newInstance();            b.f();        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><h3 id="HashMap可插入相同key的错觉-hashcode不同-equals-相等"><a href="#HashMap可插入相同key的错觉-hashcode不同-equals-相等" class="headerlink" title="HashMap可插入相同key的错觉(hashcode不同 equals 相等)"></a>HashMap可插入相同key的错觉(hashcode不同 equals 相等)</h3><pre><code>test1()是正常情况：当插入 相同key 时 后者会把前者覆盖test2()是因为插入的key p1 和 p2是2个实例对象 虽然他们在内存中的首地址不同，但他们的实际内容是相同的所以p1和p2 的 Person类必须实现 hashcode 和equals方法 以防止 插入相同内容的keyimport java.util.HashMap;import java.util.Iterator;import java.util.Map;public class TestPerson {    public static void test1() {        System.out.println(&quot;User user defined class as key&quot;);        HashMap&lt;String,String&gt;hm = new HashMap&lt;String,String&gt;();        hm.put(&quot;aaa&quot;,&quot;bbb&quot;);        hm.put(&quot;aaa&quot;,&quot;ccc&quot;);        Iterator iter = hm.entrySet().iterator();        while(iter.hasNext()) {            Map.Entry entry = (Map.Entry)iter.next();            String key = (String)entry.getKey();            String val = (String)entry.getValue();            System.out.println(key+&quot;     &quot;+val);        }    }    public static void test2(){        System.out.println(&quot;Use String as Key:&quot;);        HashMap&lt;Person,String&gt;hm = new HashMap&lt;Person,String&gt;();        Person p1 = new Person(&quot;111&quot;, &quot;name1&quot;);        Person p2 = new Person(&quot;111&quot;, &quot;name1&quot;);        hm.put(p1,&quot;address1&quot;);        hm.put(p2,&quot;address2&quot;);        Iterator iter = hm.entrySet().iterator();        while(iter.hasNext()) {            Map.Entry entry = (Map.Entry)iter.next();            Person key = (Person)entry.getKey();            String val = (String)entry.getValue();            System.out.println(key+&quot;     &quot;+val);        }    }    public static void main(String[] args) {        // TODO Auto-generated method stub        test1();        System.out.println(&quot; &quot;);        test2();    }}实现 hashcode和equalsimport java.util.*; class Person {     String id;     String name;     public int hashCode() {         return id.hashCode();     }     public Person(String id,String name) {         this.id = id;         this.name = name;     }     public String toString() {         return &quot;id =&quot;+id+&quot;,name = &quot;+name;     }     public boolean equals(Object obj) {            Person p = (Person) obj;            if(p.id.equals(this.id))                return true;            else                return false;        }}</code></pre><h3 id="斐波那契函数"><a href="#斐波那契函数" class="headerlink" title="斐波那契函数"></a><strong>斐波那契函数</strong></h3><pre><code>public class Demo2 {    // 定义三个变量方法    public static void main(String[] args) {        int a = 1, b = 1, c = 0;        System.out.println(&quot;斐波那契数列前20项为：&quot;);        System.out.print(a + &quot;\t&quot; + b + &quot;\t&quot;);        //因为前面还有两个1、1 所以i&lt;=18        for (int i = 1; i &lt;= 18; i++) {            c = a + b;            a = b;            b = c;            System.out.print(c + &quot;\t&quot;);            if ((i + 2) % 5 == 0)                System.out.println();        }    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础1</title>
      <link href="/2018/12/04/2018-9-15-%E7%AC%AC%E4%BA%8C%E7%AF%87/"/>
      <url>/2018/12/04/2018-9-15-%E7%AC%AC%E4%BA%8C%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="环境变量path和classpath的作用是什么？"><a href="#环境变量path和classpath的作用是什么？" class="headerlink" title="环境变量path和classpath的作用是什么？"></a><strong>环境变量path和classpath的作用是什么？</strong></h3><p>(1)path是配置Windows可执行文件的搜索路径，即扩展名为.exe的程序文件所在的目录，用于指定DOS窗口命令的路径。<br>(2)Classpath是配置class文件所在的目录，用于指定类搜索路径，JVM就是通过它来寻找该类的class类文件的。    </p><h3 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别?"></a><strong>&amp;和&amp;&amp;的区别?</strong></h3><p>&amp;既可以判断true/false，也可以进行数之间的运算<br>&amp;&amp;一般用于判断表达式ture/false   </p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h3><p>(1)基本数据类型(4类8种)：<br>整数类型：byte、short（2）、int（4）、long（8）<br>浮点数类型：float（4）、double（8）<br>字符类型：char（2）<br>布尔类型：boolean（1）<br>(2)引用数据类型：<br>    类<br>    接口<br>    数组    </p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h3><p>一是为了代码的可复用性   二是为了代码的易读性   </p><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a><strong>内存结构</strong></h3><p>栈内存：用于存储局部变量，当数据使用完，所占空间会自动释放。<br>堆内存：数组和对象，通过new建立的实例都存放在堆内存中。<br>方法区：静态成员、构造函数、常量池、线程池<br>本地方法区：window系统占用  </p><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a><strong>类和对象</strong></h3><p>类：对现实世界中某类事物的描述,是抽象的，概念上的定义。<br>对象：事物具体存在的个体。   </p><h3 id="成员变量和局部变量的区别-重点"><a href="#成员变量和局部变量的区别-重点" class="headerlink" title="成员变量和局部变量的区别(重点)"></a><strong>成员变量和局部变量的区别(重点)</strong></h3><p>(1)作用域<br>成员变量：针对整个类有效。<br>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)<br>(2)存储位置<br>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。<br>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。<br>当方法调用完，或者语句结束后，就自动释放。<br>(3)初始值<br>成员变量：有默认初始值。<br>局部变量：没有默认初始值，使用前必须赋值。   </p><h3 id="构造方法，构造代码块，成员方法"><a href="#构造方法，构造代码块，成员方法" class="headerlink" title="构造方法，构造代码块，成员方法"></a><strong>构造方法，构造代码块，成员方法</strong></h3><p>构造方法和类名相同，并且没有返回类型，也没有返回值，用于给对象初始化<br>构造代码块是给所有不同对象的共性进行统一初始化，而且优先于构造函数执行<br>普通成员方法是由创建好的对象调用，可以调用多次   </p><h3 id="Person-p-new-Person-在内存中做了哪些事情"><a href="#Person-p-new-Person-在内存中做了哪些事情" class="headerlink" title="Person p = new Person();在内存中做了哪些事情"></a><strong>Person p = new Person();在内存中做了哪些事情</strong></h3><p>(1)将Person.class文件加载进内存中。<br>(2)在栈空间开辟一个变量空间p。<br>(3)在堆内存给对象分配空间。<br>(4)对对象中的成员进行默认初始化。<br>(5)对对象中的成员进行显示初始化。<br>(6)调用构造代码块对对象进行初始化。(如果没有就不执行)<br>(7)调用构造方法对对象进行初始化。对象初始化完毕。<br>(8)将对象的内存地址赋值给p变量，让p变量指向该对象。  </p><h3 id="public-static-void-main-String-args"><a href="#public-static-void-main-String-args" class="headerlink" title="public static void main(String[] args)"></a><strong>public static void main(String[] args)</strong></h3><p>public:公共的意思，是最大权限修饰符。<br>static:由于jvm调用main方法的时候，没有创建对象，只能通过类名调用。所以，main必须用static修饰。<br>void:由于main方法是被jvm调用，不需要返回值。用void修饰。<br>main:main是主要的意思，所以jvm采用了这个名字。是程序的入口。<br><code>String[]</code>:字符串数组<br>args:数组名    </p><h3 id="静态变量和成员变量的区别"><a href="#静态变量和成员变量的区别" class="headerlink" title="静态变量和成员变量的区别"></a><strong>静态变量和成员变量的区别</strong></h3><p>A：调用方式<br>    静态变量也称为类变量，可以直接通过类名调用。也可以通过对象名调用。<br>    这个变量属于类。<br>    成员变量也称为实例变量，只能通过对象名调用。这个变量属于对象。<br>B：存储位置<br>    静态变量存储在方法区长中的静态区。<br>    成员变量存储在堆内存。<br>C：生命周期<br>    静态变量随着类的加载而存在，随着类的消失而消失。生命周期长。<br>    成员变量随着对象的创建而存在，随着对象的消失而消失。<br>D：与对象的相关性<br>    静态变量是所有对象共享的数据。<br>    成员变量是每个对象所特有的数据。  </p><h3 id="静态的优点和弊端"><a href="#静态的优点和弊端" class="headerlink" title="静态的优点和弊端"></a><strong>静态的优点和弊端</strong></h3><p>优点：<br>    对对象的共享数据进行单独空间的存储，节省内存，没有必要每个对象都存储一份，可直接被类名调用<br>弊端：<br>    生命周期过长，随着类的消失而消失<br>    访问出现权限，即静态虽好但只能访问静态    </p><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a><strong>单例设计模式</strong></h3><p>单例设计模式的两种方式<br>A:饿汉式 当类加载的时候，就创建对象。    </p><pre><code>class Student{private Student(){}private static final Student s = new Student();public static Student getInstance(){return s;}}</code></pre><p>B:懒汉式 当使用的使用，才去创建对象。  </p><pre><code>class Student{private Student(){}private static final Student s = null;public static Student getInstance(){if(s==null) {//线程1就进来了，线程2就进来了。s = new Student();    }    return s;    }    }</code></pre><p>注：开发常用饿汉式，因为饿汉式简单安全。懒汉式多线程的时候容易发生问题，因为可能多个线程都同时进入到if判断语句，可能会创建多个对象 ###   <strong>子类的实例化过程</strong><br>子类创建对象时，会先去创建父类的对象。<br>默认是去调用父类的无参构造方法。<br>子类构造方法中，第一行默认是super()<br>因为他继承父类的成员使用，使用前这些成员必须初始化，而他们是父类的成员，所以，必须通过父类进行初始化。<br>所以，会先创建一个父类的对象。当父类没有无参构造方法时,必须使用this或者super调用其他的构造方法。<br><strong>this和super的区别</strong><br>this:代表本类对象的引用。<br>super:代表父类的存储空间。    </p><h3 id="数组和集合都是容器，两者有何不同？"><a href="#数组和集合都是容器，两者有何不同？" class="headerlink" title="数组和集合都是容器，两者有何不同？"></a><strong>数组和集合都是容器，两者有何不同？</strong></h3><p>数组长度固定，而集合长度是可变的<br>数组值可以存储对象，还可以存储基本数据类型;而集合只能存储对象<br>数组存储数据类型是固定的，而集合存储的数据类型不固定<br>List:列表，元素是有序的(元素带角标索引)，可以有重复元素,可以有null元素<br>ArrayList(JDK1.2):底层的数据结构是数组数据结构，特点是查询速度快(因为带角标)，但是增删速度稍慢,因为当元素多时，增删一个元素则所有元素的角标都得改变，线程不同步。默认长度是10，当超过长度时，按50%延长集合长度。<br>LinkedList(JDK1.2):底层数据结构式链表数据结构(即后面一个元素记录前一个)，<br>    特点：查询速度慢，因为每个元素只知道前面一个元素，但增删速度快<br>    因为元素再多，增删一个，只要让其前后的元素重新相连即可<br>    线程是不同步的。<br>Vector(JDK1.0):底层数据结构是数组数据结构.特点是查询和增删速度都很慢。<br>    默认长度是10，当超过长度时,按100%延长集合长度。<br>    线程同步。<br>(Vector功能跟ArrayList功能一模一样，已被ArrayList替代)<br>如果要求增删快，考虑使用LinkedList<br>如果要求查询快，考虑使用ArrayList<br>如果要求线程安全，考虑使用Vector。<br>Set:集合，元素是无序的(因为没有索引)，元素不可以重复。可以有null元素。<br>HashSet(JDK1.2):底层数据结构是哈希表、存取速度快、元素唯一、线程不同步。<br>TreeSet:底层数据结构式二叉树。可以对Set集合中的元素进行排序。元素有序、线程不同步。<br>Map<br>HashTable(JDK1.0):<br>底层是哈希表数据结构；<br>    不可以使用null键和null值；<br>    用作键的对象必须实现hashCode和equals方法来保证键的唯一性<br>    线程同步，效率低<br>|—&gt;HashMap(JDK1.2):<br>底层是哈希表数据结构；<br>    允许使用null键和null值；<br>    线程不同步，效率高；<br>    保证元素唯一性的:<br>    如果你想将一组对象按一定顺序存取，在不考虑并发访问的情况下会使用<code>____C_____ ,</code><br>反之则会使用<code>____A_____；</code>如果你想存储一组无序但唯一的对象，你会使用<code>___B______ ;</code><br>如果你想按关键字对对象进行存取，在不考虑并发访问的情况下会使用<code>___D______</code> ,反之则会使用<code>_____E____。</code><br>A. Vector<br>B. HashSet<br>C. ArrayList<br>D. HashMap<br>E. Hashtable<br>(1)字节流<br>    输出字节流：OutputStream：字节写入流抽象类<br>|—&gt;FileOutputStream：<br>    字节写入流<br>|—&gt;BufferedOutputStream：<br>    字节写入流缓冲区<br>|—&gt;PrintStream：<br>    打印流<br>    输入字节流：InputStream：字节读取流抽象类<br>|—&gt;FileInputStream：<br>    字节读取流<br>|—&gt;BufferedInputStream：<br>    字节读取流缓冲区<br>(2)字符流<br>    输出字符流：Writer：字符写入流的抽象<br>|—&gt;FileWriter：<br>    字符写入流<br>|—&gt;BufferedWriter：<br>    字符写入流缓冲区<br>|—&gt;OutputStreamWriter：<br>    字符通向字节的转换流(涉及键盘录入时用)<br>    |—&gt;OutputStreamWriter：<br>    打印流，可处理各种类型的数据<br>    输入字符流：Reader: 字符读取流的抽象类<br>|—&gt;FileReader：<br>    字符读取流<br>|—&gt;LineNumberReader：<br>    跟踪行号的缓冲字符读取流<br>|—&gt;BufferedReader：<br>    字符读取流缓冲区<br>|—&gt;InputStreamReader：<br>    字节通向字符的转换流(涉及键盘录入时用)<br>规律：<br>(1)第一步：先明确源和目的<br>    源：<br>    文本：用Reader<br>字节：用InputStream<br>目的：<br>    文本：用Writer<br>字节：用OutputStream<br>    (2)第二步：明确是不是纯文本<br>    是：用字符流；<br>    不是：用字节流<br>(3)第三步：明确流体系后，通过设备来明确具体使用哪个流对象<br>    源设备：<br>    键盘：System.in<br>硬盘：文件流File<br>内存：数组流ArrayStream<br>目的设备：<br>    键盘：System.out<br>硬盘：文件流File<br>内存：数组流ArrayStream  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows使用SecureCRT连接虚拟机中的Linux系统(Ubuntu)</title>
      <link href="/2018/12/04/2018-12-04-windows%E4%BD%BF%E7%94%A8SecureCRT%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84Linux%E7%B3%BB%E7%BB%9F(Ubuntu)/"/>
      <url>/2018/12/04/2018-12-04-windows%E4%BD%BF%E7%94%A8SecureCRT%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84Linux%E7%B3%BB%E7%BB%9F(Ubuntu)/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h2><p>宿主机OS：Windows 8.1 64bits<br>虚拟机OS：Ubuntu 15.04 64bits<br>VMWare：11.1.0<br>SecureCRT： 7.1.1.264 64bits<br>VMware的网络连接我们要选择NAT模式<br><img src="https://viabcde.github.io/images/201812/28.png" alt="enter descriptionhere"><br>进入Ubuntu，先查看Ubuntu虚拟机的IP配置，打开终端(Ctrl+Alt+T)，通过ifconfig命令查看，可以看到Ubuntu下的IP地址信息<br><img src="https://viabcde.github.io/images/201812/29.png" alt="enter descriptionhere"><br>然后就可以到Windows下设置VMware Network Adapter VMnet8，其中VMnet8的IP地址和默认网关和虚拟机要相同(保持和虚拟机IP保持在同一个网段)<br><img src="https://viabcde.github.io/images/201812/30.png" alt="enter descriptionhere">   </p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a><strong>遇到的问题</strong></h2><p>输入命令:<code>ssh username@localhost</code>。如果出现了<code>ssh: connect to host localhost port 22: Connection refused</code><br>一般都是没有安装SSH<br>没有安装ssh<br>打开Ubuntu的终端，输入：<code>sudo apt-get install openssh-server</code><br>安装完毕后ssh默认已启动。可以使用下述命令查看是否有进程在22端口上监听，即是否已启动：<code>netstat -nat | grep 22</code><br>如果连接不了，则我们需要关闭掉防火墙<code>sudo ufw disable</code><br>打开SecureCRT软件，进行配置。ProtoCol模式选为SSH2，Port为22，HostName为192.168.172.168（就是我们Ubuntu的IP地址），UserName为我们Ubuntu的登录账户。　<br><img src="https://viabcde.github.io/images/201812/31.png" alt="enter descriptionhere"><br>PassWord为我们Ubuntu的登录密码<br><img src="https://viabcde.github.io/images/201812/32.png" alt="enter descriptionhere">   </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell基本命令</title>
      <link href="/2018/12/04/2018-12-04-shell%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/12/04/2018-12-04-shell%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="启动hdfs"><a href="#启动hdfs" class="headerlink" title="启动hdfs"></a><strong>启动hdfs</strong></h2><p>start-dfs.sh  </p><h2 id="查看hdfs是否启动"><a href="#查看hdfs是否启动" class="headerlink" title="查看hdfs是否启动"></a><strong>查看hdfs是否启动</strong></h2><p>jps   </p><h2 id="查看shell命令的解释"><a href="#查看shell命令的解释" class="headerlink" title="查看shell命令的解释"></a><strong>查看shell命令的解释</strong></h2><p>hdfs dfs -help  </p><h2 id="本地上传文件到hdfs根目录"><a href="#本地上传文件到hdfs根目录" class="headerlink" title="本地上传文件到hdfs根目录"></a><strong>本地上传文件到hdfs根目录</strong></h2><p>创建文件<br>touch  /simple/1.txt<br>查看并编辑<code>hdfs dfs -cat  /simple/1.txt</code><br>上传到hdfs根目录hdfs dfs -put /simple/1.txt   /<br>在本地修改1.txt后将其merge到hdfs<br>hdfs dfs -appebdToFile   /simple/1.txt   /1.txt<br>删除hdfs的目录类型的文件aa  <code>hdfs dfs -rmr  /aa</code><br>查看hdfs上的文件<code>hdfs dfs -cat /1.txt</code><br>获取hdfs上的文件<code>hdfs dfs -get /1.txt  /simple/1.txt</code><br>hdfs创建目录<code>hdfs dfs -mkdir -p   /aa/bb</code><br>在hdfs创建文件<code>hdfs dfs -touchz   /1.txt</code><br>hdfs上的文件移动<code>hdfs dfs -mv /1.txt  /2.txt</code><br>查看根目录下的所有文件<code>hdsf dfs -ls  /</code><br>把本地文件移动到hdfs<code>hdfs dfs -moveFromLocal   /simple/1.txt   /aa</code><br>修改文件或文件夹所属的用户组<code>hdfs dfs -chgrp -R root  /</code><br>改变文件的权限<code>hdfs dfs -chmod -R 777  /</code><br>改变文件的所有者<code>hdfs dfs -chown -R root:supergroup  /</code><br>查看所有属于管理者的命令<code>hadoop dfsamin -help</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web配置文件中的编码拦截器配置</title>
      <link href="/2018/12/01/2018-12-01-web%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E6%8B%A6%E6%88%AA%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/12/01/2018-12-01-web%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E6%8B%A6%E6%88%AA%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<pre><code>  &lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>druid的StatViewServlet配置</title>
      <link href="/2018/12/01/2018-12-01-druid%E7%9A%84StatViewServlet%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/12/01/2018-12-01-druid%E7%9A%84StatViewServlet%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>提供监控信息展示的html页面<br>提供监控信息的JSON API<br>web.xml文件中的配置</p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;resetEnable&lt;/param-name&gt;      &lt;param-value&gt;false&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;      &lt;param-name&gt;loginUsername&lt;/param-name&gt;      &lt;param-value&gt;yourname&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;      &lt;param-name&gt;loginPassword&lt;/param-name&gt;      &lt;param-value&gt;yourpassword&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt;    &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;</code></pre><p>根据配置中的url-pattern来访问内置监控页面，如果是上面的配置，内置监控页面的首页是/druid/index.html或其他文件<br><strong>配置resetEnable</strong><br>在StatViewSerlvet输出的html页面中，有一个功能是Reset All，执行这个操作之后，会导致所有计数器清零，重新计数。你可以通过配置参数关闭它。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> druid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web.xml中classpath:和classpath*</title>
      <link href="/2018/12/01/2018-12-01-web.xml%E4%B8%ADclasspath/"/>
      <url>/2018/12/01/2018-12-01-web.xml%E4%B8%ADclasspath/</url>
      
        <content type="html"><![CDATA[<p><code>classpath：</code>只会到你的class路径中查找找文件;<br><code>classpath*：</code>不仅包含class路径，还包括jar文件中(class路径)进行查找.<br><strong>示例</strong>  </p><pre><code>&lt;context-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath*:applicationContext.xml,          classpath*:app-datasource.xml,          classpath*:app-memcached.xml,          classpath*:app-ibatis.xml,          classpath*:app-rest.xml      &lt;/param-value&gt;  &lt;/context-param&gt; </code></pre><p><strong>不同存放位置的配置：</strong><br><strong>1：src下面</strong><br>需要在web.xml中定义如下：</p><pre><code>&lt;context-param&gt;  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;  &lt; /context-param&gt;  </code></pre><p><strong>2：WEB-INF下面</strong><br>需要在web.xml中定义如下：  </p><pre><code>&lt;context-param&gt;  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  &lt;param-value&gt;WEB-INF/applicationContext*.xml&lt;/param-value&gt;  &lt;/context-param&gt;  </code></pre><p>这些src目录下的配置文件会和class文件一样，在部署到tomcat后自动copy到应用的 classes目录下<br>spring的 配置文件<strong>在启动时</strong>，加载的是web-info目录下的applicationContext.xml, <strong>运行时</strong>使用的是web-info/classes目录下的applicationContext.xml。  </p><pre><code>&lt;context-param&gt;   &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;   &lt;param-value&gt;/WEB-INF/classes/applicationContext.xml&lt;/param-value&gt;   &lt;/context-param&gt; </code></pre><p><strong>多个配置文件的加载</strong>   </p><pre><code>&lt;context-param&gt;   &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;   &lt;param-value&gt;   classpath*:conf/spring/applicationContext_core*.xml,   classpath*:conf/spring/applicationContext_dict*.xml,   classpath*:conf/spring/applicationContext_hibernate.xml,   classpath*:conf/spring/applicationContext_staff*.xml,   classpath*:conf/spring/applicationContext_security.xml   classpath*:conf/spring/applicationContext_modules*.xml   classpath*:conf/spring/applicationContext_cti*.xml   classpath*:conf/spring/applicationContext_apm*.xml   &lt;/param-value&gt;   &lt;/context-param&gt;   </code></pre><p><strong>contextConfigLocation 参数</strong>定义了要装入的 Spring 配置文件。<br>与Spring相关的配置文件必须要以”applicationContext-“开头<br>在web.xml中的配置如下： </p><pre><code>&lt;context-param&gt;   &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;   &lt;param-value&gt;classpath*:**/applicationContext-*.xml&lt;/param-value&gt;   &lt;/context-param&gt;  </code></pre><p><strong>建议配置如下，在同一目录下</strong>  </p><pre><code>&lt;context-param&gt;   &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;   &lt;param-value&gt;classpath:/spring/applicationContext-*.xml&lt;/param-value&gt;   &lt;/context-param&gt;  </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web配置文件中Servlet请求拦截器</title>
      <link href="/2018/12/01/2018-12-01-web%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%ADServlet%E8%AF%B7%E6%B1%82%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
      <url>/2018/12/01/2018-12-01-web%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%ADServlet%E8%AF%B7%E6%B1%82%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>示例</strong><br>servlet-name:servlet的名称（为了与servlet-mapping对应）<br>load-on-startup：表示启动容器时初始化该Servlet  </p><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:spring-context-mvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;</code></pre><p>如果有以下配置Spring Web MVC框架将加载“classpath:spring-servlet-config.xml”来进行初始化上下文而不是“/WEB-INF/[servlet名字]-servlet.xml”。</p><pre><code> &lt;init-param&gt;          &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;          &lt;param-value&gt;classpath:spring-servlet-config.xml&lt;/param-value&gt;      &lt;/init-param&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的ContextLoaderListener</title>
      <link href="/2018/12/01/2018-12-01-Spring%E7%9A%84ContextLoaderListener/"/>
      <url>/2018/12/01/2018-12-01-Spring%E7%9A%84ContextLoaderListener/</url>
      
        <content type="html"><![CDATA[<p><strong>在配置文件中的配置示例：</strong></p><pre><code>  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;</code></pre><p><strong>解析</strong><br><code>public class ContextLoaderListener extends Object implements ServletContextListener</code><br><strong>部署配置文件、创建Bean</strong><br>实现Servlet的上下文监听器，在启动Web容器时，自动装配Spring applicationContext.xml<br>如果在web.xml中不写任何参数配置信息，默认的路径是”/WEB-INF/applicationContext.xml，在WEB-INF目录下创建的xml文件的名称必须是applicationContext.xml。如果是要自定义文件名可以在web.xml里加入contextConfigLocation这个context参数：</p><pre><code>&lt;context-param&gt;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;&lt;param-value&gt;/WEB-INF/classes/applicationContext-*.xml&lt;/param-value&gt;&lt;/context-param&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Boot-Starter-Test</title>
      <link href="/2018/11/30/2018-11-30-spring-boot-starter-test/"/>
      <url>/2018/11/30/2018-11-30-spring-boot-starter-test/</url>
      
        <content type="html"><![CDATA[<p>在pom包中添加spring-boot-starter-test包<strong>引用</strong></p><pre><code>　　&lt;dependency&gt;　　&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;　　&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;　　&lt;scope&gt;test&lt;/scope&gt;　　&lt;/dependency&gt;</code></pre><p><strong>测试类示例</strong>  </p><pre><code>@RunWith(SpringRunner.class)　　@SpringBootTest　　public class ApplicationTests {　　@Test　　public void hello() {　　System.out.println(&quot;hello world&quot;);　　}　　}</code></pre><p>引入了MockMvc支持<strong>对Controller层的测试</strong>，简单示例如下：</p><pre><code>　　public class HelloControlerTests {　　　　private MockMvc mvc;　　　　//初始化执行　　　　@Before　　　　public void setUp() throws Exception {　　　　mvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();　　　　}　　　　//验证controller是否正常响应并打印返回结果　　　　@Test　　　　public void getHello() throws Exception {　　　　mvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;).accept(MediaType.APPLICATION_JSON))　　　　.andExpect(MockMvcResultMatchers.status().isOk(www.027yeshenghuowang.com/))　　　　.andDo(MockMvcResultHandlers.print())　　　　.andReturn();　　　　}　　　　//验证controller是否正常响应并判断返回结果是否正确　　　　@Test　　　　public void testHello() throws Exception {　　　　mvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;).accept(MediaType.APPLICATION_JSON))　　　　.andExpect(status().isOk(http://xucaizxyl.com/))　　　　.andExpect(content().string(equalTo(&quot;Hello World&quot;)http://www.wbjyl.cn/));　　}　　}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Boot-Starter-Parent</title>
      <link href="/2018/11/30/2018-11-30-spring-boot-starter-parent/"/>
      <url>/2018/11/30/2018-11-30-spring-boot-starter-parent/</url>
      
        <content type="html"><![CDATA[<pre><code>&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;&lt;/parent&gt;</code></pre><p>Spring Boot的父级依赖，使用它之后，常用的包依赖可以<strong>省去version标签</strong><br>再加上spring-boot-starter-web，就可以搭建<strong>简单的web应用</strong></p><pre><code>&lt;dependencies&gt;   &lt;dependency&gt;       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;       &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;   &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>此时pom.xml文件是这样的，只有这2个starter</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;springBootLearn&lt;/groupId&gt;    &lt;artifactId&gt;springBootLearn&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;    &lt;/parent&gt;   &lt;dependencies&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;       &lt;/dependency&gt;   &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p><strong>HelloworldController.java</strong></p><pre><code>@RestControllerpublic class HelloworldController {    @RequestMapping(&quot;/&quot;)    public String say(){        return &quot;Hello Spring Boot&quot;;    }}</code></pre><p><strong>Application.java</strong></p><pre><code>@SpringBootApplicationpublic class Application {    public static void main(String[] args) {        SpringApplication.run(Ch1Application.class, args);    }}</code></pre><p>运行main方法，启动项目，然后在浏览器访问<a href="http://localhost:8080,就能看到" target="_blank" rel="noopener">http://localhost:8080,就能看到</a> “Hello Spring Boot”。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis-Spring-Boot-Starter</title>
      <link href="/2018/11/30/2018-11-30-mybatis-spring-boot-starter/"/>
      <url>/2018/11/30/2018-11-30-mybatis-spring-boot-starter/</url>
      
        <content type="html"><![CDATA[<p>mybatis-spring-boot-starter主要有两种解决方案，一种是使用注解解决一切问题，一种是简化后的老传统<br>2种都需要首先<strong>引入</strong>mybatis-spring-boot-starter的<strong>pom文件</strong>   </p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="第一种：无配置文件注解版"><a href="#第一种：无配置文件注解版" class="headerlink" title="第一种：无配置文件注解版"></a>第一种：无配置文件<strong>注解版</strong></h2><p>1 添加相关maven文件</p><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.1.1&lt;/version&gt;    &lt;/dependency&gt;     &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;/dependency&gt;     &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>完整的pom包这里就不贴了，大家直接看源码    </p><p>2、application.properties 添加相关配置</p><pre><code>mybatis.type-aliases-package=com.neo.entityspring.datasource.driverClassName = com.mysql.jdbc.Driverspring.datasource.url = jdbc:mysql://localhost:3306/test1?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username = rootspring.datasource.password = root</code></pre><p>springboot会自动加载<code>spring.datasource.*</code>相关配置，数据源就会自动注入到sqlSessionFactory中，sqlSessionFactory会自动注入到Mapper中，对了你一切都不用管了，直接拿起来使用就行了。<br><strong>在启动类中添加对mapper包扫描@MapperScan</strong></p><pre><code>@SpringBootApplication@MapperScan(&quot;com.neo.mapper&quot;)public class Application {    public static void main(String[] args) {        SpringApplication.run(Application.class, args);    }}</code></pre><p>3、开发Mapper<br>第三步是最关键的一块，sql生产都在这里   </p><pre><code>public interface UserMapper {    @Select(&quot;SELECT * FROM users&quot;)    @Results({        @Result(property = &quot;userSex&quot;,  column = &quot;user_sex&quot;, javaType = UserSexEnum.class),        @Result(property = &quot;nickName&quot;, column = &quot;nick_name&quot;)    })    List&lt;UserEntity&gt; getAll();    @Select(&quot;SELECT * FROM users WHERE id = #{id}&quot;)    @Results({        @Result(property = &quot;userSex&quot;,  column = &quot;user_sex&quot;, javaType = UserSexEnum.class),        @Result(property = &quot;nickName&quot;, column = &quot;nick_name&quot;)    })    UserEntity getOne(Long id);    @Insert(&quot;INSERT INTO users(userName,passWord,user_sex) VALUES(#{userName}, #{passWord}, #{userSex})&quot;)    void insert(UserEntity user);    @Update(&quot;UPDATE users SET userName=#{userName},nick_name=#{nickName} WHERE id =#{id}&quot;)    void update(UserEntity user);    @Delete(&quot;DELETE FROM users WHERE id =#{id}&quot;)    void delete(Long id);}</code></pre><p>为了更接近生产我特地将user_sex、nick_name两个属性在数据库加了下划线和实体类属性名不一致，另外user_sex使用了枚举<br>@Select 是查询类的注解，所有的查询均使用这个<br>@Result 修饰返回的结果集，关联实体类属性和数据库字段一一对应，如果实体类属性和数据库属性名保持一致，就不需要这个属性来修饰。<br>@Insert 插入数据库使用，直接传入实体类会自动解析属性到对应的值<br>@Update 负责修改，也可以直接传入对象<br>@delete 负责删除<br><strong>注意，使用#符号和$符号的不同：</strong>  </p><pre><code>// This example creates a preparedstatement, something like select * from teacher where name = ?;@Select(&quot;Select * from teacher where name = #{name}&quot;)Teacher selectTeachForGivenName(@Param(&quot;name&quot;) String name);// This example creates n inlined statement, something like select * from teacher where name = &#39;someName&#39;;@Select(&quot;Select * from teacher where name = &#39;${name}&#39;&quot;)Teacher selectTeachForGivenName(@Param(&quot;name&quot;) String name);</code></pre><p>4、使用<br>上面三步就基本完成了相关dao层开发，使用的时候当作普通的类注入进入就可以了  </p><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class UserMapperTest {    @Autowired    private UserMapper UserMapper;    @Test    public void testInsert() throws Exception {        UserMapper.insert(new UserEntity(&quot;aa&quot;, &quot;a123456&quot;, UserSexEnum.MAN));        UserMapper.insert(new UserEntity(&quot;bb&quot;, &quot;b123456&quot;, UserSexEnum.WOMAN));        UserMapper.insert(new UserEntity(&quot;cc&quot;, &quot;b123456&quot;, UserSexEnum.WOMAN));        Assert.assertEquals(3, UserMapper.getAll().size());    }    @Test    public void testQuery() throws Exception {        List&lt;UserEntity&gt; users = UserMapper.getAll();        System.out.println(users.toString());    }    @Test    public void testUpdate() throws Exception {        UserEntity user = UserMapper.getOne(3l);        System.out.println(user.toString());        user.setNickName(&quot;neo&quot;);        UserMapper.update(user);        Assert.assertTrue((&quot;neo&quot;.equals(UserMapper.getOne(3l).getNickName())));    }}</code></pre><p>源码中controler层有完整的增删改查，这里就不贴了</p><h2 id="第二种：极简xml版本"><a href="#第二种：极简xml版本" class="headerlink" title="第二种：极简xml版本"></a><strong>第二种：极简xml版本</strong></h2><p>极简xml版本保持映射文件的老传统，优化主要体现在不需要实现dao的是实现层，系统会自动根据方法名在映射文件中找对应的sql.   </p><p>1、配置<br>pom文件和上个版本一样，只是application.properties新增以下配置   </p><pre><code>mybatis.config-locations=classpath:mybatis/mybatis-config.xmlmybatis.mapper-locations=classpath:mybatis/mapper/*.xml</code></pre><p>指定了mybatis基础配置文件和实体类映射文件的地址  </p><p>mybatis-config.xml 配置   </p><pre><code>&lt;configuration&gt;    &lt;typeAliases&gt;        &lt;typeAlias alias=&quot;Integer&quot; type=&quot;java.lang.Integer&quot; /&gt;        &lt;typeAlias alias=&quot;Long&quot; type=&quot;java.lang.Long&quot; /&gt;        &lt;typeAlias alias=&quot;HashMap&quot; type=&quot;java.util.HashMap&quot; /&gt;        &lt;typeAlias alias=&quot;LinkedHashMap&quot; type=&quot;java.util.LinkedHashMap&quot; /&gt;        &lt;typeAlias alias=&quot;ArrayList&quot; type=&quot;java.util.ArrayList&quot; /&gt;        &lt;typeAlias alias=&quot;LinkedList&quot; type=&quot;java.util.LinkedList&quot; /&gt;    &lt;/typeAliases&gt;&lt;/configuration&gt;</code></pre><p>这里也可以添加一些mybatis基础的配置  </p><p>2、添加User的映射文件  </p><pre><code>&lt;mapper namespace=&quot;com.neo.mapper.UserMapper&quot; &gt;    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.neo.entity.UserEntity&quot; &gt;        &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;BIGINT&quot; /&gt;        &lt;result column=&quot;user_name&quot; property=&quot;userName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;        &lt;result column=&quot;pass_word&quot; property=&quot;passWord&quot; jdbcType=&quot;VARCHAR&quot; /&gt;        &lt;result column=&quot;user_sex&quot;  property=&quot;userSex&quot;  javaType=&quot;com.neo.enums.UserSexEnum&quot;/&gt;        &lt;result column=&quot;nick_name&quot; property=&quot;nickName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;    &lt;/resultMap&gt;    &lt;sql id=&quot;Base_Column_List&quot; &gt;        id, userName, passWord, user_sex, nick_name    &lt;/sql&gt;    &lt;select id=&quot;getAll&quot; resultMap=&quot;BaseResultMap&quot;  &gt;       SELECT        &lt;include refid=&quot;Base_Column_List&quot; /&gt;       FROM users    &lt;/select&gt;    &lt;select id=&quot;getOne&quot; parameterType=&quot;java.lang.Long&quot; resultMap=&quot;BaseResultMap&quot; &gt;        SELECT        &lt;include refid=&quot;Base_Column_List&quot; /&gt;       FROM users       WHERE id = #{id}    &lt;/select&gt;    &lt;insert id=&quot;insert&quot; parameterType=&quot;com.neo.entity.UserEntity&quot; &gt;       INSERT INTO                users               (userName,passWord,user_sex)            VALUES               (#{userName}, #{passWord}, #{userSex})    &lt;/insert&gt;    &lt;update id=&quot;update&quot; parameterType=&quot;com.neo.entity.UserEntity&quot; &gt;       UPDATE                users        SET            &lt;if test=&quot;userName != null&quot;&gt;userName = #{userName},&lt;/if&gt;           &lt;if test=&quot;passWord != null&quot;&gt;passWord = #{passWord},&lt;/if&gt;           nick_name = #{nickName}       WHERE                id = #{id}    &lt;/update&gt;    &lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang.Long&quot; &gt;       DELETE FROM                users        WHERE                 id =#{id}    &lt;/delete&gt;&lt;/mapper&gt;</code></pre><p>其实就是把上个版本中mapper的sql搬到了这里的xml中了  </p><p>3、编写Dao层的代码   </p><pre><code>public interface UserMapper {    List&lt;UserEntity&gt; getAll();    UserEntity getOne(Long id);    void insert(UserEntity user);    void update(UserEntity user);    void delete(Long id);}</code></pre><p>对比上一步这里全部只剩了接口方法</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更换容器和更换端口</title>
      <link href="/2018/11/30/2018-11-30-%20%E6%9B%B4%E6%8D%A2%E5%AE%B9%E5%99%A8%E5%92%8C%E6%9B%B4%E6%8D%A2%E7%AB%AF%E5%8F%A3%20/"/>
      <url>/2018/11/30/2018-11-30-%20%E6%9B%B4%E6%8D%A2%E5%AE%B9%E5%99%A8%E5%92%8C%E6%9B%B4%E6%8D%A2%E7%AB%AF%E5%8F%A3%20/</url>
      
        <content type="html"><![CDATA[<p><strong>更换容器：</strong>在pom.xml中编辑</p><pre><code># 01 去除springboot中默认的嵌入式tomcat依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;# 02 添加jetty依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>更换端口：</strong>编辑application.properties文件，添加如下行：</p><pre><code># server.servlet.context-path=/helloboot# logging.file=D:/mylog/log.log# logging.level.org.springframework.web= DEBUG# book.author=wxh# book.name=20# debug=true# spring.profiles.active=devserver.port=8888</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Boot-Starter-Logging</title>
      <link href="/2018/11/30/2018-11-30-spring-boot-starter-logging/"/>
      <url>/2018/11/30/2018-11-30-spring-boot-starter-logging/</url>
      
        <content type="html"><![CDATA[<p>需要在<strong>maven中添加</strong>如下配置中之一即可</p><pre><code>#默认的logging&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt;#log4j&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-logg4j&lt;/artifactId&gt;&lt;/dependency&gt;#log4j2&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组和集合</title>
      <link href="/2018/11/25/2018-11-25-%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88/"/>
      <url>/2018/11/25/2018-11-25-%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h3 id="Set，List-和-Map-的区别"><a href="#Set，List-和-Map-的区别" class="headerlink" title="Set，List 和 Map 的区别"></a><strong>Set，List 和 Map 的区别</strong></h3><p>java集合的主要分为三种类型：  Set（集）  List（列表）    Map（映射）<br>要深入理解集合首先要了解下我们熟悉的数组：  </p><h2 id="区别1："><a href="#区别1：" class="headerlink" title="区别1："></a><strong>区别1：</strong></h2><p><strong>数组</strong><br>大小固定<br>一个数组(数组是一种可读/可写数据结构)只能存放一种类型的数据（基本类型/引用类型），而集合（集合提供的ReadOnly方法，以只读方式来使用集合/能动态改变大小）只能存放以object形式的引用类型的的数据。<br>array无法判断其中实际存有多少元素，length只是告诉我们array的容量。<br><strong>List：</strong>可以自动扩展的数组<br><strong>set：</strong>没有重复的数组<br><strong>TreeSet,TreeList,Tree：</strong>自动排序的组数<br><strong>Java中有一个Arrays类，专门用来操作array</strong><br>arrays中拥有一组static函数，<br>equals()：比较两个array是否相等。array拥有相同元素个数，且所有对应元素两两相等。<br>fill()：将值填入array中。<br>sort()：用来对array进行排序。<br>binarySearch()：在排好序的array中寻找元素。<br>System.arraycopy()：array的复制。  </p><h3 id="Collection与Collections的区别"><a href="#Collection与Collections的区别" class="headerlink" title="Collection与Collections的区别"></a><strong>Collection与Collections的区别</strong></h3><p>Collection是集合类的上级接口，继承与他有关的接口主要有List和Set<br>Collections是针对集合类的一个帮助类，<br>搜索、排序、线程安全等操作<br>例子：  </p><pre><code>public static void main(String args[]) {          //注意List是实现Collection接口的          List list = new ArrayList();          double array[] = { 112, 111, 23, 456, 231 };          for (int i = 0; i &lt; array.length; i++) {              list.add(new Double(array[i]));          }          Collections.sort(list);   //把list按从小到大排序       for (int i = 0; i &lt; array.length; i++) {              System.out.println(list.get(i));          }          // 结果：23.0 111.0 112.0 231.0 456.0    }   </code></pre><p>混排（Shuffling）<br>反转（Reverse）<br>替换所有的元素（fill）<br>拷贝（copy）<br>返回Collections中最小元素（min）<br>返回Collections中最大元素（max）<br>返回指定源列表中最后一次出现指定目标列表的起始位置（lastIndexOfSubList）<br>返回指定源列表中第一次出现指定目标列表的起始位置（IndexOfSubList）<br>根据指定的距离循环移动指定列表中的元素（Rotate）    </p><h3 id="Java中HashMap的key值要是为类对象则该类需要满足什么条件？"><a href="#Java中HashMap的key值要是为类对象则该类需要满足什么条件？" class="headerlink" title="Java中HashMap的key值要是为类对象则该类需要满足什么条件？"></a><strong>Java中HashMap的key值要是为类对象则该类需要满足什么条件？</strong></h3><p>需要同时重写该类的hashCode()方法和它的equals()方法。  </p><h3 id="如何选择合适的Java集合框架"><a href="#如何选择合适的Java集合框架" class="headerlink" title="如何选择合适的Java集合框架"></a><strong>如何选择合适的Java集合框架</strong></h3><p>确定集合类型：<br>如果是单列的集合，用Collection下的子接口ArrayList和Set<br>如果是映射，使用Map<br>确定使用集合类型下的哪个子类<br>是否需要同步，选择线程安全的集合类<br>迭代时是否需要有序(插入顺序有序)，找Linked双向列表结构<br>是否需要排序(自然顺序或者手动排序)，找Tree红黑树类型的(JDK1.8)<br>估算存放集合的数据量有多大，无论是List还是Map，它们实现动态增长，都是有性能消耗的。在初始集合的时候给出一个合理的容量会减少动态增长时的消耗~<br>使用泛型，避免在运行时出现ClassCastException<br>尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet访问流程</title>
      <link href="/2018/11/25/2018-11-25-Servlet%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/11/25/2018-11-25-Servlet%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Servlet-的请求流程？"><a href="#Servlet-的请求流程？" class="headerlink" title="Servlet 的请求流程？"></a><strong>Servlet 的请求流程？</strong></h2><h3 id="1-浏览器发出请求-http-localhost-80-xxx1-xxx2"><a href="#1-浏览器发出请求-http-localhost-80-xxx1-xxx2" class="headerlink" title="1.浏览器发出请求 http://localhost:80/xxx1/xxx2"></a><strong>1.浏览器发出请求</strong> <a href="http://localhost:80/xxx1/xxx2" target="_blank" rel="noopener">http://localhost:80/xxx1/xxx2</a></h3><p><strong>注：</strong>（80端口可以默认不写，因为这是http协议默认的端口，平时我们访问<a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a> 时其实访问的是<a href="https://www.baidu.com:80/）" target="_blank" rel="noopener">https://www.baidu.com:80/）</a></p><h3 id="2-服务器解析请求信息"><a href="#2-服务器解析请求信息" class="headerlink" title="2.服务器解析请求信息"></a><strong>2.服务器解析请求信息</strong></h3><p>•http:协议名称<br>•localhost:访问的是互联网中的哪一台计算机<br>•80:从主机当中找到对应 80 端口的程序 （这里即为 Tomcat 服务器）<br>•/xxx1:当前项目的上下文路径 （即在 server.xml 中配置主机时配置的 path属性）<br>•/xxx2:当前请求的资源名  </p><h3 id="3-解析-Tomcat-服务器根目录下的-config-server-xml-文件"><a href="#3-解析-Tomcat-服务器根目录下的-config-server-xml-文件" class="headerlink" title="3.解析 Tomcat 服务器根目录下的 /config/server.xml 文件"></a><strong>3.解析 Tomcat 服务器根目录下的 /config/server.xml 文件</strong></h3><pre><code>&lt;Context docBase=&quot;D:\javaPros\test\webapp&quot; path=&quot;xxx1&quot; /&gt;</code></pre><p>判断哪一个<context>元素的 path属性 属性为 xxx1<br>•若找不到，则返回 404错误<br>•若找到了，则解析该<context>元素，得到docBase属性，获取当前访问 Web 项目的跟的绝对路径：D:\javaPros\test\webapp  </context></context></p><h3 id="4-从D-javaPros-test-webapp下的-WEB-INF-下找到-web-xml-文件"><a href="#4-从D-javaPros-test-webapp下的-WEB-INF-下找到-web-xml-文件" class="headerlink" title="4.从D:\javaPros\test\webapp下的 WEB-INF 下找到 web.xml 文件"></a><strong>4.从D:\javaPros\test\webapp下的 WEB-INF 下找到 web.xml 文件</strong></h3><p> 判断 web.xml 文件中是否有 <url-pattern> 的文本内容为 /xxx2<br> •若找不到，则返回 404错误<br>•若找到了，则继续获取该资源对应 Servlet 类的全限名称： xxx.xxx    </url-pattern></p><h3 id="5-判断-Servlet-实例缓存池-中是否有-xxx-xxx-的对象"><a href="#5-判断-Servlet-实例缓存池-中是否有-xxx-xxx-的对象" class="headerlink" title="5.判断 Servlet 实例缓存池 中是否有 xxx.xxx 的对象"></a><strong>5.判断 Servlet 实例缓存池 中是否有 xxx.xxx 的对象</strong></h3><p>Map&lt;String,Servlet&gt; cache = ……(Tomcat提供的);<br>    key:存Servlet类的全限定名称<br>    value:该Servlet类的对象.    </p><pre><code>Servlet obj = cache.get(&quot;xxx.xxx&quot;);    if(obj==null){        //Servlet实例缓存中没有该类的对象,第一次.        GOTO 6:    }else{        //有对象,非第一次.        GOTO 8:    }}</code></pre><h2 id="servlet的生命周期"><a href="#servlet的生命周期" class="headerlink" title="servlet的生命周期"></a><strong>servlet的生命周期</strong></h2><h3 id="1-使用反射调用构造器，创建对应的对象"><a href="#1-使用反射调用构造器，创建对应的对象" class="headerlink" title="1.使用反射调用构造器，创建对应的对象"></a><strong>1.使用反射调用构造器，创建对应的对象</strong></h3><p>obj = Class.forName(“xxx.xxx”).newInstance();<br>把当前创建的 Servlet 对象，存放在缓存之中，供给下一次的使用.<br>cache.put(“xxx.xxx”,obj);  </p><h3 id="2-创建-ServletConfig-对象，并调用-init-方法"><a href="#2-创建-ServletConfig-对象，并调用-init-方法" class="headerlink" title="2.创建 ServletConfig 对象，并调用 init() 方法"></a><strong>2.创建 ServletConfig 对象，并调用 init() 方法</strong></h3><p>obj.init(config);  </p><h3 id="3-创建-ServletRequest-对象和-ServletResponse-对象，并调用-service-方法"><a href="#3-创建-ServletRequest-对象和-ServletResponse-对象，并调用-service-方法" class="headerlink" title="3.创建 ServletRequest 对象和 ServletResponse 对象，并调用 service()方法"></a><strong>3.创建 ServletRequest 对象和 ServletResponse 对象，并调用 service()方法</strong></h3><p>obj.service(req,resp);</p><h3 id="4-在-service-方法中对浏览器作出响应操作。"><a href="#4-在-service-方法中对浏览器作出响应操作。" class="headerlink" title="4.在 service() 方法中对浏览器作出响应操作。"></a><strong>4.在 service() 方法中对浏览器作出响应操作。</strong></h3><h2 id="Servlet-是单例的吗？为什么？"><a href="#Servlet-是单例的吗？为什么？" class="headerlink" title="Servlet 是单例的吗？为什么？"></a><strong>Servlet 是单例的吗？为什么？</strong></h2><p>Servlet 是单例的，浏览器多次对Servlet的请求，一般情况下，服务器只创建一个Servlet对象，也就是说，Servlet对象一旦创建了，就会驻留在内存中，为后续的请求做服务，直到服务器关闭。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hibernate有几种查询数据的方式</title>
      <link href="/2018/11/25/2018-11-25-Hibernate%E6%9C%89%E5%87%A0%E7%A7%8D%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/11/25/2018-11-25-Hibernate%E6%9C%89%E5%87%A0%E7%A7%8D%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p> <strong>Hibernate有3中查询方式：</strong><br>HQL: Hibernate Query Language<br>Criteria Query,以对象的方式添加查询条件<br>SQL,直接使用SQL语句操作数据库。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hibernate工作原理</title>
      <link href="/2018/11/25/2018-11-25-Hibernate%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%20/"/>
      <url>/2018/11/25/2018-11-25-Hibernate%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%20/</url>
      
        <content type="html"><![CDATA[<h3 id="Hibernate工作原理如下"><a href="#Hibernate工作原理如下" class="headerlink" title="Hibernate工作原理如下"></a>Hibernate工作原理如下</h3><p>读取并解析配置文件<br>读取并解析映射信息，创 建SessionFactory<br>打开Session<br>创建事务Transaction<br>持久化操作<br>提交事务<br>关闭Session<br>关闭SessionFactory  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH（一）------登录系统</title>
      <link href="/2018/11/23/2018-11-23-SSH%EF%BC%88%E4%B8%80%EF%BC%89------%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F/"/>
      <url>/2018/11/23/2018-11-23-SSH%EF%BC%88%E4%B8%80%EF%BC%89------%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>login.jsp</strong><br>form表单跳转到名称为login 的action<br>struts.xml这个action对应calss为userAction的类中method为login的方法  </p><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot; %&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;  &lt;head&gt;    &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;    &lt;title&gt;用户登陆&lt;/title&gt;    &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt;    &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;    &lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt;        &lt;meta http-equiv=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt;    &lt;meta http-equiv=&quot;description&quot; content=&quot;This is my page&quot;&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;s:form action=&quot;login&quot; method=&quot;post&quot;&gt;        &lt;s:textfield label=&quot;用户名&quot; name=&quot;username&quot; /&gt;        &lt;s:password label=&quot;密码&quot; name=&quot;password&quot; /&gt;        &lt;s:submit value=&quot;登录&quot; /&gt;    &lt;/s:form&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring.xml</title>
      <link href="/2018/11/23/2018-11-23-Spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2018/11/23/2018-11-23-Spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a><strong>第一种</strong></h2><p>该文件主要是配置Hibernate事务（而事务需要sessionFactory，sessionFactory需要数据源等信息）<br>配置Hibernate事务(需要sessionFactory)<br>配置sessionFactory(需要数据源及其他配置，如指定数据库方言、显示sql语句和自动建表)<br>配置数据源:设置驱动、数据库的URL、数据库的用户名及密码</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xsi:schemaLocation=&quot;            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot;&gt;    &lt;!-- 配置数据源 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;!-- 驱动名称oracle.jdbc.driver.OracleDriver --&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;        &lt;!-- 连接数据库的URL jdbc:oracle:thin:@localhost:1521:orcl --&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test1&quot; /&gt;        &lt;!-- 连接数据库的用户名 --&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;        &lt;!-- 连接数据库的密码 --&gt;        &lt;property name=&quot;password&quot; value=&quot;135246&quot; /&gt;    &lt;/bean&gt;    &lt;!-- 配置SessionFactory --&gt;    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;        &lt;!-- 指定数据源 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;        &lt;!-- 指定hibernate的相关属性 --&gt;        &lt;property name=&quot;hibernateProperties&quot;&gt;            &lt;props&gt;                &lt;!-- 指定数据库方言org.hibernate.dialect.Oracle10gDialect --&gt;                &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLInnoDBDialect&lt;/prop&gt;                &lt;!-- 显示SQL语句 --&gt;                &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt;                &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;create&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;        &lt;!-- 指定ORM映射文件 --&gt;        &lt;property name=&quot;mappingResources&quot;&gt;            &lt;list&gt;                &lt;value&gt;com/pb/entity/User.hbm.xml&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- Hibernate声明式事务 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;        &lt;!-- 注入sessionFactory属性 --&gt;        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;    &lt;/bean&gt;    &lt;!-- 数据访问层(DAO) --&gt;    &lt;!-- 基类Dao --&gt;    &lt;bean id=&quot;baseDao&quot; abstract=&quot;true&quot; class=&quot;com.pb.dao.impl.BaseDaoImpl&quot;&gt;        &lt;!-- 注入SessionFactory属性 --&gt;        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;        &lt;!-- 注入ptm属性 --&gt;        &lt;property name=&quot;ptm&quot; ref=&quot;transactionManager&quot; /&gt;    &lt;/bean&gt;    &lt;!-- UserDao --&gt;    &lt;bean id=&quot;userDao&quot; parent=&quot;baseDao&quot; class=&quot;com.pb.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;    &lt;!-- 业务逻辑层(BIZ) --&gt;    &lt;!-- UserBiz --&gt;    &lt;bean id=&quot;userBiz&quot; class=&quot;com.pb.biz.impl.UserBizImpl&quot;&gt;        &lt;property name=&quot;dao&quot; ref=&quot;userDao&quot; /&gt;    &lt;/bean&gt;    &lt;!-- 控制层 --&gt;    &lt;!-- 基类Action --&gt;    &lt;bean id=&quot;baseAction&quot; abstract=&quot;true&quot; class=&quot;com.pb.web.action.BaseAction&quot; /&gt;    &lt;!-- 配置UserAction --&gt;    &lt;bean id=&quot;userAction&quot; class=&quot;com.pb.web.action.UserAction&quot;&gt;        &lt;property name=&quot;biz&quot; ref=&quot;userBiz&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a><strong>第二种</strong></h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans     http://www.springframework.org/schema/beans/spring-beans-3.1.xsd    http://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context.xsd    http://www.springframework.org/schema/aop    http://www.springframework.org/schema/aop/spring-aop.xsd    http://www.springframework.org/schema/tx     http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;    &lt;!-- 配置连接池: --&gt;    &lt;!-- 引入外部属性文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;    &lt;!-- 配置C3P0连接池: --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;${jdbc.user}&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;    &lt;/bean&gt;    &lt;!-- Hibernate的相关信息 --&gt;    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;        &lt;!-- 注入连接池 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;!-- 配置Hibernate的其他的属性 --&gt;        &lt;property name=&quot;hibernateProperties&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt;                &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt;                &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt;                &lt;prop key=&quot;hibernate.connection.autocommit&quot;&gt;false&lt;/prop&gt;                &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;        &lt;!-- 配置Hibernate的映射文件 --&gt;        &lt;property name=&quot;mappingResources&quot;&gt;            &lt;list&gt;                &lt;value&gt;cn/itcast/shop/user/vo/User.hbm.xml&lt;/value&gt;                &lt;value&gt;cn/itcast/shop/category/vo/Category.hbm.xml&lt;/value&gt;                &lt;value&gt;cn/itcast/shop/product/vo/Product.hbm.xml&lt;/value&gt;                &lt;value&gt;cn/itcast/shop/categorysecond/vo/CategorySecond.hbm.xml&lt;/value&gt;                &lt;value&gt;cn/itcast/shop/order/vo/Order.hbm.xml&lt;/value&gt;                &lt;value&gt;cn/itcast/shop/order/vo/OrderItem.hbm.xml&lt;/value&gt;                &lt;value&gt;cn/itcast/shop/adminuser/vo/AdminUser.hbm.xml&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 事务管理: --&gt;    &lt;!-- 事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 开启注解事务 --&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;    &lt;!-- Action的配置 ===========================--&gt;    &lt;!-- 首页访问的Action --&gt;    &lt;bean id=&quot;indexAction&quot; class=&quot;cn.itcast.shop.index.action.IndexAction&quot; scope=&quot;prototype&quot;&gt;        &lt;property name=&quot;categoryService&quot; ref=&quot;categoryService&quot;/&gt;        &lt;property name=&quot;productService&quot; ref=&quot;productService&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置验证码Action --&gt;    &lt;bean id=&quot;checkImgAction&quot; class=&quot;cn.itcast.shop.user.action.CheckImgAction&quot; scope=&quot;prototype&quot;&gt;    &lt;/bean&gt;    &lt;!-- 用户模块的Action --&gt;    &lt;bean id=&quot;userAction&quot; class=&quot;cn.itcast.shop.user.action.UserAction&quot; scope=&quot;prototype&quot;&gt;        &lt;!-- 注入Service --&gt;        &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 商品模块的Action --&gt;    &lt;bean id=&quot;productAction&quot; class=&quot;cn.itcast.shop.product.action.ProductAction&quot; scope=&quot;prototype&quot;&gt;        &lt;property name=&quot;productService&quot; ref=&quot;productService&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 购物车的Action --&gt;    &lt;bean id=&quot;cartAction&quot; class=&quot;cn.itcast.shop.cart.action.CartAction&quot; scope=&quot;prototype&quot;&gt;        &lt;property name=&quot;productService&quot; ref=&quot;productService&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置OrderAction --&gt;    &lt;bean id=&quot;orderAction&quot; class=&quot;cn.itcast.shop.order.action.OrderAction&quot; scope=&quot;prototype&quot;&gt;        &lt;property name=&quot;orderService&quot; ref=&quot;orderService&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置后台登录的Action --&gt;    &lt;bean id=&quot;adminUserAction&quot; class=&quot;cn.itcast.shop.adminuser.action.AdminUserAction&quot; scope=&quot;prototype&quot;&gt;        &lt;property name=&quot;adminUserService&quot; ref=&quot;adminUserService&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置后台一级管理的Action --&gt;    &lt;bean id=&quot;adminCategoryAction&quot; class=&quot;cn.itcast.shop.category.adminaction.AdminCategoryAction&quot; scope=&quot;prototype&quot;&gt;        &lt;property name=&quot;categoryService&quot; ref=&quot;categoryService&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置后台二级分类管理的Action --&gt;    &lt;bean id=&quot;adminCategorySecondAction&quot; class=&quot;cn.itcast.shop.categorysecond.adminaction.AdminCategorySecondAction&quot; scope=&quot;prototype&quot;&gt;        &lt;property name=&quot;categorySecondService&quot; ref=&quot;categorySecondService&quot;/&gt;        &lt;property name=&quot;categoryService&quot; ref=&quot;categoryService&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置后台商品管理的Action --&gt;    &lt;bean id=&quot;adminProductAction&quot; class=&quot;cn.itcast.shop.product.adminaction.AdminProductAction&quot; scope=&quot;prototype&quot;&gt;        &lt;property name=&quot;productService&quot; ref=&quot;productService&quot;/&gt;        &lt;property name=&quot;categorySecondService&quot; ref=&quot;categorySecondService&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置后台订单管理的Action --&gt;    &lt;bean id=&quot;adminOrderAction&quot; class=&quot;cn.itcast.shop.order.adminaction.AdminOrderAction&quot; scope=&quot;prototype&quot;&gt;        &lt;property name=&quot;orderService&quot; ref=&quot;orderService&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 配置后台用户管理的Action --&gt;    &lt;bean id=&quot;userAdminAction&quot; class=&quot;cn.itcast.shop.user.adminaction.UserAdminAction&quot; scope=&quot;prototype&quot;&gt;        &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&gt;    &lt;/bean&gt;    &lt;!-- Service的配置  ===========================--&gt;    &lt;bean id=&quot;userService&quot; class=&quot;cn.itcast.shop.user.service.UserService&quot;&gt;        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;categoryService&quot; class=&quot;cn.itcast.shop.category.service.CategoryService&quot;&gt;        &lt;property name=&quot;categoryDao&quot; ref=&quot;categoryDao&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;productService&quot; class=&quot;cn.itcast.shop.product.service.ProductService&quot;&gt;        &lt;property name=&quot;productDao&quot; ref=&quot;productDao&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;orderService&quot; class=&quot;cn.itcast.shop.order.service.OrderService&quot;&gt;        &lt;property name=&quot;orderDao&quot; ref=&quot;orderDao&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;adminUserService&quot; class=&quot;cn.itcast.shop.adminuser.service.AdminUserService&quot;&gt;        &lt;property name=&quot;adminUserDao&quot; ref=&quot;adminUserDao&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;categorySecondService&quot; class=&quot;cn.itcast.shop.categorysecond.service.CategorySecondService&quot;&gt;        &lt;property name=&quot;categorySecondDao&quot; ref=&quot;categorySecondDao&quot;/&gt;    &lt;/bean&gt;    &lt;!-- Dao的配置  ===========================--&gt;    &lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.shop.user.dao.UserDao&quot;&gt;        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;categoryDao&quot; class=&quot;cn.itcast.shop.category.dao.CategoryDao&quot;&gt;        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;    &lt;/bean&gt;        &lt;bean id=&quot;productDao&quot; class=&quot;cn.itcast.shop.product.dao.ProductDao&quot;&gt;        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;orderDao&quot; class=&quot;cn.itcast.shop.order.dao.OrderDao&quot;&gt;        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;adminUserDao&quot; class=&quot;cn.itcast.shop.adminuser.dao.AdminUserDao&quot;&gt;        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;categorySecondDao&quot; class=&quot;cn.itcast.shop.categorysecond.dao.CategorySecondDao&quot;&gt;        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>jdbc.properties</p><pre><code>jdbc.driver = com.mysql.jdbc.Driverjdbc.url = jdbc:mysql:///shopjdbc.user = rootjdbc.password =135246</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM(一)---用户管理</title>
      <link href="/2018/11/22/2018-11-22-SSM(%E4%B8%80)---%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
      <url>/2018/11/22/2018-11-22-SSM(%E4%B8%80)---%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><strong>main.jsp</strong>  </p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;         pageEncoding=&quot;utf-8&quot; %&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;    &lt;title&gt;ssm-maven系统主页&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;          href=&quot;${pageContext.request.contextPath}/jquery-easyui-1.3.3/themes/default/easyui.css&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;          href=&quot;${pageContext.request.contextPath}/jquery-easyui-1.3.3/themes/icon.css&quot;&gt;    &lt;script type=&quot;text/javascript&quot;            src=&quot;${pageContext.request.contextPath}/jquery-easyui-1.3.3/jquery.min.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;            src=&quot;${pageContext.request.contextPath}/jquery-easyui-1.3.3/jquery.easyui.min.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;            src=&quot;${pageContext.request.contextPath}/jquery-easyui-1.3.3/locale/easyui-lang-zh_CN.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        var url;        function addTab(url, text, iconCls) {            var content = &quot;&lt;iframe frameborder=0 scrolling=&#39;auto&#39; style=&#39;width:100%;height:100%&#39; src=&#39;${pageContext.request.contextPath}/views/&quot;                    + url + &quot;&#39;&gt;&lt;/iframe&gt;&quot;;            $(&quot;#tabs&quot;).tabs(&quot;add&quot;, {                title: text,                iconCls: iconCls,                closable: true,                content: content            });        }        function openTab(text, url, iconCls) {            if ($(&quot;#tabs&quot;).tabs(&quot;exists&quot;, text)) {                $(&quot;#tabs&quot;).tabs(&quot;close&quot;, text);                addTab(url, text, iconCls);                $(&quot;#tabs&quot;).tabs(&quot;select&quot;, text);            } else {                addTab(url, text, iconCls);            }        }        function logout() {            $.messager                    .confirm(                            &quot;系统提示&quot;,                            &quot;您确定要退出系统吗&quot;,                            function (r) {                                if (r) {                                    window.location.href = &quot;${pageContext.request.contextPath}/user/logout.do&quot;;                                }                            });        }    &lt;/script&gt;    &lt;jsp:include page=&quot;login_chk.jsp&quot;&gt;&lt;/jsp:include&gt;&lt;body class=&quot;easyui-layout&quot;&gt;&lt;div region=&quot;north&quot; style=&quot;height: 78px;background-color: #ffff&quot;&gt;    &lt;table width=&quot;100%&quot;&gt;        &lt;tr&gt;            &lt;td width=&quot;50%&quot;&gt;&lt;/td&gt;            &lt;td valign=&quot;bottom&quot;                style=&quot;font-size: 20px;color:#8B8B8B;font-family: &#39;楷体&#39;;&quot;                align=&quot;right&quot; width=&quot;50%&quot;&gt;&lt;font size=&quot;3&quot;&gt;&amp;nbsp;&amp;nbsp;&lt;strong&gt;当前管理员：&lt;/strong&gt;${currentUser.userName                    }&lt;/font&gt;【管理员】            &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/div&gt;&lt;div region=&quot;center&quot;&gt;    &lt;div class=&quot;easyui-tabs&quot; fit=&quot;true&quot; border=&quot;false&quot; id=&quot;tabs&quot;&gt;        &lt;div title=&quot;首页&quot; data-options=&quot;iconCls:&#39;icon-home&#39;&quot;&gt;                        &lt;div align=&quot;center&quot; style=&quot;padding-top: 20px;&quot;&gt;&lt;a                    href=&quot;https://git.oschina.net/zhenfeng13/ssm-demo&quot;                    target=&quot;_blank&quot; style=&quot;font-size: 20px;&quot;&gt;开源中国仓库地址&lt;/a&gt;            &lt;/div&gt;            &lt;div align=&quot;center&quot; style=&quot;padding-top: 20px;&quot;&gt;&lt;a href=&quot;https://github.com/ZHENFENG13/ssm-demo&quot;                                                              target=&quot;_blank&quot;                                                              style=&quot;font-size: 20px;&quot;&gt;Gitub仓库地址&lt;/a&gt;&lt;/div&gt;            &lt;div align=&quot;center&quot; style=&quot;padding-top: 50px;&quot;&gt;&lt;a                    href=&quot;http://download.csdn.net/detail/zhenfengshisan/9813721&quot;                    target=&quot;_blank&quot; style=&quot;font-size: 20px;&quot;&gt;项目源码下载(最新代码)&lt;/a&gt;            &lt;/div&gt;            &lt;div align=&quot;center&quot; style=&quot;padding-top: 20px;&quot;&gt;&lt;a                    href=&quot;http://download.csdn.net/detail/zhenfengshisan/9765855&quot;                    target=&quot;_blank&quot; style=&quot;font-size: 20px;&quot;&gt;项目源码下载(非maven)&lt;/a&gt;            &lt;/div&gt;            &lt;div align=&quot;center&quot; style=&quot;padding-top: 50px&quot;&gt;                &lt;font color=&quot;grey&quot; size=&quot;10&quot;&gt;ssm demo&lt;/font&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div region=&quot;west&quot; style=&quot;width: 200px;height:500px;&quot; title=&quot;导航菜单&quot;     split=&quot;true&quot;&gt;    &lt;div class=&quot;easyui-accordion&quot;&gt;        &lt;div title=&quot;文章管理&quot;             data-options=&quot;selected:true,iconCls:&#39;icon-wenzhangs&#39;&quot;             style=&quot;padding: 10px;height:10px;&quot;&gt;            &lt;a                    href=&quot;javascript:openTab(&#39; 文章管理&#39;,&#39;articleManage.jsp&#39;,&#39;icon-wenzhang&#39;)&quot;                    class=&quot;easyui-linkbutton&quot;                    data-options=&quot;plain:true,iconCls:&#39;icon-wenzhang&#39;&quot;                    style=&quot;width: 150px;&quot;&gt; 文章管理&lt;/a&gt;        &lt;/div&gt;        &lt;div title=&quot;图片管理&quot; data-options=&quot;iconCls:&#39;icon-shouye&#39;&quot;             style=&quot;padding:10px&quot;&gt;            &lt;a                    href=&quot;javascript:openTab(&#39; 图片设置&#39;,&#39;pictureManage.jsp?type=1&amp;grade=1&#39;,&#39;icon-tupians&#39;)&quot;                    class=&quot;easyui-linkbutton&quot;                    data-options=&quot;plain:true,iconCls:&#39;icon-tupian&#39;&quot;                    style=&quot;width: 150px;&quot;&gt; 图片设置&lt;/a&gt;        &lt;/div&gt;        &lt;div title=&quot;书籍管理&quot; data-options=&quot;iconCls:&#39;icon-shuji&#39;&quot;             style=&quot;padding:10px&quot;&gt;            &lt;a                    href=&quot;javascript:openTab(&#39; 全部书籍&#39;,&#39;allBooksManage.jsp&#39;,&#39;icon-shuben&#39;)&quot;                    class=&quot;easyui-linkbutton&quot;                    data-options=&quot;plain:true,iconCls:&#39;icon-shuben&#39;&quot;                    style=&quot;width: 150px;&quot;&gt;全部书籍&lt;/a&gt;        &lt;/div&gt;        &lt;div title=&quot;系统管理&quot; data-options=&quot;iconCls:&#39;icon-item&#39;&quot;             style=&quot;padding:10px;border:none;&quot;&gt;            &lt;a href=&quot;javascript:openTab(&#39; 管理员列表&#39;,&#39;userManage.jsp&#39;,&#39;icon-lxr&#39;)&quot;               class=&quot;easyui-linkbutton&quot;               data-options=&quot;plain:true,iconCls:&#39;icon-lxr&#39;&quot; style=&quot;width: 150px;&quot;&gt;                管理员列表&lt;/a&gt;&lt;a href=&quot;javascript:logout()&quot;                            class=&quot;easyui-linkbutton&quot;                            data-options=&quot;plain:true,iconCls:&#39;icon-exit&#39;&quot;                            style=&quot;width: 150px;&quot;&gt;            安全退出&lt;/a&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>main.jsp在执行其他代码之前先验证session里是否有用户，没有返回登录页面（这样可以防止强制跳转）<br><strong>loginchk.jsp</strong>  </p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;         pageEncoding=&quot;utf-8&quot; %&gt;&lt;%--防强值跳转 --%&gt;&lt;%    if (session.getAttribute(&quot;currentUser&quot;) == null) {        out.println(&quot;&lt;script&gt;window.location.href=&#39;&quot; + session.getServletContext().getContextPath() + &quot;/login.jsp&#39;;&lt;/script&gt;&quot;);    }%&gt;</code></pre><p>用户管理：usermanager.jsp<br>list.do从后台获取所有用户信息并列出  （前台需要给后台的信息是：username,开始的索引数start,往后的搜索的记录数size）并把他们封装在map里<br>相关查询语句  </p><pre><code>&lt;select id=&quot;findUsers&quot; parameterType=&quot;Map&quot; resultMap=&quot;UserResult&quot;&gt;        select id,user_name,password,role_name from ssm_user        &lt;where&gt;            &lt;if test=&quot;userName!=null and userName!=&#39;&#39; &quot;&gt;                and user_name like #{userName}            &lt;/if&gt;        &lt;/where&gt;        &lt;if test=&quot;start!=null and size!=null&quot;&gt;            limit #{start},#{size}        &lt;/if&gt;    &lt;/select&gt;</code></pre><p>增加/更新用户：save.do （需要给后台传递的信息：user的username和password）</p><pre><code>    &lt;insert id=&quot;addUser&quot; parameterType=&quot;User&quot;&gt;        insert into ssm_user(user_name,password)        values(#{userName},#{password})    &lt;/insert&gt;</code></pre><pre><code>    &lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt;        update ssm_user        &lt;set&gt;            &lt;if test=&quot;userName!=null and userName!=&#39;&#39; &quot;&gt;                user_name=#{userName},            &lt;/if&gt;            &lt;if test=&quot;password!=null and password!=&#39;&#39; &quot;&gt;                password=#{password}            &lt;/if&gt;        &lt;/set&gt;        where id=#{id} and &lt;![CDATA[ id &lt;&gt; 2 ]]&gt;    &lt;/update&gt;</code></pre><p>删除用户：delete.do</p><pre><code>    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;Integer&quot;&gt;        delete from ssm_user        where id=#{id}    &lt;/delete&gt;</code></pre><p>安全退出：logout.do<br>清除session<code>session.invalidate();</code><br>返回登录页面<code>return &quot;redirect:/login.jsp&quot;;</code>  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Easy-Ui</title>
      <link href="/2018/11/22/2018-11-22-easy-ui/"/>
      <url>/2018/11/22/2018-11-22-easy-ui/</url>
      
        <content type="html"><![CDATA[<h3 id="jquery中datagrid中getSelected和getSelections的用法"><a href="#jquery中datagrid中getSelected和getSelections的用法" class="headerlink" title="jquery中datagrid中getSelected和getSelections的用法"></a><strong>jquery中datagrid中getSelected和getSelections的用法</strong></h3><p>说明data是table表格的某一列的id<br>选中一行：  </p><pre><code>var get = $(&quot;#dg&quot;).datagrid(&quot;getSelected&quot;);</code></pre><p>获取列值：get.data，<br>选中多行：<br>遍历多行的数据  </p><pre><code>var get = $(&quot;#dg&quot;).datagrid(&quot;getSelections&quot;);for(var i=0;i&lt;get.length;i++){  var data = get[i].data;}</code></pre><h3 id="easyui-datagrid"><a href="#easyui-datagrid" class="headerlink" title="easyui-datagrid"></a><strong>easyui-datagrid</strong></h3><p>pagination    ：    设置为 true，则在数据网格（datagrid）底部显示分页工具栏。   </p><pre><code>&lt;table id=&quot;dg&quot; title=&quot;活动管理&quot; class=&quot;easyui-datagrid&quot; pagination=&quot;true&quot;       rownumbers=&quot;true&quot; fit=&quot;true&quot; data-options=&quot;pageSize:10&quot;       url=&quot;${pageContext.request.contextPath}/activity/list.do&quot; toolbar=&quot;#tb1&quot;&gt;     &lt;thead data-options=&quot;frozen:true&quot;&gt;    &lt;tr&gt;        &lt;th field=&quot;cb&quot; checkbox=&quot;true&quot; align=&quot;center&quot;&gt;&lt;/th&gt;        &lt;th field=&quot;id&quot; width=&quot;10%&quot; align=&quot;center&quot; hidden=&quot;true&quot;&gt;编号&lt;/th&gt;        &lt;th field=&quot;activityTitle&quot; width=&quot;200&quot; align=&quot;center&quot;&gt;标题&lt;/th&gt;    &lt;/tr&gt;    &lt;/thead&gt; &lt;/table&gt;</code></pre><h3 id="div-easyui-window-生成一个window窗口样式。"><a href="#div-easyui-window-生成一个window窗口样式。" class="headerlink" title="div easyui-window        生成一个window窗口样式。"></a><strong>div easyui-window        生成一个window窗口样式。</strong></h3><pre class=" language-groovy"><code class="language-groovy">属性如下：                      <span class="token number">1</span><span class="token punctuation">)</span>modal<span class="token punctuation">:</span>是否生成模态窗口。<span class="token boolean">true</span><span class="token punctuation">[</span>是<span class="token punctuation">]</span> <span class="token boolean">false</span><span class="token punctuation">[</span>否<span class="token punctuation">]</span>                      <span class="token number">2</span><span class="token punctuation">)</span>shadow<span class="token punctuation">:</span>是否显示窗口阴影。<span class="token boolean">true</span><span class="token punctuation">[</span>显示<span class="token punctuation">]</span> <span class="token boolean">false</span><span class="token punctuation">[</span>不显示<span class="token punctuation">]</span></code></pre><p>==    </p><h3 id="div-easyui-panel-生成一个面板。"><a href="#div-easyui-panel-生成一个面板。" class="headerlink" title="div easyui-panel           生成一个面板。"></a><strong>div easyui-panel           生成一个面板。</strong></h3><pre class=" language-groovy"><code class="language-groovy">       属性如下<span class="token punctuation">:</span>                    <span class="token number">1</span><span class="token punctuation">)</span>title<span class="token punctuation">:</span>该标题文本显示在面板头部。                    <span class="token number">2</span><span class="token punctuation">)</span>iconCls<span class="token punctuation">:</span>在面板上通过一个CSS类显示16x16图标。                    <span class="token number">3</span><span class="token punctuation">)</span>width<span class="token punctuation">:</span>设置面板宽度。默认auto。                    <span class="token number">4</span><span class="token punctuation">)</span>height<span class="token punctuation">:</span>设置面板高度。默认auto。                    <span class="token number">5</span><span class="token punctuation">)</span>left<span class="token punctuation">:</span>设置面板左边距。                    <span class="token number">6</span><span class="token punctuation">)</span>top<span class="token punctuation">:</span>设置面板顶部位置。                    <span class="token number">7</span><span class="token punctuation">)</span>cls<span class="token punctuation">:</span>在面板中增加一个Class类。                    <span class="token number">8</span><span class="token punctuation">)</span>headerCls<span class="token punctuation">:</span>在面板头部中增加一个Class类。                    <span class="token number">9</span><span class="token punctuation">)</span>bodyCls<span class="token punctuation">:</span>在面板内容中增加一个Class类。                   <span class="token number">10</span><span class="token punctuation">)</span>style<span class="token punctuation">:</span>在面板中增加一个指定样式。                   <span class="token number">11</span><span class="token punctuation">)</span>fit<span class="token punctuation">:</span>当True时设置该面板尺寸适合于它的父容器。默认<span class="token boolean">false</span>。                   <span class="token number">12</span><span class="token punctuation">)</span>border<span class="token punctuation">:</span>当定义时显示面板边界。默认<span class="token boolean">true</span>。                   <span class="token number">13</span><span class="token punctuation">)</span>doSize<span class="token punctuation">:</span>如果设置为True，该面板将重绘大小，并重建布局。默认<span class="token boolean">true</span>。                   <span class="token number">14</span><span class="token punctuation">)</span>collapsible<span class="token punctuation">:</span>当定义时显示可折叠面板的按钮。默认<span class="token boolean">false</span>。                   <span class="token number">15</span><span class="token punctuation">)</span>minimizable<span class="token punctuation">:</span>当定义时显示最小化面板的按钮。默认<span class="token boolean">false</span>。                    <span class="token number">16</span><span class="token punctuation">)</span>maximizable<span class="token punctuation">:</span>当定义时显示最大化面板的按钮。默认<span class="token boolean">false</span>。                    <span class="token number">17</span><span class="token punctuation">)</span>closable<span class="token punctuation">:</span>当定义时显示关闭面板的按钮。默认<span class="token boolean">false</span>。                   <span class="token number">18</span><span class="token punctuation">)</span>tools<span class="token punctuation">:</span>自定义工具栏，每个工具都包含两个属性<span class="token punctuation">:</span>iconCls、handler。                    <span class="token number">19</span><span class="token punctuation">)</span>collapsed<span class="token punctuation">:</span>当定义时该面板初始化时处于收缩状态。默认<span class="token boolean">false</span>。                    <span class="token number">20</span><span class="token punctuation">)</span>minimized<span class="token punctuation">:</span>当定义时该面板初始化时处于最小化状态。默认<span class="token boolean">false</span>。                   <span class="token number">21</span><span class="token punctuation">)</span>maximized<span class="token punctuation">:</span>当定义时该面板初始化时处于最大化状态。默认<span class="token boolean">false</span>。                   <span class="token number">22</span><span class="token punctuation">)</span>closed：当定义时该面板初始化时处于关闭状态。默认<span class="token boolean">false</span>。                   <span class="token number">23</span><span class="token punctuation">)</span>href<span class="token punctuation">:</span>一个url，加载远程数据并显示在面板中。                   <span class="token number">24</span><span class="token punctuation">)</span>loadingMessage<span class="token punctuation">:</span>当加载远程数据时，在面板中显示一个消息。默认Loading…                事件如下<span class="token punctuation">:</span>                    <span class="token number">1</span><span class="token punctuation">)</span>onLoad<span class="token punctuation">:</span>当远程数据加载完毕后激活。                    <span class="token number">2</span><span class="token punctuation">)</span>onBeforeOpen<span class="token punctuation">:</span>当面板打开前激活。                    <span class="token number">3</span><span class="token punctuation">)</span>onOpen<span class="token punctuation">:</span>当面板打开后激活。                    <span class="token number">4</span><span class="token punctuation">)</span>onBeforeClose<span class="token punctuation">:</span>当面板关闭前激活。                    <span class="token number">5</span><span class="token punctuation">)</span>onClose<span class="token punctuation">:</span>当面板关闭后激活。                    <span class="token number">6</span><span class="token punctuation">)</span>onBeforeDestroy<span class="token punctuation">:</span>当面板销毁前激活。                    <span class="token number">7</span><span class="token punctuation">)</span>onDestroy<span class="token punctuation">:</span>当面板销毁后激活。                    <span class="token number">8</span><span class="token punctuation">)</span>onBeforeCollpase<span class="token punctuation">:</span>当面板收缩前激活。                    <span class="token number">9</span><span class="token punctuation">)</span>onCollapse<span class="token punctuation">:</span>当面板收缩后激活。                   <span class="token number">10</span><span class="token punctuation">)</span>onBeforeExpand<span class="token punctuation">:</span>当面板扩展前激活。                      <span class="token number">11</span><span class="token punctuation">)</span>onExpand<span class="token punctuation">:</span>当面板扩展后激活。                   <span class="token number">12</span><span class="token punctuation">)</span>onResize<span class="token punctuation">:</span>当面板重绘后激活。                         width<span class="token punctuation">:</span>新建的外部宽度                         height<span class="token punctuation">:</span>新建的外部高度                   <span class="token number">13</span><span class="token punctuation">)</span>onMove<span class="token punctuation">:</span>当面板移动后激活。                        left<span class="token punctuation">:</span>左侧新位置。                        top<span class="token punctuation">:</span>顶部新位置。                   <span class="token number">14</span><span class="token punctuation">)</span>onMaximize<span class="token punctuation">:</span>当窗口最大化后激活。                   <span class="token number">15</span><span class="token punctuation">)</span>onRestore<span class="token punctuation">:</span>当窗口恢复到原来大小时激活。                   <span class="token number">16</span><span class="token punctuation">)</span>onMinimize<span class="token punctuation">:</span>当窗口最小化后激活。                方法如下：                    <span class="token number">1</span><span class="token punctuation">)</span>options<span class="token punctuation">:</span>返回options属性。                    <span class="token number">2</span><span class="token punctuation">)</span>panel<span class="token punctuation">:</span>返回面板对象。                   <span class="token number">3</span><span class="token punctuation">)</span>header<span class="token punctuation">:</span>返回面板头部对象。                    <span class="token number">4</span><span class="token punctuation">)</span>body<span class="token punctuation">:</span>返回面板主体对象。                    <span class="token number">5</span><span class="token punctuation">)</span>setTitle<span class="token punctuation">:</span>设置头部的标题文本。                    <span class="token number">6</span><span class="token punctuation">)</span>open<span class="token punctuation">:</span>当forceOpen参数设置为<span class="token boolean">true</span>时，面板打开时绕过onBeforeOpen回调函数。                    <span class="token number">7</span><span class="token punctuation">)</span>close<span class="token punctuation">:</span>当forceClose参数设置为<span class="token boolean">true</span>时，该面板关闭时绕过onBeforeClose回调函数。                    <span class="token number">8</span><span class="token punctuation">)</span>destroy<span class="token punctuation">:</span>当forceDestroy参数设置为<span class="token boolean">true</span>时该面板销毁时绕过onBeforeDestroy回调函数。                    <span class="token number">9</span><span class="token punctuation">)</span>refresh<span class="token punctuation">:</span>当href属性设置后刷新该面板以加载远程数据。                   <span class="token number">10</span><span class="token punctuation">)</span>resize<span class="token punctuation">:</span>设置面板的大小和布局。该options对象包含以下属性<span class="token punctuation">:</span>                        width：新的面板宽度。                        height：新的面板高度。                        left：新的面板左侧位置。                        top：新的面板顶部位置。                   <span class="token number">11</span><span class="token punctuation">)</span>move<span class="token punctuation">:</span>移动面板到一个新的位置。该options对象包含以下属性：                        left：新的面板左侧位置。                        top：新的面板顶部位置。 </code></pre><h3 id="a-easyui-linkbutton-生成链接类型的按钮。"><a href="#a-easyui-linkbutton-生成链接类型的按钮。" class="headerlink" title="a  easyui-linkbutton                    生成链接类型的按钮。"></a><strong>a  easyui-linkbutton                    生成链接类型的按钮。</strong></h3><pre class=" language-vbscript"><code class="language-vbscript">       属性如下：               1)disabled:当True时禁用该按钮。默认false。               2)plain:当True时显示一个普通效果。默认false。 </code></pre><h3 id="input-textarea-easyui-validatebox-生成字段验证。"><a href="#input-textarea-easyui-validatebox-生成字段验证。" class="headerlink" title="input/textarea easyui-validatebox       生成字段验证。"></a><strong>input/textarea easyui-validatebox       生成字段验证。</strong></h3><pre class=" language-livecodeserver"><code class="language-livecodeserver">              属性如下：                 1)required:true[必需] false[不必需] 默认false                 2)validType:                    a、length[a,b] 字段长度控制在a至b之间。                    b、email       验证Email。                    c、url      验证网络地址。                  3)missingMessage：当文本时出现空时弹出该工具提示，系统有默认[英文]，自定义可覆盖它。                 4)invalidMessage：当文本内容无效后弹出该工具提示，系统有默认[英文]，自定义可覆盖它。   </code></pre><h3 id="ul-easyui-tree-生成一个树形结构。"><a href="#ul-easyui-tree-生成一个树形结构。" class="headerlink" title="ul easyui-tree         生成一个树形结构。"></a><strong>ul easyui-tree         生成一个树形结构。</strong></h3><pre class=" language-groovy"><code class="language-groovy">             属性如下：                 <span class="token number">1</span><span class="token punctuation">)</span>url<span class="token punctuation">:</span>一个获取远程数据的地址。                 <span class="token number">2</span><span class="token punctuation">)</span>animate<span class="token punctuation">:</span>当展开或折叠节点时是否定义动画效果。<span class="token boolean">true</span><span class="token punctuation">[</span>是<span class="token punctuation">]</span> <span class="token boolean">false</span><span class="token punctuation">[</span>否<span class="token punctuation">]</span> 默认<span class="token boolean">false</span>                节点属性如下：                <span class="token number">1</span><span class="token punctuation">)</span>text<span class="token punctuation">:</span>节点的显示文本。                <span class="token number">2</span><span class="token punctuation">)</span>id<span class="token punctuation">:</span>节点ID，对于加载远程数据时非常重要。                <span class="token number">3</span><span class="token punctuation">)</span>state<span class="token punctuation">:</span>节点状态，<span class="token string">'open'</span>或<span class="token string">'closed'</span>，默认为<span class="token string">'open'</span>。当设置为<span class="token string">'关闭'</span>，该节点包含子节点，并将远程站点加载它们<span class="token punctuation">(</span>并非触发再加载<span class="token punctuation">)</span>。                <span class="token number">4</span><span class="token punctuation">)</span>attributes<span class="token punctuation">:</span>为节点添加自定义属性。                <span class="token number">5</span><span class="token punctuation">)</span>children<span class="token punctuation">:</span>以数组节点的方式定义一些字节点。                事件如下：                    <span class="token number">1</span><span class="token punctuation">)</span>onClick<span class="token punctuation">:</span>                       当用户点击一个节点时激活，该节点参数包含如下属性：                       id：节点ID                        text<span class="token punctuation">:</span>节点文本                        attributes<span class="token punctuation">:</span>节点自定义属性。                      target<span class="token punctuation">:</span>目标点击的DOM对象。                 <span class="token number">2</span><span class="token punctuation">)</span>onLoadSuccess<span class="token punctuation">:</span>                     当数据成功加载数据时激活，该参数跟jQuery<span class="token operator">.</span>ajax的<span class="token string">'success'</span>函数效果相同。                <span class="token number">3</span><span class="token punctuation">)</span>onLoadError<span class="token punctuation">:</span>                    当数据加载数据失败时激活，该参数跟jQuery<span class="token operator">.</span>ajax的<span class="token string">'error'</span>函数效果相同。               方法如下<span class="token punctuation">:</span>                   <span class="token number">1</span><span class="token punctuation">)</span>reload<span class="token punctuation">:</span>重新加载树数据。                   <span class="token number">2</span><span class="token punctuation">)</span>getSelected<span class="token punctuation">:</span>获取选中的节点并返回它，如果没有选择节点将返回null。                    <span class="token number">3</span><span class="token punctuation">)</span>collapse<span class="token punctuation">:</span>折叠一个节点，该目标参数是该节点的DOM对象。                 <span class="token number">4</span><span class="token punctuation">)</span>expand<span class="token punctuation">:</span>展开一个节点，该目标参数是该节点的DOM对象。                   <span class="token number">5</span><span class="token punctuation">)</span>append<span class="token punctuation">:</span>在一个父节点追加一些子节点。                       param有两个属性：                       parent<span class="token punctuation">:</span>DOM对象，把它作为父节点追加<span class="token punctuation">(</span>它们<span class="token punctuation">)</span>。                       data<span class="token punctuation">:</span>array，或者节点数据。                 <span class="token number">6</span><span class="token punctuation">)</span>remove<span class="token punctuation">:</span>删除它以及它以下的子节点，该目标参数是该节点的DOM对象。   </code></pre><h3 id="table-easyui-datagrid-生成一个表格。"><a href="#table-easyui-datagrid-生成一个表格。" class="headerlink" title="table easyui-datagrid                   生成一个表格。"></a><strong>table easyui-datagrid                   生成一个表格。</strong></h3><pre class=" language-groovy"><code class="language-groovy">             属性如下：                    <span class="token number">1</span><span class="token punctuation">)</span>title<span class="token punctuation">:</span>该DataGrid面板的标题文本。                    <span class="token number">2</span><span class="token punctuation">)</span>iconCls<span class="token punctuation">:</span>一个CSS类，将提供一个背景图片作为标题图标。                    <span class="token number">3</span><span class="token punctuation">)</span>border：当<span class="token boolean">true</span>时，显示该datagrid面板的边框。                    <span class="token number">4</span><span class="token punctuation">)</span>width<span class="token punctuation">:</span>面板宽度，自动列宽。                    <span class="token number">5</span><span class="token punctuation">)</span>height<span class="token punctuation">:</span>面板高度，自动列高。                    <span class="token number">6</span><span class="token punctuation">)</span>columns<span class="token punctuation">:</span>该DataGrid列配置对象，查看column属性可获取更多信息。                    <span class="token number">7</span><span class="token punctuation">)</span>frozenColumns<span class="token punctuation">:</span>跟Columns属性相同，但是这些列将会被固定在左边。                    <span class="token number">8</span><span class="token punctuation">)</span>striped<span class="token punctuation">:</span>当<span class="token boolean">true</span>时，单元格显示条纹。默认<span class="token boolean">false</span>。                    <span class="token number">9</span><span class="token punctuation">)</span>method<span class="token punctuation">:</span>通过该方法类型请求远程数据。默认post。                   <span class="token number">10</span><span class="token punctuation">)</span>nowrap<span class="token punctuation">:</span>当<span class="token boolean">true</span>时，显示数据在同一行上。默认<span class="token boolean">true</span>。                   <span class="token number">11</span><span class="token punctuation">)</span>idField<span class="token punctuation">:</span>说明哪个字段是一个标识字段。                   <span class="token number">12</span><span class="token punctuation">)</span>url<span class="token punctuation">:</span>一个URL，从远程站点获取数据。                   <span class="token number">13</span><span class="token punctuation">)</span>loadMsg<span class="token punctuation">:</span>当从远程站点加载数据时，显示一个提示信息。默认<span class="token string">"Processing,please wait …"</span>。自定义覆盖。                   <span class="token number">14</span><span class="token punctuation">)</span>pagination<span class="token punctuation">:</span>当<span class="token boolean">true</span>时在DataGrid底部显示一个分页工具栏。默认<span class="token boolean">false</span>。                   <span class="token number">15</span><span class="token punctuation">)</span>rownumbers<span class="token punctuation">:</span>当<span class="token boolean">true</span>时显示行号。默认<span class="token boolean">false</span>。                   <span class="token number">16</span><span class="token punctuation">)</span>singleSelect<span class="token punctuation">:</span>当<span class="token boolean">true</span>时只允许当前选择一行。默认<span class="token boolean">false</span>。                   <span class="token number">17</span><span class="token punctuation">)</span>fit<span class="token punctuation">:</span>当<span class="token boolean">true</span>时，设置大小以适应它的父容器。默认<span class="token boolean">false</span>。                   <span class="token number">18</span><span class="token punctuation">)</span>pageNumber<span class="token punctuation">:</span>当设置分页属性时，初始化的页码编号。默认从<span class="token number">1</span>开始                   <span class="token number">19</span><span class="token punctuation">)</span>pageSize<span class="token punctuation">:</span>当设置分页属性是，初始化的页面大小。默认<span class="token number">10</span>行                   <span class="token number">20</span><span class="token punctuation">)</span>pageList<span class="token punctuation">:</span>当设置分页属性时，初始化页面的大小选择清单。默认<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">]</span>                   <span class="token number">21</span><span class="token punctuation">)</span>queryParams<span class="token punctuation">:</span>当请求远程数据时，也可以发送额外的参数。                   <span class="token number">22</span><span class="token punctuation">)</span>sortName<span class="token punctuation">:</span>定义哪列可以排序。                   <span class="token number">23</span><span class="token punctuation">)</span>sortOrder<span class="token punctuation">:</span>定义列的排列顺序，只能是<span class="token string">'asc'</span>或<span class="token string">'desc'</span>。默认asc。                Column属性如下：                    <span class="token number">1</span><span class="token punctuation">)</span>title<span class="token punctuation">:</span>该列标题文本。                    <span class="token number">2</span><span class="token punctuation">)</span>field<span class="token punctuation">:</span>该列对应的字段名称。                    <span class="token number">3</span><span class="token punctuation">)</span>width：列宽。                    <span class="token number">4</span><span class="token punctuation">)</span>rowspan<span class="token punctuation">:</span>说明该单元格需要多少行数。                    <span class="token number">5</span><span class="token punctuation">)</span>colspan<span class="token punctuation">:</span>说明该单元格需要多少列数。                    <span class="token number">6</span><span class="token punctuation">)</span>align<span class="token punctuation">:</span>说明Column数据的对齐方式。<span class="token string">'left'</span>，<span class="token string">'right'</span>，<span class="token string">'center'</span> 都可以使用。                    <span class="token number">7</span><span class="token punctuation">)</span>sortable<span class="token punctuation">:</span>当<span class="token boolean">true</span>时，允许该列进行排序。                    <span class="token number">8</span><span class="token punctuation">)</span>checkbox<span class="token punctuation">:</span>当<span class="token boolean">true</span>时，允许该列出现checkbox。                事件如下：                    <span class="token number">1</span><span class="token punctuation">)</span>onLoadSuccess<span class="token punctuation">:</span>当远程数据加载成功是激活。                    <span class="token number">2</span><span class="token punctuation">)</span>onLoadError<span class="token punctuation">:</span>当远程数据加载发现一些错误时激活。                    <span class="token number">3</span><span class="token punctuation">)</span>onClickRow<span class="token punctuation">:</span>当用户点击某行时激活，参数包含：                       rowIndex<span class="token punctuation">:</span> 点击的行索引，从<span class="token number">0</span>开始。                       rowData<span class="token punctuation">:</span> 点击行时对应的记录。                   <span class="token number">4</span><span class="token punctuation">)</span>onDblClickRow<span class="token punctuation">:</span>当用户双击某行时激活，参数包含：                       rowIndex<span class="token punctuation">:</span> 点击的行索引，从<span class="token number">0</span>开始。                       rowData<span class="token punctuation">:</span> 点击行时对应的记录。                   <span class="token number">5</span><span class="token punctuation">)</span>onSortColumn<span class="token punctuation">:</span>当用户对某列排序时激活，参数包含：                      sort<span class="token punctuation">:</span>排序字段名称。                      order<span class="token punctuation">:</span>排序字段类型。                   <span class="token number">6</span><span class="token punctuation">)</span>onSelect<span class="token punctuation">:</span>当用户选择某行时激活，参数包含<span class="token punctuation">:</span>                      rowIndex<span class="token punctuation">:</span> 点击的行索引，从<span class="token number">0</span>开始。                      rowData<span class="token punctuation">:</span> 点击行时对应的记录。                   <span class="token number">7</span><span class="token punctuation">)</span>onUnselect<span class="token punctuation">:</span>当用户取消选择某行时激活，参数包含<span class="token punctuation">:</span>                       rowIndex<span class="token punctuation">:</span> 点击的行索引，从<span class="token number">0</span>开始。                       rowData<span class="token punctuation">:</span> 点击行时对应的记录。                方法如下：                    <span class="token number">1</span><span class="token punctuation">)</span>options<span class="token punctuation">:</span>返回选择对象。                    <span class="token number">2</span><span class="token punctuation">)</span>resize<span class="token punctuation">:</span>重调大小，生成布局。                    <span class="token number">3</span><span class="token punctuation">)</span>reload<span class="token punctuation">:</span>重新加载数据。                    <span class="token number">4</span><span class="token punctuation">)</span>fixColumnSize<span class="token punctuation">:</span>固定列大小。                    <span class="token number">5</span><span class="token punctuation">)</span>loadData<span class="token punctuation">:</span>加载本地数据，过去的行会被删除。                    <span class="token number">6</span><span class="token punctuation">)</span>getSelected<span class="token punctuation">:</span>返回第一个选中行的记录，若未选返回null。                    <span class="token number">7</span><span class="token punctuation">)</span>getSelections<span class="token punctuation">:</span>返回选中的所有行，当没有选择记录时将返回空数组。                    <span class="token number">8</span><span class="token punctuation">)</span>clearSelections<span class="token punctuation">:</span>清除所有选项的选择状态。                    <span class="token number">9</span><span class="token punctuation">)</span>selectRow<span class="token punctuation">:</span>选择一行，行索引从<span class="token number">0</span>开始。                   <span class="token number">10</span><span class="token punctuation">)</span>selectRecord<span class="token punctuation">:</span>通过传递一个ID值参数，选择一行。                   <span class="token number">11</span><span class="token punctuation">)</span>unselectRow<span class="token punctuation">:</span>取消选择一行。</code></pre><h3 id="div-easyui-tabs-生成一个tab容器。"><a href="#div-easyui-tabs-生成一个tab容器。" class="headerlink" title="div easyui-tabs                         生成一个tab容器。"></a><strong>div easyui-tabs                         生成一个tab容器。</strong></h3><pre class=" language-stata"><code class="language-stata">             属性如下：                     1)width:容器宽度，自动列宽。                    2)height:容器高度，自动列高。                    3)idSeed:该根id衍生成标签面板DOM id属性。默认0                    4)plain：当true时，该Tab渲染不使用容器背景图片。默认false                    5)fit:当true时，设置该Tab大小以适应它的父容器。默认false                     6)border:当true时，显示该Tab边框。                    7)scrollIncrement:                    8)scrollDuration:                事件如下：                    1)onLoad:当一个ajax Tab面板需要加载远程数据时激活。该参数跟jQuery.ajax的'success'函数效果相同。                    2)onSelect:当用户选择一个Tab面板时激活。                     3)onClose:当用户关闭一个Tab面板时激活。                方法如下:                    1)resize:重绘该Tab容器的布局。                    2)add:新增加一个Tab面板，该选项参数是一个配置对象，看Tab面板属性可获取更多信息。                    3)close：关闭该Tab面板，标题参数显示你要关闭的对象。                    4)select:选择一个Tab面板。                    5)exists:如果该Tab面板存在即显示。                Tab面板属性如下：                    1)id:该Tab面板DOM id属性。                    2)text:该Tab面板标题文本。                    3)content:该Tab面板内容。                    4)href:一个URL，加载远程内容以填充Tab面板。                    5)cache:当true时，缓存Tab面板，当href 属性设置后有效。默认true                     6)icon:增加一个CSS class图标以显示在Tab面板的标题旁。                     7)closable:当true时，该Tab面板将显示可关闭按钮，点击能关闭该Tab面板。默认false                     8)selected:当true时，该Tab面板将被选中。默认false                     9)width:面板宽度，自动列宽。                    10)height:面板高度，自动列高。</code></pre><h3 id="div-menu-sep-生成一个菜单分隔线。"><a href="#div-menu-sep-生成一个菜单分隔线。" class="headerlink" title="div menu-sep              生成一个菜单分隔线。"></a>div menu-sep              生成一个菜单分隔线。</h3><h3 id="a-easyui-splitbutton-生成一个菜单列。"><a href="#a-easyui-splitbutton-生成一个菜单列。" class="headerlink" title="a easyui-splitbutton         生成一个菜单列。"></a>a easyui-splitbutton         生成一个菜单列。</h3><h3 id="div-easyui-accordion-生成手风琴式下拉框。继承自panel"><a href="#div-easyui-accordion-生成手风琴式下拉框。继承自panel" class="headerlink" title="div easyui-accordion        生成手风琴式下拉框。继承自panel"></a>div easyui-accordion        生成手风琴式下拉框。继承自panel</h3><h3 id="select-easyui-combobox-生成一个组合下拉框。"><a href="#select-easyui-combobox-生成一个组合下拉框。" class="headerlink" title="select easyui-combobox       生成一个组合下拉框。"></a><strong>select easyui-combobox       生成一个组合下拉框</strong>。</h3><pre class=" language-groovy"><code class="language-groovy">             属性如下：                    <span class="token number">1</span><span class="token punctuation">)</span>width<span class="token punctuation">:</span>容器宽度，自动列宽。                    <span class="token number">2</span><span class="token punctuation">)</span>listWidth<span class="token punctuation">:</span>该组合下拉框的宽度。                    <span class="token number">3</span><span class="token punctuation">)</span>listHeight<span class="token punctuation">:</span>该组合下拉框的高度。                    <span class="token number">4</span><span class="token punctuation">)</span>valueField：把该基础数据的值名称绑定到组合下拉框中<span class="token punctuation">[</span>value<span class="token punctuation">]</span>。                    <span class="token number">5</span><span class="token punctuation">)</span>textField<span class="token punctuation">:</span>把该基础数据的字段名称绑定到组合下拉框中<span class="token punctuation">[</span>text<span class="token punctuation">]</span>。                    <span class="token number">6</span><span class="token punctuation">)</span>editable<span class="token punctuation">:</span>当True时，可直接在文字域中键入文本。默认<span class="token boolean">true</span>。                    <span class="token number">7</span><span class="token punctuation">)</span>url<span class="token punctuation">:</span>一个URL，从远程加载列表数据。                事件如下：                    <span class="token number">1</span><span class="token punctuation">)</span>onLoadSuccess<span class="token punctuation">:</span>当远程数据加载成功是激活。                    <span class="token number">2</span><span class="token punctuation">)</span>onLoadError<span class="token punctuation">:</span>当远程数据加载发现一些错误时激活。                    <span class="token number">2</span><span class="token punctuation">)</span>onSelect<span class="token punctuation">:</span>当用户选择一个列表选项时激活。                    <span class="token number">3</span><span class="token punctuation">)</span>onChange<span class="token punctuation">:</span>当该字段的值发生改变时激活。                方法如下<span class="token punctuation">:</span>                    <span class="token number">1</span><span class="token punctuation">)</span>select<span class="token punctuation">:</span> 在下拉列表中选择一个值。                    <span class="token number">2</span><span class="token punctuation">)</span>setValue<span class="token punctuation">:</span> 设置指定值到该字段。在<span class="token string">'param'</span> 参数可以是一个字符串或者一个JS对象。注<span class="token punctuation">:</span>JS对象包含的属性对应valueField和TextField两个属性。                    <span class="token number">3</span><span class="token punctuation">)</span>getValue<span class="token punctuation">:</span> 获取该字段的值。                     <span class="token number">4</span><span class="token punctuation">)</span>reload<span class="token punctuation">:</span>   重新请求远程列表数据。</code></pre><h3 id="select-easyui-combotree-生成一个组合树形框。"><a href="#select-easyui-combotree-生成一个组合树形框。" class="headerlink" title="select easyui-combotree      生成一个组合树形框。"></a><strong>select easyui-combotree      生成一个组合树形框。</strong></h3><pre class=" language-groovy"><code class="language-groovy">            属性如下：               <span class="token number">1</span><span class="token punctuation">)</span>width<span class="token punctuation">:</span>容器宽度，自动列宽。               <span class="token number">2</span><span class="token punctuation">)</span>treeWidth<span class="token punctuation">:</span>该树形下拉框的宽度。               <span class="token number">3</span><span class="token punctuation">)</span>treeHeight<span class="token punctuation">:</span>该树形下拉框的高度。               <span class="token number">4</span><span class="token punctuation">)</span>url<span class="token punctuation">:</span>一个URL，从远程加载树形数据。                事件如下：                <span class="token number">1</span><span class="token punctuation">)</span>onSelect<span class="token punctuation">:</span>当用户选择一个树形节点时激活。                <span class="token number">2</span><span class="token punctuation">)</span>onChange<span class="token punctuation">:</span>当该字段的值发生改变时激活。                方法如下<span class="token punctuation">:</span>                <span class="token number">1</span><span class="token punctuation">)</span>setValue<span class="token punctuation">:</span> 设置指定值到该字段。在<span class="token string">'param'</span> 参数可以是一个树形节点ID值或者一个JS对象。注<span class="token punctuation">:</span>JS对象包含的属性对应id和text两个属性。                <span class="token number">2</span><span class="token punctuation">)</span>getValue<span class="token punctuation">:</span> 获取该字段的值。                 <span class="token number">3</span><span class="token punctuation">)</span>reload<span class="token punctuation">:</span>   重新请求远程列表数据。 </code></pre><h3 id="body-div-easyui-layout生成一个布局"><a href="#body-div-easyui-layout生成一个布局" class="headerlink" title="body[div] easyui-layout生成一个布局"></a><strong>body[div] easyui-layout生成一个布局</strong></h3><pre class=" language-groovy"><code class="language-groovy">            属性如下：               <span class="token number">1</span><span class="token punctuation">)</span>title<span class="token punctuation">:</span>该面板标题文本。               <span class="token number">2</span><span class="token punctuation">)</span>region<span class="token punctuation">:</span>定义布局面板的位置，包含下列值<span class="token punctuation">:</span>north<span class="token punctuation">,</span>south<span class="token punctuation">,</span> east<span class="token punctuation">,</span> west<span class="token punctuation">,</span> center。               <span class="token number">3</span><span class="token punctuation">)</span>border<span class="token punctuation">:</span>当True时显示布局面板的边框。默认为True。               <span class="token number">4</span><span class="token punctuation">)</span>split<span class="token punctuation">:</span> 当True时显示一个分割符以使用户改变面板的尺寸。默认<span class="token boolean">false</span>。               <span class="token number">5</span><span class="token punctuation">)</span>icon<span class="token punctuation">:</span>一个图标CSS类，在面板头部显示一个图标。                <span class="token number">6</span><span class="token punctuation">)</span>href<span class="token punctuation">:</span>一个URL<span class="token punctuation">,</span>以从远程站点加载数据。</code></pre><h3 id="div-easyui-menu-生成一个菜单"><a href="#div-easyui-menu-生成一个菜单" class="headerlink" title="div easyui-menu        生成一个菜单"></a><strong>div easyui-menu        生成一个菜单</strong></h3><pre class=" language-groovy"><code class="language-groovy">            属性如下：               <span class="token number">1</span><span class="token punctuation">)</span>zIndex<span class="token punctuation">:</span> Menu z<span class="token operator">-</span>index样式。注释：z<span class="token operator">-</span>index 属性设置元素的堆叠顺序。                <span class="token number">2</span><span class="token punctuation">)</span>left<span class="token punctuation">:</span>菜单左起位置。默认<span class="token number">0</span>。               <span class="token number">3</span><span class="token punctuation">)</span>top<span class="token punctuation">:</span> 菜单顶部位置。默认<span class="token number">0</span>。                <span class="token number">4</span><span class="token punctuation">)</span>href<span class="token punctuation">:</span>当点击菜单项时能在当前浏览器窗口显示不同的网址。               事件如下<span class="token punctuation">:</span>               <span class="token number">1</span><span class="token punctuation">)</span>onShow<span class="token punctuation">:</span>激活后显示菜单。               <span class="token number">2</span><span class="token punctuation">)</span>onHide<span class="token punctuation">:</span>激活后隐藏菜单。               方法如下<span class="token punctuation">:</span>               <span class="token number">1</span><span class="token punctuation">)</span>show<span class="token punctuation">:</span>在指定的位置显示一个菜单。该位置上包含两个参数：                   left<span class="token punctuation">:</span>新的左起位置。                  top<span class="token punctuation">:</span>新的顶部位置。               <span class="token number">2</span><span class="token punctuation">)</span>hide<span class="token punctuation">:</span>隐藏一个菜单。   </code></pre><h3 id="a-easyui-menubutton-生成一个菜单按钮。"><a href="#a-easyui-menubutton-生成一个菜单按钮。" class="headerlink" title="a easyui-menubutton       生成一个菜单按钮。"></a><strong>a easyui-menubutton       生成一个菜单按钮。</strong></h3><pre class=" language-groovy"><code class="language-groovy">            属性如下：               <span class="token number">1</span><span class="token punctuation">)</span>disabled<span class="token punctuation">:</span>当True时禁用该按钮。默认<span class="token boolean">false</span>。               <span class="token number">2</span><span class="token punctuation">)</span>plain<span class="token punctuation">:</span>当True时显示一个普通效果。默认<span class="token boolean">false</span>。                <span class="token number">3</span><span class="token punctuation">)</span>menu<span class="token punctuation">:</span>一个选择器名称，用来创建相应的菜单。               <span class="token number">4</span><span class="token punctuation">)</span>duration<span class="token punctuation">:</span> 当悬停该按钮时，定义菜单的持续显示时间，单位为毫秒。默认<span class="token number">100</span>。</code></pre><h3 id="input-easyui-numberbox-生成一个数字输入框。"><a href="#input-easyui-numberbox-生成一个数字输入框。" class="headerlink" title="input easyui-numberbox      生成一个数字输入框。"></a><strong>input easyui-numberbox      生成一个数字输入框</strong>。</h3><pre class=" language-irpf90"><code class="language-irpf90">            选项如下:               1)min:允许的最小值。当输入值小于最小值时，显示最小值。               2)max:允许的最大值。当输入值大于最大值时，显示最大值。               3)precision:分隔符后能精确的小数点位数。整数默认会追加小数点位数。 </code></pre><h2 id="JS定义："><a href="#JS定义：" class="headerlink" title="JS定义："></a><strong>JS定义：</strong></h2><pre class=" language-groovy"><code class="language-groovy"><span class="token number">1</span>、 <span class="token operator">.</span>window            生成一个window窗口。   <span class="token number">2</span>、 <span class="token operator">.</span>tree                  生成一个树形结构。   <span class="token number">3</span>、 <span class="token operator">.</span>datagrid           生成一个表格。   <span class="token number">4</span>、 <span class="token operator">.</span>combobox        生成一个组合下拉框。   <span class="token number">5</span>、 <span class="token operator">.</span>combotree       生成一个组合树形框。   <span class="token number">6</span>、 <span class="token operator">.</span>dialog               生成一个对话框。它继承自window         私有属性如下：                    <span class="token number">1</span><span class="token punctuation">)</span>title<span class="token punctuation">:</span>该对话框标题文本。默认<span class="token string">"New Dialog"</span>。                    <span class="token number">2</span><span class="token punctuation">)</span>collapsible<span class="token punctuation">:</span>当True时可显示折叠按钮。默认<span class="token boolean">false</span>。                    <span class="token number">3</span><span class="token punctuation">)</span>minimizable<span class="token punctuation">:</span>当True时可显示最小化按钮。默认<span class="token boolean">false</span>。                    <span class="token number">4</span><span class="token punctuation">)</span>maximizable<span class="token punctuation">:</span>当True时可显示最大化按钮。默认<span class="token boolean">false</span>。                    <span class="token number">5</span><span class="token punctuation">)</span>resizable<span class="token punctuation">:</span>当True时能重绘对话框大小。默认<span class="token boolean">false</span>。                    <span class="token number">6</span><span class="token punctuation">)</span>toolbar<span class="token punctuation">:</span>该工具栏置于对话框的顶部，每个工具栏包含<span class="token punctuation">:</span>text<span class="token punctuation">,</span> iconCls<span class="token punctuation">,</span> disabled<span class="token punctuation">,</span> handler等属性。                    <span class="token number">7</span><span class="token punctuation">)</span>buttons<span class="token punctuation">:</span>这个按钮置于对话框的底部，每个按钮包含<span class="token punctuation">:</span>text<span class="token punctuation">,</span> iconCls<span class="token punctuation">,</span> handler等属性。   <span class="token number">7</span>、 <span class="token operator">.</span>draggable          生成一个可自由拖动的块。         属性如下<span class="token punctuation">:</span>                 <span class="token number">1</span><span class="token punctuation">)</span>handle<span class="token punctuation">:</span>选择<span class="token string">"#id"</span>进行拖动。                 <span class="token number">2</span><span class="token punctuation">)</span>disabled<span class="token punctuation">:</span>当True时停止自由拖动。默认<span class="token boolean">false</span>。                 <span class="token number">3</span><span class="token punctuation">)</span>edge<span class="token punctuation">:</span>开始拖动拖动块时的宽度。默认<span class="token number">0</span>。                 <span class="token number">4</span><span class="token punctuation">)</span>axis<span class="token punctuation">:</span>当拖动块移动时定义轴，可选值是<span class="token string">'v'</span>或者<span class="token string">'h'</span><span class="token punctuation">,</span>当超出<span class="token string">'v'</span>和<span class="token string">'h'</span>的方位时将设置为null。        事件如下：                     <span class="token number">1</span><span class="token punctuation">)</span>onStartDrag<span class="token punctuation">:</span>当目标对象开始拖动时激活。                    <span class="token number">2</span><span class="token punctuation">)</span>onDrag<span class="token punctuation">:</span>在拖动期间激活。返回<span class="token boolean">false</span>将不会实际拖动它<span class="token punctuation">(</span>的位置<span class="token punctuation">)</span>。                    <span class="token number">3</span><span class="token punctuation">)</span>onStopDrag<span class="token punctuation">:</span>当目标对象停止拖动时激活。    <span class="token number">8</span>、 <span class="token operator">.</span>linkbutton          生成一个链式按钮。   </code></pre><h3 id="messager-生成一个消息框。"><a href="#messager-生成一个消息框。" class="headerlink" title="messager  生成一个消息框。"></a><strong>messager  生成一个消息框。</strong></h3><pre class=" language-yaml"><code class="language-yaml"> 选项如下：                 1)ok<span class="token punctuation">:</span>显示确定按钮文本。                     2)cancel<span class="token punctuation">:</span>显示取消按钮文本。                 <span class="token key atrule">方法如下</span><span class="token punctuation">:</span>                1)show<span class="token punctuation">:</span>在屏幕的右下角出现一个消息框。该选项参数是一个配置对象，它包括：                    showType<span class="token punctuation">:</span>定义消息框显示的模式，可选值包括<span class="token punctuation">:</span><span class="token null important">null</span><span class="token punctuation">,</span>slide<span class="token punctuation">,</span>fade<span class="token punctuation">,</span>show.默认slide.                   <span class="token key atrule">showSpeed</span><span class="token punctuation">:</span> 定义消息框完成显示的时间。默认600毫秒。                   <span class="token key atrule">width</span><span class="token punctuation">:</span> 定义消息框的宽度。默认250。                    height<span class="token punctuation">:</span>定义消息框的高度。默认100。                    msg<span class="token punctuation">:</span>定义消息框显示的文本。                    <span class="token key atrule">title</span><span class="token punctuation">:</span> 在消息框面板头部显示标题文本。                    <span class="token key atrule">timeout</span><span class="token punctuation">:</span> 如果定义为0<span class="token punctuation">,</span>消息框将不会自动关闭，除非用户手动关闭它。如果定义为非0值，消息框会在超时结束时自动关闭它。单位毫秒。                 <span class="token key atrule">2)alert:显示一个打印窗口。它的参数如下</span><span class="token punctuation">:</span>                    <span class="token key atrule">title</span><span class="token punctuation">:</span> 在头部显示标题文本。                   msg<span class="token punctuation">:</span>显示文本内容。                   <span class="token key atrule">icon</span><span class="token punctuation">:</span> 显示图标。可选值<span class="token punctuation">:</span>error<span class="token punctuation">,</span>question<span class="token punctuation">,</span>info<span class="token punctuation">,</span>warning。                   <span class="token key atrule">fn</span><span class="token punctuation">:</span> 当窗口关闭后触发回调函数。                <span class="token key atrule">3)confirm:显示一个包含确定和取消按钮的确认消息框。参数包括</span><span class="token punctuation">:</span>                    title<span class="token punctuation">:</span>在头部显示标题文本。                   <span class="token key atrule">msg</span><span class="token punctuation">:</span> 显示文本内容。                   fn(b)<span class="token punctuation">:</span>回调函数，当用户点击OK按钮，返回True<span class="token punctuation">,</span>才会处理该函数，其它按钮返回false<span class="token punctuation">,</span>不处理。                <span class="token key atrule">4)prompt:显示一个消息框，包含OK和Cancel按钮并提示用户输入一些文本。参数包括</span><span class="token punctuation">:</span>                   title<span class="token punctuation">:</span>在头部显示标题文本。                   msg<span class="token punctuation">:</span>显示文本内容。                   fn(val)<span class="token punctuation">:</span>该回调函数处理用户输入的参数值。   </code></pre><h3 id="pagination生成一个页码工具条"><a href="#pagination生成一个页码工具条" class="headerlink" title=".pagination生成一个页码工具条"></a><strong>.pagination生成一个页码工具条</strong></h3><pre class=" language-groovy"><code class="language-groovy">属性如下：               <span class="token number">1</span><span class="token punctuation">)</span>total<span class="token punctuation">:</span>当分页条创建后设置的记录数。默认<span class="token number">1</span>。               <span class="token number">2</span><span class="token punctuation">)</span>pageSize<span class="token punctuation">:</span>页面大小。默认<span class="token number">10</span>。               <span class="token number">3</span><span class="token punctuation">)</span>pageNumber<span class="token punctuation">:</span>当分页创建后显示的页码。默认<span class="token number">1</span>。               <span class="token number">4</span><span class="token punctuation">)</span>pageList<span class="token punctuation">:</span>用户能更改页面的大小。您也可以改变该属性定义的默认大小。默认`<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">]</span>`。            <span class="token number">5</span><span class="token punctuation">)</span>loading<span class="token punctuation">:</span>定义是否正在加载。默认<span class="token boolean">false</span>。              <span class="token number">6</span><span class="token punctuation">)</span>buttons<span class="token punctuation">:</span>定义自定义按钮，每个按钮都包含两个属性<span class="token punctuation">:</span>                 iconCls<span class="token punctuation">:</span> 该CSS类将显示一个背景图标。                  handler<span class="token punctuation">:</span> 当按钮点击时触发一个处理函数。               <span class="token number">7</span><span class="token punctuation">)</span>beforePageText<span class="token punctuation">:</span>当输入组件前显示一个标签文本。               <span class="token number">8</span><span class="token punctuation">)</span>afterPageText<span class="token punctuation">:</span>当输入组件后显示一个标签文本。               <span class="token number">9</span><span class="token punctuation">)</span>displayMsg<span class="token punctuation">:</span>显示一个页面信息。             方法如下<span class="token punctuation">:</span>              <span class="token number">1</span><span class="token punctuation">)</span>onSelectPage<span class="token punctuation">:</span>当用户选择一个新页面时激活。该回调函数包括两个参数<span class="token punctuation">:</span>                  pageNumber<span class="token punctuation">:</span> 该新页面的页码。                 pageSize<span class="token punctuation">:</span>该新页面的大小  </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分页</title>
      <link href="/2018/11/22/2018-11-22-%E5%88%86%E9%A1%B5/"/>
      <url>/2018/11/22/2018-11-22-%E5%88%86%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="pageBean的作用"><a href="#pageBean的作用" class="headerlink" title="pageBean的作用"></a><strong>pageBean的作用</strong></h3><p>主要用来存储页面的相关元素的信息</p><pre><code>public String findAll(){        PageBean&lt;Employee&gt; pageBean = employeeService.findByPage(currPage);        // 将pageBean存入栈中，以便于页面上通过struts标签来获取值        ActionContext.getContext().getValueStack().push(pageBean);        return &quot;findAll&quot;;    }</code></pre><pre><code>    public List&lt;Employee&gt; findByPage(int begin, int pageSize) {        DetachedCriteria criteria = DetachedCriteria.forClass(Employee.class);        @SuppressWarnings(&quot;unchecked&quot;)        List&lt;Employee&gt; list = (List&lt;Employee&gt;) hibernateTemplate.findByCriteria(criteria, begin,pageSize);        return list;    }</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dao向resultMap传值</title>
      <link href="/2018/11/22/2018-11-22-dao%E5%90%91resultMap%E4%BC%A0%E5%80%BC/"/>
      <url>/2018/11/22/2018-11-22-dao%E5%90%91resultMap%E4%BC%A0%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="对应实体的各种属性"><a href="#对应实体的各种属性" class="headerlink" title="对应实体的各种属性"></a><strong>对应实体的各种属性</strong></h3><pre><code>    &lt;resultMap type=&quot;Article&quot; id=&quot;ArticleResult&quot;&gt;        &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt;        &lt;result property=&quot;articleTitle&quot; column=&quot;article_title&quot;/&gt;        &lt;result property=&quot;articleCreateDate&quot; column=&quot;article_create_date&quot;/&gt;        &lt;result property=&quot;articleContent&quot; column=&quot;article_content&quot;/&gt;        &lt;result property=&quot;isTop&quot; column=&quot;is_top&quot;/&gt;        &lt;result property=&quot;addName&quot; column=&quot;add_name&quot;/&gt;    &lt;/resultMap&gt;</code></pre><p>传入的参数是Map Mybatis会自动解析Map里的字段</p><pre><code>&lt;select id=&quot;findArticles&quot; parameterType=&quot;Map&quot; resultMap=&quot;ArticleResult&quot;&gt;        select id,article_title,article_create_date,article_content,add_name from ssm_article        &lt;where&gt;            &lt;if test=&quot;articleTitle!=null and articleTitle!=&#39;&#39; &quot;&gt;                and article_title like #{articleTitle}            &lt;/if&gt;        &lt;/where&gt;        &lt;if test=&quot;start!=null and size!=null&quot;&gt;            limit #{start},#{size}        &lt;/if&gt;    &lt;/select&gt;</code></pre><h3 id="Mapper文件参数获取的方式"><a href="#Mapper文件参数获取的方式" class="headerlink" title="Mapper文件参数获取的方式"></a><strong>Mapper文件参数获取的方式</strong></h3><p>参数个数为1个（string或者int）<br>dao层方法为以下两种<br>单个int型  </p><pre><code>public List&lt;UserComment&gt; findByDepartmentId(int dapartmentId);</code></pre><p>单个string型  </p><pre><code>public Source findByTitle(String title);</code></pre><p><strong>对应的Mapper取值：</strong><br>取值时应当注意，参数名字应该与dao层传入的参数名字相同。<br><strong>单个int型</strong></p><pre><code>&lt;select id=&quot;findByDepartmentId&quot;  resultType=&quot;com.bonc.wechat.entity.publicserver.UserComment&quot;&gt;    select * from wx_user_comment where     department_id=#{departmentId}     order by createtime desc;&lt;/select&gt;</code></pre><p><strong>单个string型</strong>  </p><pre><code>&lt;select id=&quot;findByTitle&quot;  parameterType=&quot;java.lang.String&quot; resultType=&quot;com.bonc.wechat.entity.publicserver.Source&quot;&gt;    select * from wx_source where         title=#{title};&lt;/select&gt;</code></pre><p>2、参数个数为多个。<br>dao层方法：<br>1.正常传参</p><pre><code>public Dailyuserinfo findStutaByUserAndDaily(String username,String dailyid);</code></pre><p>2.注解传参  </p><pre><code>public List&lt;UserTab&gt; selectUserListExceptUserId(@Param(&quot;USER_ID&quot;)String USER_ID,  @Param(&quot;LIMIT_POS&quot;)int LIMIT_POS,  @Param(&quot;LIMIT_SIZE&quot;)int LIMIT_SIZE);</code></pre><p>对应的Mapper取值：<br>取值时应当注意，参数名字应该与dao层传入的参数名字相同。</p><h3 id="正常传参方式参数获取"><a href="#正常传参方式参数获取" class="headerlink" title="正常传参方式参数获取"></a>正常传参方式参数获取</h3><pre><code>&lt;select id=&quot;findStutaByUserAndDaily&quot;           parameterType=&quot;java.lang.String&quot;            resultType=&quot;com.thinkgem.jeesite.modules.dailynews.entity.Dailyuserinfo&quot;&gt;    select * from daily_user_info     where login_name=#{username}     And daily_id=#{dailyid};&lt;/select&gt;</code></pre><h3 id="注解传参方式参数获取"><a href="#注解传参方式参数获取" class="headerlink" title="注解传参方式参数获取"></a>注解传参方式参数获取</h3><pre><code>&lt;select id=&quot;selectUserListExceptUserId&quot;             resultMap=&quot;userResMap&quot;&gt;    select * from MH_USER         where USER_ID!=#{USER_ID}         and USER_STATE&gt;9         order by NICK_NAME         limit #{LIMIT_POS},#{LIMIT_SIZE}&lt;/select&gt;</code></pre><h3 id="3、参数为map的形式"><a href="#3、参数为map的形式" class="headerlink" title="3、参数为map的形式"></a>3、参数为map的形式</h3><p>mapper中使用map的key取值<br>dao中的方法  </p><h3 id="1-参数为map"><a href="#1-参数为map" class="headerlink" title="1.参数为map"></a>1.参数为map</h3><pre><code>public List&lt;Source&gt; search(Map&lt;String,Object&gt; param);</code></pre><h3 id="2-map的内部封装"><a href="#2-map的内部封装" class="headerlink" title="2.map的内部封装"></a>2.map的内部封装</h3><pre><code> Map&lt;String,Object&gt; param=new HashMap&lt;String,Object&gt;();    param.put(&quot;page&quot;, (page-1)*pageSize);    param.put(&quot;pageSize&quot;,pageSize);    param.put(&quot;keyword&quot;,&quot;%&quot;+keyword+&quot;%&quot;);    param.put(&quot;type&quot;,type);    List&lt;Source&gt; sources=sourceDao.search(param);</code></pre><h3 id="对应的Mapper取值"><a href="#对应的Mapper取值" class="headerlink" title="对应的Mapper取值"></a><strong>对应的Mapper取值</strong></h3><pre><code>&lt;select id=&quot;search&quot;             parameterType=&quot;java.util.Map&quot;             resultType=&quot;com.bonc.wechat.entity.publicserver.Source&quot;&gt;    select * from wx_source         where      &lt;if test=&quot;keyword != null and keyword != &#39;&#39;&quot;&gt;        (title like #{keyword} or content like #{keyword}) and         &lt;/if&gt;          type=#{type}      order by ordernum asc           limit #{page},#{pageSize};&lt;/select&gt;</code></pre><h2 id="参数为对象"><a href="#参数为对象" class="headerlink" title="参数为对象"></a><strong>参数为对象</strong></h2><p>mapper中使用对象中的属性直接取值，或者【对象.属性】取值。<br>dao中的方法  </p><h3 id="使用对象传参"><a href="#使用对象传参" class="headerlink" title="使用对象传参"></a><strong>使用对象传参</strong></h3><pre><code>public int addUserComment(UserComment UC);</code></pre><p><strong>对象中的属性</strong>  </p><pre><code>private int id;    private int department_id;            private String telphone;            private String content;                private String createtime; </code></pre><h3 id="对应的Mapper取值："><a href="#对应的Mapper取值：" class="headerlink" title="对应的Mapper取值："></a><strong>对应的Mapper取值：</strong></h3><pre><code>&lt;insert id=&quot;addUserComment&quot;             parameterType=&quot;com.bonc.wechat.entity.publicserver.UserComment&quot;&gt;    insert into wx_user_comment                   (department_id,                    telphone,                    content,                    createtime)     values(#{department_id},                   #{telphone},                   #{content},                   #{createtime});&lt;/insert&gt;</code></pre><h3 id="使用【对象-属性】取值"><a href="#使用【对象-属性】取值" class="headerlink" title="使用【对象.属性】取值"></a><strong>使用【对象.属性】取值</strong></h3><p><strong>dao层：</strong><br><strong>**</strong>此示例中直接省去dao层，service直接绑定mapper层<strong>**</strong></p><pre><code>public PageResult findPanoramaPage(Page page) throws Exception{    List&lt;PageData&gt; panoramaList = new ArrayList&lt;PageData&gt;();    try {    panoramaList = (List&lt;PageData&gt;)dao.findForList(&quot;PanoramaMapper.findPagePanorama&quot;, page);    } catch (Exception e) {        e.printStackTrace();        }    PageResult pageResult = new PageResult(page.getTotalResult(),panoramaList);    return pageResult;}</code></pre><p><strong>对应的Mapper取值：</strong></p><pre><code>&lt;select id=&quot;findPagePanorama&quot;             parameterType=&quot;page&quot;             resultType=&quot;pd&quot;&gt;    SELECT         a.id as id,        a.project_code as projectCode,        a.project_name as projectName,        a.project_addr as projectAddr,        a.project_type as projectType    FROM         calm_project a     WHERE         a.is_valid=1        &lt;if test=&quot;page.projectType != null and page.projectType != &#39;&#39;&quot;&gt;        AND a.project_type = #{page.projectType}         &lt;/if&gt;    &lt;if test=&quot;page.keyword != null and page.keyword != &#39;&#39;&quot;&gt;       AND (a.project_name LIKE &#39;%${page.keyword}%&#39; OR a.project_code LIKE &#39;%${page.keyword}%&#39;)        &lt;/if&gt;        ORDER BY              a.sort&lt;/select&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sql----Limit</title>
      <link href="/2018/11/21/2018-11-21-limit/"/>
      <url>/2018/11/21/2018-11-21-limit/</url>
      
        <content type="html"><![CDATA[<p>在数据库中很多地方都会用到，比如当你数据库查询记录有几万、几十万时使用limit查询效率非常快，只需要查询出你需要的数据就可以了·再也不用全表查询导致查询数据库崩溃的情况。<br>select <em> from Customer LIMIT 10;–检索前10行数据，显示1-10条数据<br>select </em> from Customer LIMIT 1,10;–检索从第2行开始，累加10条id记录，共显示id为2….11<br>select <em> from Customer limit 5,10;–检索从第6行开始向前加10条数据，共显示id为6,7….15<br>select </em> from Customer limit 6,10;–检索从第7行开始向前加10条记录，显示id为7,8…16  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis----CDATA部件</title>
      <link href="/2018/11/21/2018-11-21-CDATA%E9%83%A8%E4%BB%B6/"/>
      <url>/2018/11/21/2018-11-21-CDATA%E9%83%A8%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>在使用mybatis 时我们sql是写在xml 映射文件中，如果写的sql中有一些特殊的字符的话，在解析xml文件的时候会被转义，但我们不希望他被转义，所以我们要使用<code>&lt;![CDATA[ ]]&gt;</code>来解决。<br><code>&lt;![CDATA[   ]]&gt;</code> 是什么：这是XML语法。在CDATA内部的所有内容都会被解析器忽略。<br>如果文本包含了很多的”&lt;”字符 &lt;=和”&amp;”字符——就象程序代码一样，那么最好把他们都放到CDATA部件中。<br>但是有个问题那就是<code>&lt;if test=&quot;&quot;&gt;   &lt;/if&gt;   &lt;where&gt;   &lt;/where&gt;  &lt;choose&gt;  &lt;/choose&gt;  &lt;trim&gt;  &lt;/trim&gt;</code>等这些标签都不会被解析，所以我们只把有特殊字符的语句放在 <code>&lt;![CDATA[   ]]&gt;</code>  尽量缩小 <code>&lt;![CDATA[  ]]&gt;</code> 的范围。<br>实例如下：</p><pre><code>&lt;select id=&quot;allUserInfo&quot; parameterType=&quot;java.util.HashMap&quot; resultMap=&quot;userInfo1&quot;&gt;  &lt;![CDATA[  SELECT newsEdit,newsId, newstitle FROM shoppingGuide  WHERE 1=1  AND  newsday &gt; #{startTime} AND newsday &lt;= #{endTime}  ]]&gt;  &lt;if test=&quot;etidName!=&#39;&#39;&quot;&gt;   AND newsEdit=#{etidName}  &lt;/if&gt; &lt;/select&gt;</code></pre><p>因为这里有 “&gt;”  “&lt;=” 特殊字符所以要使用 <code>&lt;![CDATA[   ]]&gt;</code>来注释，但是有<code>&lt;if&gt;</code>标签，所以把<code>&lt;if&gt;</code>等 放外面</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统JDK的配置</title>
      <link href="/2018/11/20/2018-11-20-%20Linux%E7%B3%BB%E7%BB%9FJDK%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/11/20/2018-11-20-%20Linux%E7%B3%BB%E7%BB%9FJDK%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>①解压JDK的压缩包<br>cd /simple<br>tar -zxvf /simple/soft/jdk-7u79-linux-x64.tar.gz -C /simple/<br>②配置JDK环境变量<br>修改profile文件即可<br>vim /etc/profile<br>加入以下内容<br>JAVA_HOME=/simple/jdk1.7.0_79<br>export PATH=$JAVA_HOME/bin:$PATH<br><img src="https://viabcde.github.io/images/201812/13.png" alt="enter descriptionhere"><br>注意：编辑完成后要刷新配置才能生效  source /etc/profile<br>创建Hello.java文件：touch Hello.java<br>打开编辑文件：vim Hello.java<br>编译和运行与在windows上操作一样  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH免密登录</title>
      <link href="/2018/11/20/2018-11-20-SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
      <url>/2018/11/20/2018-11-20-SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>A发送原始字符串–B公钥加密返回—A私钥解密—A发送字符串<br>B前后字符串比较一致则true  B的公钥是A给的<br>①生产ssh免密登录的密钥<br>ce ~/.ssh<br>ssh-keygen -t rsa 4个回车即可生成<br>②将公钥copy到免密登录的机器（这里copy到自己的机器）<br>ssh-cpoy-id simple02<br><img src="https://viabcde.github.io/images/201812/19.png" alt="enter descriptionhere"><br>③首次登录远程主机<br>ssh simple02<br>第一次需要密码，以后都不用密码</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop伪分布式配置与测试</title>
      <link href="/2018/11/20/2018-11-20-Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/11/20/2018-11-20-Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>①解压Hadoop的压缩包<br>cd /simple<br>tar -zxvf /simple/soft/hadoop-2.4.1.tar.gz -C /simple/<br>②为hadoop配置好jdk<br>cd /simple/hadoop-2.4.1/etc/hadoop/<br>vi hadoop-env.sh<br>增加内容如下<br>export JAVA_HOME=/simple/jdk1.7.0_79<br><img src="https://viabcde.github.io/images/201812/14.png" alt="enter descriptionhere"><br>③指定hdfs的缺省名称及缺省路径地址和运行时产生文件的存储目录<br>只需要hadoop目录下的core-site.xml文件即可</p><pre><code>&lt;!--缺省名称--&gt;&lt;property&gt;    &lt;name&gt;fs.default.name&lt;/name&gt;    &lt;value&gt;hdfs://192.168.1.2:90000&lt;/value&gt;&lt;/property&gt;&lt;!--缺省路径地址--&gt;&lt;property&gt;    &lt;name&gt;fs.defaultFS&lt;/name&gt;    &lt;value&gt;hdfs://192.168.1.2:90000&lt;/value&gt;&lt;/property&gt;&lt;!--运行时文件存储目录--&gt;&lt;property&gt;    &lt;name&gt;fs.tmp.dir&lt;/name&gt;    &lt;value&gt;/simple/hadoop-2.4.1/tmp&lt;/value&gt;&lt;/property&gt;</code></pre><p>④制定HDFS副本的数量，名称和数据的存储路径<br>只需要修改hadoop目录下的hdfs-site.xml文件即可</p><pre><code>&lt;!-- 副本数量--&gt;&lt;property&gt;    &lt;name&gt;dfs.replication&lt;/name&gt;    &lt;value&gt;1&lt;/value&gt;&lt;/property&gt;&lt;!-- 副本数量--&gt;&lt;!-- 副本名称存储路径--&gt;&lt;property&gt;    &lt;name&gt;dfs.name.dir&lt;/name&gt;    &lt;value&gt;/simple/hadoop-2.4.1/hdfs/name&lt;/value&gt;&lt;/property&gt;&lt;!-- 副本数据存储路径--&gt;&lt;property&gt;    &lt;name&gt;dfs.data.dir&lt;/name&gt;    &lt;value&gt;/simple/hadoop-2.4.1/hdfs/data&lt;/value&gt;&lt;/property&gt;</code></pre><p>⑤修改文件名称并指定mapred运行在yarn上<br>mv mapred-site.xml.template mapred-site.xml<br>vi mapred.xml修改如下  </p><pre><code>&lt;!-- 指定mr运行在yarn上--&gt;&lt;property&gt;    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;    &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt;</code></pre><p>⑥指定yarn的老大（ResourceManager）的地址 和reducer获取数据的方式<br>修改yarn-site.xml文件即可<br>vi yarn-site.xml  </p><pre><code>&lt;!-- 指定ResourceManager的地址--&gt;&lt;property&gt;    &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;    &lt;value&gt;192.168.1.2&lt;/value&gt;&lt;/property&gt;&lt;!-- reducer获取数据的方式--&gt;&lt;property&gt;    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;</code></pre><p>最后，为hadoop配置环境变量<br>修改profile文件即可<br>vi /etc/profile 修改如下<br>HADOOP_HOME=/simple/hadoop-2.4.1<br>export PATH=$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH<br><img src="https://viabcde.github.io/images/201812/15.png" alt="enter descriptionhere"><br>更新配置文件即可生效  source /etc/profile  </p><h3 id="格式化namenode"><a href="#格式化namenode" class="headerlink" title="格式化namenode"></a>格式化namenode</h3><p>hdfs namenode -format<br>或者<br>hadoop namenode -format  </p><h3 id="启动hadoop"><a href="#启动hadoop" class="headerlink" title="启动hadoop"></a>启动hadoop</h3><p>start-dfs.sh  </p><h3 id="启动yarn"><a href="#启动yarn" class="headerlink" title="启动yarn"></a>启动yarn</h3><p>start-yarn.sh</p><h3 id="查看以上是否正常启动"><a href="#查看以上是否正常启动" class="headerlink" title="查看以上是否正常启动"></a>查看以上是否正常启动</h3><p>jps 非正常则stop-all.sh然后重新启动  —–jps jvm process status<br><img src="https://viabcde.github.io/images/201812/16.png" alt="enter descriptionhere">      </p><h3 id="测试hdfs和yarn"><a href="#测试hdfs和yarn" class="headerlink" title="测试hdfs和yarn"></a>测试hdfs和yarn</h3><p><img src="https://viabcde.github.io/images/201812/17.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/201812/18.png" alt="enter descriptionhere">      </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop-修改Linux的ip地址</title>
      <link href="/2018/11/19/2018-11-19-Hadoop-%E4%BF%AE%E6%94%B9Linux%E7%9A%84ip%E5%9C%B0%E5%9D%80/"/>
      <url>/2018/11/19/2018-11-19-Hadoop-%E4%BF%AE%E6%94%B9Linux%E7%9A%84ip%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<p>修改ifcfg-eth0文件即可<br>该文件路径：/etc/sysconfig/network-scripts/ifcfg-eth0  </p><h3 id="方法一：图形化设置IP"><a href="#方法一：图形化设置IP" class="headerlink" title="方法一：图形化设置IP"></a><strong>方法一：图形化设置IP</strong></h3><p>①auto eth0代表第一张物理网卡，如果是eth1就代表第二张网卡<br>点击并编辑它<br><img src="https://viabcde.github.io/images/201812/1.png" alt="enter descriptionhere"><br>②修改IPv4的设置 method（网卡配置方式选择manual即手动配置的意思）<br>添加IP192.168.0.202  子网掩码：255.255.255.0 网关：192.168.0.1<br><img src="https://viabcde.github.io/images/201812/2.png" alt="enter descriptionhere"><br>IP地址分为网络号和主机号2个域的原因：IP数据包在网络传输时，是基于网络而非基于主机，这样即简化了路由表，有能快速定位目标主机所在网络<br>子网掩码的作用：外部网络号通过与子网掩码进行与运算，可以判断与本机网络号是否处于同一个网络<br>网关：192.168.0.1 外部的网络IP<br>本机IP:192.168.0.202,即192.168.0.1的子网，该子网内的主机IP通过与子网掩码与运算来判断是否可以直接相连<br><img src="https://viabcde.github.io/images/201812/3.png" alt="enter descriptionhere"> </p><h3 id="方法二：修改配置文件方式设置IP"><a href="#方法二：修改配置文件方式设置IP" class="headerlink" title="方法二：修改配置文件方式设置IP"></a><strong>方法二：修改配置文件方式设置IP</strong></h3><p>打开终端<br><img src="https://viabcde.github.io/images/201812/4.png" alt="enter descriptionhere"><br>cd /etc/sysconfig/network-scripts<br><img src="https://viabcde.github.io/images/201812/5.png" alt="enter descriptionhere"><br>vim ifcfg-eth0<br><img src="https://viabcde.github.io/images/201812/6.png" alt="enter descriptionhere"><br>修改hwaddr(硬件物理地址)<br>ipaddr(IP地址)<br>netmask(子网掩码)<br>gateway(网关)<br><img src="https://viabcde.github.io/images/201812/7.png" alt="enter descriptionhere"> </p><h3 id="查看配置结果"><a href="#查看配置结果" class="headerlink" title="查看配置结果"></a><strong>查看配置结果</strong></h3><p>ifconfig<br><img src="https://viabcde.github.io/images/201812/8.png" alt="enter descriptionhere"> </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行器Executor</title>
      <link href="/2018/11/19/2018-11-19-%E6%89%A7%E8%A1%8C%E5%99%A8/"/>
      <url>/2018/11/19/2018-11-19-%E6%89%A7%E8%A1%8C%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>作用：调度StatementHandler、ParameterHandler、ResultHandler等来执行对应的SQL。  </p><h3 id="SimpleExecutor"><a href="#SimpleExecutor" class="headerlink" title="SimpleExecutor"></a><strong>SimpleExecutor</strong></h3><p>每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。  </p><h3 id="ReuseExecutor"><a href="#ReuseExecutor" class="headerlink" title="ReuseExecutor"></a><strong>ReuseExecutor</strong></h3><p>执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。   </p><h3 id="BatchExecutor"><a href="#BatchExecutor" class="headerlink" title="BatchExecutor"></a><strong>BatchExecutor</strong></h3><p>执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。<br><strong>作用范围</strong>在SqlSession生命周期范围。</p><p>执行过程：步骤一，MyBatis根据Configuration来构建StatementHandler<br>                  步骤二，使用prepareStatement方法，对SQL编译并对参数进行初始化<br>                  步骤三，调用prepareStatement的prepare()进行预编译和基础设置，再通过StatementHandler的parameterize()来设置参数并执行<br>                  步骤四，resultHandler再组装查询结果返回给调用者。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态SQL</title>
      <link href="/2018/11/19/2018-11-19-%E5%8A%A8%E6%80%81SQL/"/>
      <url>/2018/11/19/2018-11-19-%E5%8A%A8%E6%80%81SQL/</url>
      
        <content type="html"><![CDATA[<h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a><strong>动态SQL</strong></h2><p>动态SQL是在原先SQL基础上加上判断条件，例如if等语句<br><img src="https://viabcde.github.io/images/2018-10-10/2018101029.png" alt="enter descriptionhere"> </p><h3 id="if元素"><a href="#if元素" class="headerlink" title="if元素"></a><strong>if元素</strong></h3><p> <strong>示例：根据角色名称模糊匹配查询角色</strong>  </p><pre><code>       &lt;select id=&quot;findRoles&quot; parameterType=&quot;string&quot; resultMap=&quot;roleResultMap&quot;&gt;    select role_no, role_name, note from t_role where 1 = 1    &lt;if test=&quot;roleName !=null and roleName !=&#39;&#39; &quot;&gt;        and role_name like concat(&#39;%&#39;, #{roleName}, &#39;%&#39;)    &lt;/if&gt;&lt;/select&gt;</code></pre><h3 id="choose、when、otherwise元素"><a href="#choose、when、otherwise元素" class="headerlink" title="choose、when、otherwise元素"></a><strong>choose、when、otherwise元素</strong></h3><p><strong>判断条件结果不只是true或false，类似于java语言中的switch——case语句</strong></p><p>示例：当role编号为空，使用roleNo为条件查询；当role编号为空，而角色名称roleName不为空，则roleName作为条件进行模糊查询；若俩者都为空，要求备注不为空。三种查询情况，来看mybatis动态sql语句如何实现？</p><pre><code>&lt;select id=&quot;findRoles&quot; parameterType=&quot;string&quot; resultMap=&quot;roleResultMap&quot;&gt;    select role_no, role_name, note from t_role where 1 = 1    &lt;choose&gt;        &lt;when test=&quot;testNO != null and roleNo !=&#39;&#39; &quot;&gt;            and role_no = #{roleNo}        &lt;/when&gt;        &lt;when test=&quot;roleName !=null and roleName !=&#39;&#39; &quot;&gt;            and role_name like concat(&#39;%&#39;, {roleName}, &#39;%&#39;)        &lt;/when&gt;        &lt;otherwise&gt;            and note is not null        &lt;/otherwise&gt;    &lt;/choose&gt;&lt;/select&gt;</code></pre><h3 id="trim、where、set元素"><a href="#trim、where、set元素" class="headerlink" title="trim、where、set元素"></a><strong>trim、where、set元素</strong></h3><p><strong>where</strong><br>如果将if元素示例中的1=1去掉，SQL的语法就会异常，这时我们就可以用where元素起到同等作用。</p><pre><code>&lt;select id=&quot;findRoles&quot; parameterType=&quot;string&quot; resultMap=&quot;roleResultMap&quot;&gt;    select role_no, role_name, note from t_role         &lt;where&gt;        &lt;if test=&quot;roleName !=null and roleName !=&#39;&#39; &quot;&gt;            and role_name like concat(&#39;%&#39;, {roleName}, &#39;%&#39;)        &lt;/if&gt;        &lt;/where&gt;    &lt;/choose&gt;&lt;/select&gt;</code></pre><p><strong>trim</strong></p><pre><code>&lt;select id=&quot;findRoles&quot; parameterType=&quot;string&quot; resultMap=&quot;roleResultMap&quot;&gt;    select role_no, role_name, note from t_role         &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and&quot;&gt;            &lt;if test=&quot;roleName !=null and roleName !=&#39;&#39; &quot;&gt;            and role_name like concat(&#39;%&#39;, {roleName}, &#39;%&#39;)            &lt;/if&gt;        &lt;/trim&gt;&lt;/select&gt;</code></pre><p>trim元素用来去掉一些特殊的字符串，prefix代表是语句的前缀，而prefixOverrides代表你需要去掉的字符串，本实例中trim与where元素起到同样的效果。<br><strong>set</strong><br>使用场景：更新一条记录的一个字段，性能最佳的办法是把主键和更新字段的值传给sql进行更新。mybatis通过set来设置这样的更新操作，具体示例如下：    </p><pre><code>&lt;update id=&quot;updateRole&quot; parameterType=&quot;role&quot;&gt;    update t_role    &lt;set&gt;        &lt;if test=&quot;roleName != null and roleName !=&#39;&#39;&quot;&gt;            role_name = #{roleName},        &lt;/if&gt;        &lt;if test=&quot;note != null and note !=&#39;&#39; &quot;&gt;            note = #{note}        &lt;/if&gt;    &lt;/set&gt;    where role_no = #{roleNo}&lt;/update&gt;</code></pre><p><strong>foreach元素</strong><br>循环语句，用来遍历集合。能够很好的支持数组和List、Set接口的集合，对此提供遍历的功能</p><pre><code>&lt;select id=&quot;findUserBySex&quot; resultType=&quot;user&quot;&gt;    select * from t_user where sex in    &lt;foreach item=&quot;sex&quot; index=&quot;index&quot; collection=&quot;sexList&quot; open=&quot;(&quot;separator=&quot;,&quot; close=&quot;)&quot;&gt;        #{sex}    &lt;/foreach&gt;&lt;/select&gt;</code></pre><p>collection配置的sexList是传递进来的参数名称，可以是一个数组或List、Set等集合；item配置的是循环中当前的元素；index配置的是当前元素在集合的位置下标；open和close配置的是以什么符号将这些集合元素包装起来；separator是各个元素的间隔符。值得注意的是，sql中大量语句的in是非常消耗性能的，所以我们要预估一下collection对象的长度。<br> <strong>test属性</strong><br> 用于条件判断语句中，相当于判断真假，上面的示例基本是用它判断空和非空，我们还可以用它来判断字符串、数字和枚举等。</p><pre><code>&lt;select id=&quot;getRoleTest&quot; parameterType=&quot;string&quot; resultMap=&quot;roleResultMap&quot;&gt;    select role_no, role_name, note from t_role     &lt;if test=&quot;type = &#39;Y&#39;&quot;&gt;        where 1=1    &lt;/if&gt;&lt;/select&gt;</code></pre><p><strong>bind元素</strong><br>通过OGNL表达式自定义一个上下文变量。例如模糊查询，mysql使用一个concat用“%”和参数相连接，然而oracle则是用连接符号“||”，这样就很难兼容，需要俩种形式。这样情况下，mybatis提供了bind元素，不必使用数据库的语言，只要使用mybatis的语言即可与所需参数相连，实现模糊查询。  </p><h3 id="1-使用bind绑定一个参数"><a href="#1-使用bind绑定一个参数" class="headerlink" title="1 使用bind绑定一个参数"></a><strong>1 使用bind绑定一个参数</strong></h3><pre><code>&lt;select id=&quot;findRole&quot; resultType=&quot;com.liming.domain.mybatis.bean.RoleBean&quot;&gt;    &lt;bind name=&quot;pattern&quot; value=&quot;&#39;%&#39; + _parameter + &#39;%&#39;&quot;/&gt;    select id, role_name as roleName, create_date as createDate, end_date as endDate From t_role    where role_name like #{pattern}&lt;/select&gt;</code></pre><h3 id="2-多参数绑定"><a href="#2-多参数绑定" class="headerlink" title="2  多参数绑定"></a><strong>2  多参数绑定</strong></h3><p><strong>（1）定义接口方法</strong></p><pre><code>/*  * 查询角色  * @param roleName 角色名称  * @param note 备注  * @return 符合条件的角色 */public List&lt;RoleBean&gt; findRole(@Param(&quot;roleName&quot;)String roleName, @Param(&quot;note&quot;)String note);</code></pre><p><strong>（2）定义映射文件，定义俩个新的变量执行模糊查询</strong></p><pre><code>&lt;select id=&quot;findRole&quot; resultType=&quot;com.liming.domain.mybatis.bean.RoleBean&quot;&gt;    &lt;bind name=&quot;pattern_roleName&quot; value=&quot;&#39;%&#39; + roleName + &#39;%&#39;&quot;/&gt;    &lt;bind name=&quot;pattern_note&quot; value =&quot;&#39;%&#39; + note + &#39;%&#39;&quot;/&gt;    select id, role_name as roleName, create_date as createDate, end_date as endDate from t_role    where role_name like #{pattern_roleName}    and note like #{pattern_note}&lt;/select&gt;</code></pre><p><strong>总结</strong><br>            mybatis通过条件判断的元素实现动态SQL语句查询功能，相对于静态的sql语句更加灵活，更全面满足开发人员的需求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改主机名和映射关系</title>
      <link href="/2018/11/19/2018-11-19-%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D%E5%92%8C%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2018/11/19/2018-11-19-%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D%E5%92%8C%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="通过计算机名映射到IP地址"><a href="#通过计算机名映射到IP地址" class="headerlink" title="通过计算机名映射到IP地址"></a><strong>通过计算机名映射到IP地址</strong></h3><p>修改主机名，只需要修改network文件即可<br>①<strong>打开终端</strong><br>右键，open in terminal<br>cd /etc/sysconfig  vim network<br><img src="https://viabcde.github.io/images/201812/9.png" alt="enter descriptionhere"><br>②修改内容如下<br><img src="https://viabcde.github.io/images/201812/10.png" alt="enter descriptionhere"><br>修改映射关系，只需要修改host文件即可<br>vim /etc/hosts 修改如下<br><img src="https://viabcde.github.io/images/201812/11.png" alt="enter descriptionhere"><br><strong>注意：重启才能生效</strong><br><img src="https://viabcde.github.io/images/201812/12.png" alt="enter descriptionhere"> </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Discriminator鉴别器</title>
      <link href="/2018/11/19/2018-11-19-discriminator%E9%89%B4%E5%88%AB%E5%99%A8/"/>
      <url>/2018/11/19/2018-11-19-discriminator%E9%89%B4%E5%88%AB%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>discriminator鉴别器（一）</strong><br>有时一个单独的数据库查询也许返回很多不同（但是希望有些关联）数据类型的结果集。<br>鉴别器元素就是被设计来处理这个情况的，还有包括类的继承层次结构。鉴别器非常容易理<br>解，它很像 Java的 switch<br>定义鉴别器指定了 column 和 javaType 属性<br>列是 MyBatis 查找比较值的地方<br>JavaType是需要被用来保证等价测试的合适类型（尽管字符串在很多情形下都会有用）。比如：</p><pre><code>&lt;resultMap id=&quot;vehicleResult&quot; type=&quot;Vehicle&quot;&gt;  &lt;id property=”id” column=&quot;id&quot; /&gt;  &lt;result property=&quot;vin&quot; column=&quot;vin&quot;/&gt;  &lt;result property=&quot;year&quot; column=&quot;year&quot;/&gt;  &lt;result property=&quot;make&quot; column=&quot;make&quot;/&gt;  &lt;result property=&quot;model&quot; column=&quot;model&quot;/&gt;  &lt;result property=&quot;color&quot; column=&quot;color&quot;/&gt;  &lt;discriminator javaType=&quot;int&quot; column=&quot;vehicle_type&quot;&gt;    &lt;case value=&quot;1&quot; resultMap=&quot;carResult&quot;/&gt;    &lt;case value=&quot;2&quot; resultMap=&quot;truckResult&quot;/&gt;    &lt;case value=&quot;3&quot; resultMap=&quot;vanResult&quot;/&gt;    &lt;case value=&quot;4&quot; resultMap=&quot;suvResult&quot;/&gt;  &lt;/discriminator&gt;&lt;/resultMap&gt;&lt;resultMap id=&quot;carResult&quot; type=&quot;Car&quot;&gt;  &lt;result property=&quot;doorCount&quot; column=&quot;door_count&quot; /&gt;&lt;/resultMap&gt;</code></pre><p>这个例子中，如果vehicle_type的值是1，则会使用carResult，即只加载doorCount属性，如果需要加载vehicleResult中的属性，则需要让carResult继承vehicleResult，使用如下：</p><pre><code>&lt;resultMap id=&quot;carResult&quot; type=&quot;Car&quot; extends=”vehicleResult”&gt;  &lt;result property=”doorCount” column=&quot;door_count&quot; /&gt;&lt;/resultMap&gt;</code></pre><p><strong>discriminator鉴别器（二）</strong>  </p><p>还有一种方式可以实现上面的效果：</p><pre><code>&lt;resultMap id=&quot;vehicleResult&quot; type=&quot;Vehicle&quot;&gt;  &lt;id property=”id” column=&quot;id&quot; /&gt;  &lt;result property=&quot;vin&quot; column=&quot;vin&quot;/&gt;  &lt;result property=&quot;year&quot; column=&quot;year&quot;/&gt;  &lt;result property=&quot;make&quot; column=&quot;make&quot;/&gt;  &lt;result property=&quot;model&quot; column=&quot;model&quot;/&gt;  &lt;result property=&quot;color&quot; column=&quot;color&quot;/&gt;  &lt;discriminator javaType=&quot;int&quot; column=&quot;vehicle_type&quot;&gt;    &lt;case value=&quot;1&quot; resultType=&quot;carResult&quot;&gt;      &lt;result property=”doorCount” column=&quot;door_count&quot; /&gt;    &lt;/case&gt;    &lt;case value=&quot;2&quot; resultType=&quot;truckResult&quot;&gt;      &lt;result property=”boxSize” column=&quot;box_size&quot; /&gt;      &lt;result property=”extendedCab” column=&quot;extended_cab&quot; /&gt;    &lt;/case&gt;    &lt;case value=&quot;3&quot; resultType=&quot;vanResult&quot;&gt;      &lt;result property=”powerSlidingDoor” column=&quot;power_sliding_door&quot; /&gt;    &lt;/case&gt;    &lt;case value=&quot;4&quot; resultType=&quot;suvResult&quot;&gt;      &lt;result property=”allWheelDrive” column=&quot;all_wheel_drive&quot; /&gt;    &lt;/case&gt;  &lt;/discriminator&gt;&lt;/resultMap&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SqlSessionFactoryBuilder、SqlSessionFactory、SqlSession、数据库会话器</title>
      <link href="/2018/11/19/2018-11-19-SqlSessionFactoryBuilder/"/>
      <url>/2018/11/19/2018-11-19-SqlSessionFactoryBuilder/</url>
      
        <content type="html"><![CDATA[<h3 id="SqlSessionFactoryBuilder（构造器）"><a href="#SqlSessionFactoryBuilder（构造器）" class="headerlink" title="SqlSessionFactoryBuilder（构造器）"></a><strong>SqlSessionFactoryBuilder（构造器）</strong></h3><p><strong>用处：</strong>根据配置信息或者代码来生成SqlSessionFactory<br>该类有多个重载方法build()。如下图：<br><img src="https://viabcde.github.io/images/2018-10-10/2018101026.png" alt="enter descriptionhere"><br><strong>SqlSessionFactoryBuilder真正重载build方法只有如下三种：</strong><br>分别是InputStream（字节流）、Reader（字符流）、Configuration（类）<br><strong>字节流和字符流</strong>通过读取XML文件创建SqlSessionFactory    </p><pre><code>public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) </code></pre><pre><code>public SqlSessionFactory build(Reader reader, String environment, Properties properties)</code></pre><p><strong>Configuration</strong>是java代码方式创建SqlSessionFactory  </p><pre><code>public SqlSessionFactory build(Configuration config)</code></pre><p>最后一种读取xml构造SqlSessionFactory，构造过程中注入了configuration的实例对象，之后configuration实例对象解析XML文件来构建SqlSessionFactory，示例代码</p><pre><code>String resource = &quot;mybatis-config.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    SqlSessionFactory sqlSessionFactory = null;    sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code></pre><p>通过分析，SqlSessionFactoryBuilder创建SqlSessionFactory采用了建造者的设计模式<br>SqlSessionFactoryBuilder扮演具体的建造者，Configuration类则负责建造的细节工作，SqlSession则是构造出来的产品  </p><h3 id="SqlSessionFactory（工厂接口）"><a href="#SqlSessionFactory（工厂接口）" class="headerlink" title="SqlSessionFactory（工厂接口）"></a><strong>SqlSessionFactory（工厂接口）</strong></h3><p><strong>用处：</strong>生产SqlSession会话 即sqlSession = sqlSessionFactory.openSession();  </p><h3 id="SqlSession（会话）"><a href="#SqlSession（会话）" class="headerlink" title="SqlSession（会话）"></a><strong>SqlSession（会话）</strong></h3><p><strong>作用</strong><br>获取映射器，映射器通过命名空间和方法名称找到SQL，发送给数据库执行后返回结果；<br>通过update、insert、select、delete等方法，带上SQL的id来操作在XML中配置好的SQL，从而完成工作，与此同时它也支持事务，通过commit、rollback方法提交或者回滚事务。<br><strong>运行原理：</strong>SqlSession通过Executor（执行器）创建StatementHandler来运行的<br><img src="https://viabcde.github.io/images/2018-10-10/2018101027.png" alt="enter descriptionhere"> </p><h3 id="数据库会话器（StatementHandler）："><a href="#数据库会话器（StatementHandler）：" class="headerlink" title="数据库会话器（StatementHandler）："></a><strong>数据库会话器（StatementHandler）：</strong></h3><p>使用数据库的Statement（PrepareStatement）执行操作<br>种类：SimpleStatementHandler：对应SIMPLE执行器<br>           PrepareStatementHandler：对应REUSE执行器<br>           CallableStatementHandler：对应BATCH执行器<br><strong>参数处理器（ParameterHandler）：</strong>用于SQL对参数的处理<br><strong>结果处理器（ResultSetHandler）：</strong>进行最后数据集（ResultSet）的封装返回处理。  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>mybatis的核心组件，重点是SqlSession和映射器。SqlSession的运行原理要有所了解，会使用SqlSession，同时也要理解mapper的原理，理解mybatis访问数据看的具体原理</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis缓存</title>
      <link href="/2018/11/19/2018-11-19-Mybatis%E7%BC%93%E5%AD%98/"/>
      <url>/2018/11/19/2018-11-19-Mybatis%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Hibernate二级缓存的注意要点"><a href="#Hibernate二级缓存的注意要点" class="headerlink" title="Hibernate二级缓存的注意要点"></a><strong>Hibernate二级缓存的注意要点</strong></h2><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a><strong>一级缓存</strong></h2><p>是必需的，位于Session（是一个HashMap,存放对象的引用）在 session commit 时 清空一级缓存 (防止其他用户 读取到 修改的脏数据)    </p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a><strong>二级缓存</strong></h2><p>非必需，跨多个session，由SessionFactory控制<br>二级缓存可指定使用何种Cache工具，Hibernate 3以后的版本默认使用的是Ehcache，也可以切换为Oscache、JbossCache.  </p><h2 id="缓存策略："><a href="#缓存策略：" class="headerlink" title="缓存策略："></a><strong>缓存策略：</strong></h2><p>比如最大缓存数、缓存过期时间等，将这些参数降低至一个合理的范围<br>首先判断二级缓存有没有 再判断一级缓存有没有 都没有后 才执行sql语句<br>session 共享一个namespace为Usermapper二级缓存 但不共享 namespace为goodsmapper二级缓存<br>如果要这两个mapper.xml使用相同的namespace那么就共享同一个二级缓存   </p><h2 id="开启全部二级缓存"><a href="#开启全部二级缓存" class="headerlink" title="开启全部二级缓存"></a><strong>开启全部二级缓存</strong></h2><p><strong>在sqlmapconfig.xml中</strong><br><img src="https://viabcde.github.io/images/blog/20180928137.png" alt="enter descriptionhere"><br>仅开启一个mapper的二级缓存 usermapper,xml中<br><img src="https://viabcde.github.io/images/blog/20180928138.png" alt="enter descriptionhere">  </p><h2 id="整合echache"><a href="#整合echache" class="headerlink" title="整合echache"></a><strong>整合echache</strong></h2><p><strong>加入2个jar包</strong><br><img src="https://viabcde.github.io/images/blog/20180928138_1.png" alt="enter descriptionhere"><br><strong>usermapper.xml中加入</strong><br><img src="https://viabcde.github.io/images/blog/20180928139.png" alt="enter descriptionhere"><br><strong>echache配置文件classpath下</strong><br><img src="https://viabcde.github.io/images/blog/20180928140.png" alt="enter descriptionhere"><br>po实体类 实现序列化接口(因为二级缓存 可能存在硬盘中  当从硬盘中读取需要反序列化读取)<br>只要sqlsession不提交 就不会清空二级缓存  </p><h2 id="何时清空二级缓存"><a href="#何时清空二级缓存" class="headerlink" title="何时清空二级缓存"></a><strong>何时清空二级缓存</strong></h2><p>请求频繁、对实时数据要求不高的数据 不要求每次都是最新数据  （设置刷新频率久一点 30分钟 24小时）<br>实时性高的 操作后会自动更新缓存 即把缓存清空了  </p><h2 id="二级缓存-局限性"><a href="#二级缓存-局限性" class="headerlink" title="二级缓存 局限性"></a><strong>二级缓存 局限性</strong></h2><p>A客户查询 了 a 商品 B客户查询了 b商品 …都存入了二级缓存 （有1w个商品）<br>当有一个更新商品的操作 那么二级缓存全部被清空了 因此可以说mybatis二级缓存只能针对整个mapper 而不是某一种操作设置二级缓存，粒度不够细<br><strong>缓存</strong><br>同hibernate一样，一级缓存（session级）是默认开启的，如果需要开启二级缓存，就需要加以下配置：  </p><pre><code>&lt;!-- 在核心配置文件中加入配置 --&gt;&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;!-- 在mapper文件中加入配置 --&gt;&lt;cache /&gt;</code></pre><p><code>&lt;cache /&gt;</code> 语句的效果如下：<br>映射语句文件中的所有 <code>select</code> 语句将会被缓存。<br>映射语句文件中的所有 <code>insert， update 和 delete</code>语句会刷新缓存。<br>缓存会使用 Least Recently Used（ LRU，最近最少使用的）算法来收回。<br>根据时间表（比如 no Flush Interval，没有刷新间隔），缓存不会以任何时间顺序来刷新。<br>缓存会存储列表集合或对象（无论查询方法返回什么）的 1024 个引用。<br>缓存会被视为是 read/write（可读/可写）的缓存，意味着对象检索不是共享的，而且可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。<br>所有的这些属性都可以通过缓存元素的属性来修改。比如：     </p><pre><code>&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt;</code></pre><p>这个配置创建了一个 FIFO 缓存，并每隔 60 秒刷新， 存数结果对象或列表的512 个引用，而且返回的对象是只读的，因此在不同线程中的调用者之间修改它们会导致冲突。<br>可用的收回策略有：<br>LRU – 最近最少使用的：移除最长时间不被使用的对象。<br>FIFO – 先进先出：按对象进入缓存的顺序来移除它们。<br>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。<br>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。<br>默认的是 LRU。<br><strong>flushInterval</strong>（刷新间隔）可以被设置为任意的正整数，它们代表一个合理的毫秒形式的时间段。默认不设置，即没有刷新间隔，缓存仅仅调用语句时刷新。<br><strong>size</strong>（引用数目）可以被设置为任意正整数，要记住你缓存的对象数目和你运行环境的可用内存资源数目。默认值是 1024。<br><strong>readOnly</strong>（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例,可读写的缓存会返回缓存对象的拷贝（通过序列化）,默认是 false。   </p><h2 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a><strong>动态sql</strong></h2><p><strong>if 和 choose when otherwise</strong>    </p><pre><code>&lt;select id=”findActiveBlogLike” parameterType=”Blog” resultType=”Blog”&gt;  SELECT * FROM BLOG WHERE state = „ACTIVE‟  &lt;choose&gt;    &lt;when test=”title != null”&gt;      AND title like #{title}    &lt;/when&gt;    &lt;when test=”author != null and author.name != null”&gt;      AND title like #{author.name}    &lt;/when&gt;    &lt;otherwise&gt;      AND featured = 1    &lt;/otherwise&gt;  &lt;/choose&gt;&lt;/select&gt;</code></pre><p>关键字<br><strong>where 和 set</strong>    </p><pre><code>&lt;!-- 取代where关键字，当所有if条件不成立时就不会出现where关键字 --&gt;&lt;select id=”findActiveBlogLike” parameterType=”Blog” resultType=”Blog”&gt;  SELECT * FROM BLOG  &lt;where&gt;    &lt;if test=”state != null”&gt;      state = #{state}    &lt;/if&gt;    &lt;if test=”title != null”&gt;      AND title like #{title}    &lt;/if&gt;    &lt;if test=”author != null and author.name != null”&gt;      AND title like #{author.name}    &lt;/if&gt;  &lt;/where&gt;&lt;/select&gt;&lt;update id=&quot;updateAuthorIfNecessary&quot; parameterType=&quot;domain.blog.Author&quot;&gt;  update Author  &lt;set&gt;    &lt;if test=&quot;username != null&quot;&gt;username=#{username},&lt;/if&gt;    &lt;if test=&quot;password != null&quot;&gt;password=#{password},&lt;/if&gt;    &lt;if test=&quot;email != null&quot;&gt;email=#{email},&lt;/if&gt;    &lt;if test=&quot;bio != null&quot;&gt;bio=#{bio}&lt;/if&gt;  &lt;/set&gt;  where id=#{id}&lt;/update&gt;</code></pre><p><strong>foreach</strong>  </p><pre><code>&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt;  SELECT * FROM POST P WHERE ID in  &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;    #{item}  &lt;/foreach&gt;&lt;/select&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Config配置</title>
      <link href="/2018/11/19/2018-11-19-Config%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/11/19/2018-11-19-Config%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="properties"><a href="#properties" class="headerlink" title="properties"></a><strong>properties</strong></h2><p> <strong>3种配置方式：</strong>  </p><h2 id="第一种：property元素，配置代码示例如下"><a href="#第一种：property元素，配置代码示例如下" class="headerlink" title="第一种：property元素，配置代码示例如下"></a><strong>第一种：property元素，配置代码示例如下</strong></h2><pre><code>&lt;properties&gt;    &lt;properties name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;    &lt;properties name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt;    &lt;properties name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;properties name=&quot;password&quot; value=&quot;****&quot;/&gt;&lt;/properties&gt;</code></pre><h2 id="第二种：怎么使用？"><a href="#第二种：怎么使用？" class="headerlink" title="第二种：怎么使用？"></a><strong>第二种：怎么使用？</strong></h2><pre><code>&lt;dataSource type=&quot;POOLED&quot;&gt;    &lt;properties name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;    &lt;properties name=&quot;url&quot; value=&quot;{url}&quot;/&gt;    &lt;properties name=&quot;username&quot; value=&quot;${username}&quot;/&gt;    &lt;properties name=&quot;password&quot; value=&quot;${password}&quot;/&gt;&lt;/dataSource&gt;</code></pre><p><strong>properties配置文件作用：</strong>方便在多个配置文件中重复使用，便于修改和维护，有的时候为了数据的安全，在jdbc.properties配置密文，通过程序明文解密，保证系统的安全。<br> <strong>properties文件代码示例</strong><br><strong>第三种：数据库配置文件</strong>   </p><pre><code>driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatisusername=rootpassword=****</code></pre><h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a><strong>如何使用？</strong></h2><p>将配置文件放到源包下即可  <code>&lt;properties resource=&quot;jdbc.properties&quot;/&gt;</code></p><h2 id="三种配置方式的优先级"><a href="#三种配置方式的优先级" class="headerlink" title="三种配置方式的优先级"></a><strong>三种配置方式的优先级</strong></h2><p>第三种通过程序方法参数传递的属性具有最高优先级，resource/url属性中指定的配置文件次之，最低优先级是properties元素中指定的属性。            </p><h2 id="settings"><a href="#settings" class="headerlink" title="settings"></a><strong>settings</strong></h2><p>settings是mybatis最复杂的配置，也是最重要的配置，配置内容繁多，这里不予总结，配置内容项自行了解，那么如何配置哪？ 完整的配置示例如下<br> <img src="https://viabcde.github.io/images/2018-10-10/2018101031.png" alt="enter descriptionhere"> </p><pre><code>&lt;settings&gt;    &lt;settings name=&quot;cacheEnable&quot; value=&quot;true&quot;/&gt;    &lt;settings name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;settings name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt;    &lt;settings name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;    &lt;settings name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;    &lt;settings name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;    &lt;settings name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;    &lt;settings name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt;    &lt;settings name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt;    &lt;settings name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt;    &lt;settings name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt;    &lt;settings name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt;    &lt;settings name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;&lt;/settings&gt;</code></pre><h2 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a><strong>typeAliases</strong></h2><h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a><strong>作用：</strong></h2><p>别名可以代替过长类全限定名，在mybatis上下文中使用。  </p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a><strong>分类</strong></h2><p><strong>系统自定义别名：如下表</strong><br><img src="https://viabcde.github.io/images/2018-10-10/2018101030.png" alt="enter descriptionhere"><br><strong>自定义别名：</strong><br>示例代码如下，使用role代替其类的全路径，减少配置的复杂度               </p><pre><code>&lt;!--定义别名--!&gt;&lt;typeAliases&gt;    &lt;typeAlias alias=&quot;role&quot; type=&quot;com.liming.domain.po.Role&quot;/&gt;&lt;/typeAlias&gt;</code></pre><h2 id="typeHandler"><a href="#typeHandler" class="headerlink" title="typeHandler"></a><strong>typeHandler</strong></h2><h2 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a><strong>作用：</strong></h2><p> 预处理语句（PreparedStatemen）中设置参数或者从结果集（ResultSet）中取值，都需要注册了的typeHandler进行类型转换。   </p><h2 id="分类："><a href="#分类：" class="headerlink" title="分类："></a><strong>分类：</strong></h2><p>（1）系统定义<br><strong>系统注册的TypeHandler</strong><br> <strong>代码示例</strong>                                          </p><pre><code>public TypeHandlerRegistry(){    register(Boolean.class, new BooleanTypeHandler());    register(boolean.class, new BooleanTypeHandler());    register(JdbcType.BOOLEAN, new BooleanTypeHandler());    register(JdbcType.BIT, new BooleanTypeHandler());    ......    register(Character.class, new CharacterTypeHandler());    register(char.class, new CharacterTypeHandler());}</code></pre><p> <strong>常用配置</strong><br> java类型（javaType）、JDBC类型（jdbcType）。TypeHandler将参数从javaType转换为jdbcType，或者从数据库取出结果时把jdbcType转换为javaType   </p><h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a><strong>自定义</strong></h2><p> <strong>注册自定义typeHandler，重新覆盖字符串参数的typeHandler</strong>                                </p><pre><code>&lt;typeHandlers&gt;    &lt;typeHandler jdbc=&quot;VARCHAR&quot; javaType=&quot;string&quot; handler=&quot;com.liming.domain.typeHandler.myStringTypeHandler&quot;/&gt;&lt;/typeHandlers&gt;</code></pre><p> <strong>通过扫描注册typeHandle</strong></p><pre><code>&lt;typeHandlers&gt;    &lt;package name=&quot;com.liming.domain.typeHandler&quot;/&gt;&lt;/typeHandlers&gt;                                     </code></pre><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a><strong>枚举</strong></h2><p>mybatis提供了俩个转化枚举类型的typeHandle：org.apache.ibatis.type.EnumTypeHandler和org.apache.ibatis.type.EnumOrdinalTypeHandler。</p><h2 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a><strong>ObjectFactory</strong></h2><h3 id="1-作用："><a href="#1-作用：" class="headerlink" title="1 作用："></a><strong>1 作用：</strong></h3><p>mybatis构建结果返回的时候，会使用ObjectFactory（对象工厂）构建POJO。</p><h3 id="2-分类-："><a href="#2-分类-：" class="headerlink" title="2 分类 ："></a><strong>2 分类 ：</strong></h3><p>（1）默认的，mybatis中默认的ObjectFactory是由org.apache.ibatis.reflection.factory.DefaultObjectFactory来提供服务的。<br>（2）自定义 ，定义新的ObjectFactory代码示例如下，实现代码的时候，我们新的ObjectFactory类直接继承DefaultObjectFactory来实现ObjectFactory的接口。  </p><pre><code>&lt;objectFactory type=&quot;com.liming.domain.objectFactory.MyObjectFactory&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;MyObjectFactory&quot;/&gt;&lt;/objectFactory&gt;</code></pre><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><h2 id="environments"><a href="#environments" class="headerlink" title="environments"></a>environments</h2><h3 id="1-作用：-1"><a href="#1-作用：-1" class="headerlink" title="1 作用："></a><strong>1 作用：</strong></h3><p>主要是用来配置连接池的数据源。</p><h3 id="2-数据源俩大部分："><a href="#2-数据源俩大部分：" class="headerlink" title="2 数据源俩大部分："></a><strong>2 数据源俩大部分：</strong></h3><p>（1）数据库源的配置，通过dataSource标签来配置数据源连接信息，通过子标签property来定义数据库的各类参数，type属性代表数据库连接方式的配置，提供如下四种：<br> 1）UNPOOLED，非连接池数据库（UnpooledDataSource）；<br> 2）POOLED，连接池数据库（PooledDataSource）；<br> 3）JNDI，JNDI数据源（JNDIDataSource）；<br> 4）自定义数据源，必须实现org.apache.ibatis.datasource.DataSourceFactory接口<br>（2）数据库事务的配置，通过transactionManager标签来配置，通过子标签property来配置数据源的各类属性，type属性包含如下三种配置方式<br> 1）JDBC，采用JDBC方式管理事务，在独立编码中常用；<br>  2）MANAGED，采用容器方式管理事务，在JNDI数据源中常用；<br> 3）自定义，由开发者自定义数据库事务管理方法，适用于特殊应用；<br>（3）一个数据源完整配置的代码示例    </p><pre><code>&lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;        &lt;transactionManager type=&quot;JDBC&quot;&gt;            &lt;property name=&quot;autoCommit&quot; value=&quot;false&quot;&gt;        &lt;/transactionManager&gt;        &lt;dataSource type=&quot;POOLED&quot;&gt;            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt;            &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;            &lt;property name=&quot;password&quot; value=&quot;****&quot;/&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;</code></pre><p>备注：environment中的属性default，表明缺省情况下，我们启动哪个数据源配置。   </p><h2 id="databaseIdProvider："><a href="#databaseIdProvider：" class="headerlink" title="databaseIdProvider："></a>databaseIdProvider：</h2><p>它的作用在于指定SQL到对应的数据库厂商提供的数据库中运行，一般应用较少，使用不同厂商数据库的情况较少。mybatis也为数据库厂商标识提供系统默认规则和自定义规则俩种方式，有兴趣自行了解即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mapper.xml文件sql语句编写</title>
      <link href="/2018/11/19/2018-11-19-mapper.xml%E6%96%87%E4%BB%B6sql%E8%AF%AD%E5%8F%A5%E7%BC%96%E5%86%99/"/>
      <url>/2018/11/19/2018-11-19-mapper.xml%E6%96%87%E4%BB%B6sql%E8%AF%AD%E5%8F%A5%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h3 id="resultType和resultMap区别"><a href="#resultType和resultMap区别" class="headerlink" title="resultType和resultMap区别"></a><strong>resultType和resultMap区别</strong></h3><p>resultType是自定义除实体额外的pojo来接收查询结果<br>resultMap是在xml组装好的映射结果，不需要额外的pojo<br>一对一查询（resulttype）<br>    需要些pojo 来接收查询结果 可以继承属性较多的一方 这样子类可以少写一些属性<br><img src="https://viabcde.github.io/images/blog/20180928141.png" alt="enter descriptionhere"><br>一对一查询（resultMap）<br><img src="https://viabcde.github.io/images/blog/20180928142.png" alt="enter descriptionhere"><br>column是指数据库里的字段 而property是po里的属性名<br><img src="https://viabcde.github.io/images/blog/20180928143.png" alt="enter descriptionhere"><br>延迟加载<br><img src="https://viabcde.github.io/images/blog/20180928144.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/blog/20180928145.png" alt="enter descriptionhere"><br>开启延迟加载 在sqlmapconfig.xml<br><img src="https://viabcde.github.io/images/blog/20180928146.png" alt="enter descriptionhere"><br>测试<br><img src="https://viabcde.github.io/images/blog/20180928147.png" alt="enter descriptionhere"><br>测试环境<br><img src="https://viabcde.github.io/images/blog/20180928148.png" alt="enter descriptionhere">  </p><h1 id="association-查询结果的一对一关联："><a href="#association-查询结果的一对一关联：" class="headerlink" title="association 查询结果的一对一关联："></a>association 查询结果的一对一关联：</h1><pre><code>&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;  &lt;id property=”blog_id” column=&quot;id&quot; /&gt;  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;  &lt;association property=&quot;author&quot; column=&quot;blog_author_id&quot; javaType=&quot;Author&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt;    &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt;    &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt;    &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt;    &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt;  &lt;/association&gt;&lt;/resultMap&gt;</code></pre><h1 id="collection查询结果的一对多关联："><a href="#collection查询结果的一对多关联：" class="headerlink" title="collection查询结果的一对多关联："></a>collection查询结果的一对多关联：</h1><pre><code>&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt;  &lt;id property=”id” column=&quot;blog_id&quot; /&gt;  &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt;  &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt;    &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt;    &lt;result property=&quot;body&quot; column=&quot;post_body&quot;/&gt;  &lt;/collection&gt;&lt;/resultMap&gt;</code></pre><h3 id="Mapper配置"><a href="#Mapper配置" class="headerlink" title="Mapper配置"></a><strong>Mapper配置</strong></h3><p>Mybatis 的Mapper 是指Mybatis 执行数据库操作的接口类以及方法，在非注解模式下，还包含与类对应的 xml 配置文件。<br>第一种依据 Mapper 类 具体路径 配置 Mapper<br>这种情况下，如果是非注解模式的话xml配置文件必须和这个类在同一级目录，且与Mapper类同名  </p><pre><code>&lt;configuration&gt;    &lt;mappers&gt;                &lt;!-- class 级别的指定 --&gt;        &lt;mapper class=&quot;com.bestcxx.stu.springmvc.mapper.UserModelMapper&quot;/&gt;        &lt;mapper class=&quot;com.bestcxx.stu.springmvc.mapper.UserModelTwoMapper&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>在存在 xml 配置文件的情况下，文件结构如下，没有 xml 配置文件的情况下，只有 Mapper 类<br><img src="https://viabcde.github.io/images/2018-10-10/2018101032.png" alt="enter descriptionhere"><br>第二种依据 Mapper 类所在的package包路径 配置 Mapper<br>这种情况下，如果是非注解模式的话xml配置文件必须也处于同一级 package 下，且与Mapper类同名  </p><pre><code>&lt;configuration&gt;    &lt;mappers&gt;        &lt;package name=&quot;com.bestcxx.stu.springmvc.mapper&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>文件结构<br><img src="https://viabcde.github.io/images/2018-10-10/2018101033.png" alt="enter descriptionhere"><br>第三种是把 Mapper 的xml配置文件单独放置到 resources 中，和Mapper 类分开了<br>这种方式的好处是便于统一管理 xml 配置文件，不好的的地方是无法使用注解模式了  </p><pre><code>&lt;configuration&gt;    &lt;mappers&gt;        &lt;!-- 使用这个方案，可以单独指定Mapper的位置 --&gt;        &lt;mapper resource=&quot;mybatis/mappings/UserModelMapper.xml&quot;/&gt;        &lt;mapper resource=&quot;mybatis/mappings/UserModelTwoMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>然后Mapper类还是呆在该在的位置<br><img src="https://viabcde.github.io/images/2018-10-10/2018101034.png" alt="enter descriptionhere"><br>但是mapper 的 xml文件的位置如下<br><img src="https://viabcde.github.io/images/2018-10-10/2018101035.png" alt="enter descriptionhere"><br>上面的配置在mybitas-config.xml（名字是可以自定义的）中集中管理，Mapper 的 xml 文件需要关联<br>第一，是mybatis-config.xml 文件负责加载 Mapper的xml文件，即上面所说的配置是在这个mybatis-config.xml文件中<br>第二，mapper对应的xml 配置文件内部要指定对应的Mapper类<br>下面是单独测试mybatis的mybatas的配置文件的内容  </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!-- 元素首次出现必须符合下面的顺序 --&gt;    &lt;!-- (properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?) --&gt;    &lt;!-- 加载常量配置信息 --&gt;    &lt;!-- 可以覆盖重写，用于解密-http://www.mybatis.org/mybatis-3/zh/configuration.html        ·在 properties 元素体内指定的属性首先被读取。        ·然后根据 properties 元素中的 resource 属性读取类路径下属性文件或根据 url 属性指定的路径读取属性文件，并覆盖已读取的同名属性。        ·最后读取作为方法参数传递的属性，并覆盖已读取的同名属性。 --&gt;    &lt;properties resource=&quot;config/jdbc.properties&quot;/&gt;    &lt;!-- 为实体类定义别名 --&gt;    &lt;typeAliases&gt;        &lt;typeAlias alias=&quot;userModel&quot;  type=&quot;com.bestcxx.stu.springmvc.model.UserModel&quot;/&gt;        &lt;typeAlias alias=&quot;userModelTwo&quot;  type=&quot;com.bestcxx.stu.springmvc.model.UserModelTwo&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!-- 使用 spring 配置数据库的时候，下面就可以注释掉了 --&gt;    &lt;!-- 定义数据库信息，默认使用 development 数据库构建环境 --&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;!-- 采用 jdbc 事务管理 --&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;!-- 配置数据库链接信息 --&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driverClassName}&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!-- 定义映射器 --&gt;    &lt;mappers&gt;        &lt;!-- 使用这个方案，可以单独指定Mapper的位置 --&gt;        &lt;!-- &lt;mapper resource=&quot;mybatis/mappings/UserModelMapper.xml&quot;/&gt;        &lt;mapper resource=&quot;mybatis/mappings/UserModelTwoMapper.xml&quot;/&gt; --&gt;        &lt;!-- 使用下面两个个方法，Mapper.xml 文件位置必须在和其内部 &lt;mapper namespace=&quot;&quot;&gt;的类在一起，当然，使用注解模式的话，Mapper.xml文件就没有必要存在了 --&gt;        &lt;!-- 直接指定一个包去扫描-内保包含多个Mapper配置- --&gt;        &lt;!-- &lt;package name=&quot;com.bestcxx.stu.springmvc.mapper&quot;/&gt; --&gt;        &lt;!-- class 级别的指定 --&gt;        &lt;mapper class=&quot;com.bestcxx.stu.springmvc.mapper.UserModelMapper&quot;/&gt;        &lt;mapper class=&quot;com.bestcxx.stu.springmvc.mapper.UserModelTwoMapper&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>mapper的xml 配置文件的内容<br>注意  </p><pre><code>&lt;mapper namespace=&quot;com.bestcxx.stu.springmvc.mapper.UserModelMapper&quot;&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.bestcxx.stu.springmvc.mapper.UserModelMapper&quot;&gt;    &lt;!-- 表字段显式 --&gt;    &lt;sql id=&quot;userModelColumns&quot;&gt;        u.userName AS &quot;userName&quot;,        u.passWord AS &quot;passWord&quot;,        u.createDate AS &quot;createDate&quot;,        u.intNum AS &quot;intNum&quot;,        u.decimalNum AS &quot;decimalNum&quot;    &lt;/sql&gt;    &lt;!-- 根据 userName 查询 --&gt;    &lt;select id=&quot;getUserModel&quot; resultType=&quot;userModel&quot;&gt;        SELECT        &lt;include refid=&quot;userModelColumns&quot; /&gt;        FROM        userModel u        WHERE        u.userName = #{userName}    &lt;/select&gt;    &lt;!-- 插入 --&gt;    &lt;insert id=&quot;addUserModel&quot; parameterType=&quot;userModel&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;userName&quot;&gt;        INSERT INTO userModel (        passWord,        createDate,        intNum,        decimalNum        )        VALUES (        #{passWord},        #{createDate},        #{intNum},        #{decimalNum}        )    &lt;/insert&gt;    &lt;!-- 搜索多条，返回List&lt;userModel&gt;-入参为111,222,333 格式 --&gt;    &lt;select id=&quot;getUserModelListByStrs&quot; parameterType=&quot;string&quot; resultType=&quot;userModel&quot;&gt;        SELECT         &lt;include refid=&quot;userModelColumns&quot; /&gt;        FROM         userModel u        WHERE        u.userName in (${userNames})    &lt;/select&gt;    &lt;!-- 搜索多条，返回 List&lt;HashMap&lt;String,Object&gt;&gt;,入参为list--&gt;    &lt;select id=&quot;getHashMapListByList&quot; parameterType=&quot;list&quot; resultType=&quot;map&quot;&gt;        SELECT         &lt;include refid=&quot;userModelColumns&quot; /&gt;        FROM         userModel u        WHERE        u.userName in         &lt;foreach item=&quot;item&quot; collection=&quot;userNamelist&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot; &gt;            #{item}         &lt;/foreach&gt;    &lt;/select&gt;    &lt;update id=&quot;update&quot;&gt;        UPDATE userModel u        SET        u.passWord=#{passWord},u.createDate=#{createDate}        WHERE        u.userName=#{userName}    &lt;/update&gt;&lt;/mapper&gt;</code></pre><p>第四种，直接在spring中配置Mapper的路径，但是mybatis.xml还是必不可少的<br>在sqlSessionFactory中设定 mybitas的xml和aliases  </p><pre><code>&lt;!-- MustConfigPoint MyBatis begin --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;        &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;实体类包路径&quot; /&gt;        &lt;property name=&quot;typeAliasesSuperType&quot; value=&quot;实体类顶级包路径&quot; /&gt;        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:/mybatis/mappings/**/*.xml&quot; /&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:/mybatis/mybatis-config.xml&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;</code></pre><h1 id="设置Mapper类"><a href="#设置Mapper类" class="headerlink" title="设置Mapper类"></a>设置Mapper类</h1><pre><code>&lt;!-- MustConfigPoint 扫描basePackage下所有以@MyBatisDao注解的接口 --&gt;    &lt;bean id=&quot;mapperScannerConfigurer&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;mapper类的包路径&quot; /&gt;        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;        &lt;property name=&quot;annotationClass&quot; value=&quot;com.msyd.framework.common.persistence.annotation.MyBatisDao&quot; /&gt;    &lt;/bean&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>映射器</title>
      <link href="/2018/11/19/2018-11-19-%E6%98%A0%E5%B0%84%E5%99%A8/"/>
      <url>/2018/11/19/2018-11-19-%E6%98%A0%E5%B0%84%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>映射器是mybatis最复杂最核心的组件</p><h2 id="Sql-Mapper（映射器）"><a href="#Sql-Mapper（映射器）" class="headerlink" title="Sql Mapper（映射器）"></a><strong>Sql Mapper（映射器）</strong></h2><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a><strong>作用：</strong></h3><p>1）定义参数、2）描述缓存、3）描述SQL语句、4）定义查询结果和POJO的映射关系  </p><h3 id="主要元素："><a href="#主要元素：" class="headerlink" title="主要元素："></a><strong>主要元素：</strong></h3><p><img src="https://viabcde.github.io/images/2018-10-10/2018101028.png" alt="enter descriptionhere"> </p><h3 id="引入映射器mapper的方法"><a href="#引入映射器mapper的方法" class="headerlink" title="引入映射器mapper的方法"></a><strong>引入映射器mapper的方法</strong></h3><p><strong>用文件路径引入映射器</strong>                                   </p><pre><code>&lt;mappers&gt;            &lt;mapper resource=&quot;对应mapper接口全路径的配置文件&quot;&gt;&lt;/mappers&gt;</code></pre><p><strong>用包名引入映射器</strong>                           </p><pre><code>&lt;mappers&gt;            &lt;mapper resource=&quot;对应mapper接口包的全路基&quot;&gt;&lt;/mappers&gt;</code></pre><p><strong>用类注册引入映射器</strong>                          </p><pre><code>&lt;mappers&gt;            &lt;mapper resource=&quot;对应mapper接口类的路径&quot;&gt;&lt;/mappers&gt;</code></pre><p><strong>用xml配置文件引入映射器</strong>                          </p><pre><code>&lt;mappers&gt;            &lt;mapper url=&quot;file:///var/mappers+文件路径&quot;&gt;&lt;/mappers&gt;</code></pre><h3 id="引入映射器步骤"><a href="#引入映射器步骤" class="headerlink" title="引入映射器步骤"></a><strong>引入映射器步骤</strong></h3><p><strong>定义映射器接口RoleMapper.java</strong>                      </p><pre><code>package com.liming.domain.mapper;import com.liming.domain.po.Role;public interface RoleMapper{    public Role getRole(Long id);}</code></pre><p> <strong>对应映射器接口的配置文件RoleMapper.xml：定义mapper映射规则和SQL语句</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;      &lt;!DOCTYPE mapper PUBLIC           &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;          &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;      &lt;mapper namespace=&quot;com.liming.domain.mapper.RoleMapper&quot;&gt;          &lt;select id=&quot;getRole&quot; parameterType=&quot;long&quot; resultType=&quot;role&quot;&gt;              select id, role_name as roleName from t_role where id = #{id}         &lt;/select&gt;      &lt;/mapper&gt;  </code></pre><p><strong>在核心配置SqlMapConfig.xml文件中引入映射器</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;        &lt;!-- 别名定义 --&gt;    &lt;typeAliases&gt;        &lt;typeAlias alias=&quot;role&quot; type=&quot;com.liming.domain.po.Role&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!--定义数据库信息，默认使用development数据库构建环境--&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;!--采用jdbc事务管理--&gt;            &lt;transactionMapper type=&quot;JDBC&quot;/&gt;            &lt;!--配置数据库链接信息--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;****&quot;/&gt;            &lt;/dataSource&gt;            &lt;/environment&gt;    &lt;/environments&gt;    &lt;!--定义映射器--&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;com/liming/domain/mapper/roleMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>增删改</title>
      <link href="/2018/11/18/2018-11-18-%E7%BA%A7%E8%81%94%E4%BF%9D%E5%AD%98%E9%97%AE%E9%A2%98/"/>
      <url>/2018/11/18/2018-11-18-%E7%BA%A7%E8%81%94%E4%BF%9D%E5%AD%98%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="级联保存CascadeType"><a href="#级联保存CascadeType" class="headerlink" title="级联保存CascadeType"></a><strong>级联保存CascadeType</strong></h2><p>mappedby设置在一的一方，解决了当多的一方增加，不需要修改一的一方的代码<br>保存transient对象出问题<br>如下图g 没有被save    many2one     one2many     user保存 group不会跟着自动保存<br><img src="https://viabcde.github.io/images/blog/2018092883.png" alt="enter descriptionhere">   </p><h3 id="解决方法1"><a href="#解决方法1" class="headerlink" title="解决方法1"></a><strong>解决方法1</strong></h3><p>把上图注释打开，先存g 再存 a</p><h3 id="解决方法2"><a href="#解决方法2" class="headerlink" title="解决方法2"></a><strong>解决方法2</strong></h3><p>在group.java 保存group时自动保存其关联对象<br><strong>设置group能级联保存</strong><br><img src="https://viabcde.github.io/images/blog/2018092884.png" alt="enter descriptionhere"><br><strong>测试</strong><br><img src="https://viabcde.github.io/images/blog/2018092885.png" alt="enter descriptionhere"><br>【不建议，因为一的一方设置了mappedby，在它的表中不用保存多的一方，所以自动保存一的一方那个不会出现null，而自动保存多的一方会出现null值】同理，可以在user.java即多的这一方设置 保存user时自动保存其关联对象g<br><strong>解决方法</strong><br><img src="https://viabcde.github.io/images/blog/2018092886.png" alt="enter descriptionhere"><br><strong>问题：在数据库里u没有g的数据</strong><br><img src="https://viabcde.github.io/images/blog/2018092887.png" alt="enter descriptionhere"><br><strong>解决方法：user设置group属性</strong><br><img src="https://viabcde.github.io/images/blog/2018092888.png" alt="enter descriptionhere">      </p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h2><p>存储时在save多的一方较容易只需要设多的一方即可 如果save一的一方则后需要 把多地一方再设一遍<br>many-to-one默认取多的一方user会把一的一方group取出来，即使不设置cascade为ALL而取一的一方group不会把多的一方user取出来<br><strong>测试</strong><br><img src="https://viabcde.github.io/images/blog/2018092890.png" alt="enter descriptionhere">    </p><h2 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a><strong>结论</strong></h2><p>cascade管增删改 而fetch管读取<br><img src="https://viabcde.github.io/images/blog/2018092891.png" alt="enter descriptionhere"><br>group的fetch是eager user是lazy 则在用user .getGroup时会发2条sql，一次是取user和group联合的,另一次因为group是eager的所以在第一次取group时，会顺带着把user再取一遍<br>在xml中懒加载设置<br><img src="https://viabcde.github.io/images/blog/2018092892.png" alt="enter descriptionhere"><br>一对多设置eager情况：查看用户的权限；  </p><h2 id="update"><a href="#update" class="headerlink" title="update"></a><strong>update</strong></h2><p>(一般cascade设为all，否则可能更新其他的方法不成功，比如设为merge,就只有用merge方法时能更新)<br><img src="https://viabcde.github.io/images/blog/2018092893.png" alt="enter descriptionhere">  </p><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a><strong>delete</strong></h3><p>在删除前如果不先删除其级联对象会把一个一方group也给删了，如果此时有其他对象级联了group，那么该对象也被清除，才能清除group<br>解决方法1：打破级联关系 先把级联对象设为空<br>解决方法二：使用sql语句<br><img src="https://viabcde.github.io/images/blog/2018092894.png" alt="enter descriptionhere">  </p><h3 id="deletegroup"><a href="#deletegroup" class="headerlink" title="deletegroup"></a><strong>deletegroup</strong></h3><p><img src="https://viabcde.github.io/images/blog/2018092895.png" alt="enter descriptionhere">  </p><h3 id="list和iterate区别"><a href="#list和iterate区别" class="headerlink" title="list和iterate区别"></a><strong>list和iterate区别</strong></h3><p>list取的是id+所有信息 iterate取的是id 当用到的时候再根据id取相应的值<br>list每执行一次都会发出sql语句，而iterate会利用session级的缓存，只会发出一次sql语句</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取Xml文件</title>
      <link href="/2018/11/18/2018-11-18-%E8%8E%B7%E5%8F%96xml%E6%96%87%E4%BB%B6/"/>
      <url>/2018/11/18/2018-11-18-%E8%8E%B7%E5%8F%96xml%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="在test中如何获取xml"><a href="#在test中如何获取xml" class="headerlink" title="在test中如何获取xml"></a><strong>在test中如何获取xml</strong></h2><p>classpathxml 按alt+/即可 然后根据补全<br>接着就可以通过.getBean获取xml中的bean了  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取插入的数据的主键</title>
      <link href="/2018/11/18/2018-11-18-%E8%8E%B7%E5%8F%96%E6%8F%92%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%BB%E9%94%AE/"/>
      <url>/2018/11/18/2018-11-18-%E8%8E%B7%E5%8F%96%E6%8F%92%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%BB%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="一般插入数据后想知道插入的数据的主键是多少，我们可以通过以下的方式来获取"><a href="#一般插入数据后想知道插入的数据的主键是多少，我们可以通过以下的方式来获取" class="headerlink" title="一般插入数据后想知道插入的数据的主键是多少，我们可以通过以下的方式来获取"></a><strong>一般插入数据后想知道插入的数据的主键是多少，我们可以通过以下的方式来获取</strong></h3><p>需求：<br>user对象插入到数据库后，新记录的主键要通过user对象返回，通过user获取主键值。<br>解决思路：<br>通过LAST_INSERT_ID()获取刚插入记录的自增主键值，在insert语句执行后，执行select LAST_INSERT_ID()就可以获取自增主键。<br>mysql:</p><pre><code>    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot;&gt;        &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;int&quot;&gt;            select LAST_INSERT_ID()        &lt;/selectKey&gt;        INSERT INTO USER(username,birthday,sex,address) VALUES(#{username},#{birthday},#{sex},#{address})    &lt;/insert&gt;</code></pre><p>oracle:<br>实现思路：<br>先查询序列得到主键，将主键设置到user对象中，将user对象插入数据库。</p><pre><code>    &lt;!-- oracle    在执行insert之前执行select 序列.nextval() from dual取出序列最大值，将值设置到user对象 的id属性     --&gt;    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot;&gt;        &lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;int&quot;&gt;            select 序列.nextval() from dual        &lt;/selectKey&gt;        INSERT INTO USER(id,username,birthday,sex,address) VALUES( 序列.nextval(),#{username},#{birthday},#{sex},#{address})    &lt;/insert&gt; </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装备Bean的多种方式</title>
      <link href="/2018/11/18/2018-11-18-%E8%A3%85%E5%A4%87bean%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/11/18/2018-11-18-%E8%A3%85%E5%A4%87bean%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="service自动装配dao"><a href="#service自动装配dao" class="headerlink" title="service自动装配dao"></a><strong>service自动装配dao</strong></h3><p>byname 是和 service的属性名相同的bean<br>bytype 是和servicec属性类型相同的bean<br><img src="https://viabcde.github.io/images/blog/20180928103.png" alt="enter descriptionhere"></p><h2 id="装备bean的多种方式"><a href="#装备bean的多种方式" class="headerlink" title="装备bean的多种方式"></a><strong>装备bean的多种方式</strong></h2><h3 id="第一种-注解的方式-自动装配dao-autowired"><a href="#第一种-注解的方式-自动装配dao-autowired" class="headerlink" title="第一种.注解的方式 自动装配dao autowired"></a><strong>第一种.注解的方式 自动装配dao autowired</strong></h3><p> 在beans.xml中<br><img src="https://viabcde.github.io/images/blog/20180928107.png" alt="enter descriptionhere"><br>然后便可以在service 的setDao方法上加注解<br>默认bytype 即按照service的 DAO属性类型注入<br>如果按名称需要像下面在serUserDao括号里写明<br><img src="https://viabcde.github.io/images/blog/20180928108.png" alt="enter descriptionhere">  </p><h3 id="或者不写autowired注解，加resource注解"><a href="#或者不写autowired注解，加resource注解" class="headerlink" title="或者不写autowired注解，加resource注解"></a><strong>或者不写autowired注解，加resource注解</strong></h3><p>默认byname<br><img src="https://viabcde.github.io/images/blog/20180928109.png" alt="enter descriptionhere"><br>但这只是指明了各个组件之间的关系 ，仍需要把各个bean 如service， daoimpl写到xml中<br><img src="https://viabcde.github.io/images/blog/20180928110.png" alt="enter descriptionhere">  </p><h3 id="第二种：使用自动扫描"><a href="#第二种：使用自动扫描" class="headerlink" title="第二种：使用自动扫描"></a><strong>第二种：使用自动扫描</strong></h3><p><img src="https://viabcde.github.io/images/blog/20180928111.png" alt="enter descriptionhere"><br>在类上配置bean<br><img src="https://viabcde.github.io/images/blog/20180928112.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/blog/20180928113.png" alt="enter descriptionhere"><br>而UserDaoImpl是userservice的一个资源<br>在serviceimpl的setUserDaoimol上加resource注解<br><img src="https://viabcde.github.io/images/blog/20180928114.png" alt="enter descriptionhere">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hibernate注解</title>
      <link href="/2018/11/18/2018-11-18-Hibernate%E6%B3%A8%E8%A7%A3/"/>
      <url>/2018/11/18/2018-11-18-Hibernate%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="Transaction"><a href="#Transaction" class="headerlink" title="@Transaction"></a><strong>@Transaction</strong></h3><p><img src="https://viabcde.github.io/images/blog/2018092832.png" alt="enter descriptionhere">  </p><h3 id="指定时间的精度-Temporal"><a href="#指定时间的精度-Temporal" class="headerlink" title="指定时间的精度@Temporal"></a><strong>指定时间的精度@Temporal</strong></h3><p><img src="https://viabcde.github.io/images/blog/2018092833.png" alt="enter descriptionhere">  </p><h3 id="枚举类型注解-Enumerated"><a href="#枚举类型注解-Enumerated" class="headerlink" title="枚举类型注解@Enumerated"></a><strong>枚举类型注解@Enumerated</strong></h3><p><strong>写好枚举类</strong><br><img src="https://viabcde.github.io/images/blog/2018092834.png" alt="enter descriptionhere"><br><strong>引用枚举类并加上注解</strong><br><img src="https://viabcde.github.io/images/blog/2018092835.png" alt="enter descriptionhere"><br><strong>EnumType.ORDINAL这是按枚举类型的下标插入表，而不是按他的值插入表</strong><br><img src="https://viabcde.github.io/images/blog/2018092836.png" alt="enter descriptionhere">  </p><h3 id="Table"><a href="#Table" class="headerlink" title="@Table"></a><strong>@Table</strong></h3><p>当表名和类名不一致 还需在类上加上 @Table 指明 数据库中对应的表的表名<br><img src="https://viabcde.github.io/images/blog/2018092837.png" alt="enter descriptionhere">  </p><h3 id="ID生成策略"><a href="#ID生成策略" class="headerlink" title="ID生成策略"></a><strong>ID生成策略</strong></h3><p>在xml.让所使用的数据库选择ID策略（在mysql中，使用uuid,此时的实体类id改为String类型,如果是native（自动增长）则类型是int）选native和uuid方便数据库跨平台<br><img src="https://viabcde.github.io/images/blog/2018092838.png" alt="enter descriptionhere"><br>最后在插入数据时，不要求设置ID,只需要用户提供name 和age即可<br>Annotation版：<br><img src="https://viabcde.github.io/images/blog/2018092839.png" alt="enter descriptionhere"><br>同样，最后xml配置版的需要在配置文件加上映射 注解版则不需要<br><img src="https://viabcde.github.io/images/blog/2018092840.png" alt="enter descriptionhere">  </p><h3 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a><strong>联合主键</strong></h3><h4 id="编写联合主键类"><a href="#编写联合主键类" class="headerlink" title="编写联合主键类"></a><strong>编写联合主键类</strong></h4><p><img src="https://viabcde.github.io/images/blog/2018092841.png" alt="enter descriptionhere"><br>重写equal和hashcode原因：数据库区分实体使用的是主键，但在内存中也需要使用类似的hashcode算法来区分不同的实体</p><h4 id="修改实体类"><a href="#修改实体类" class="headerlink" title="修改实体类"></a><strong>修改实体类</strong></h4><p><img src="https://viabcde.github.io/images/blog/2018092842.png" alt="enter descriptionhere">  </p><h4 id="修改xml映射文件"><a href="#修改xml映射文件" class="headerlink" title="修改xml映射文件"></a><strong>修改xml映射文件</strong></h4><p><img src="https://viabcde.github.io/images/blog/2018092843.png" alt="enter descriptionhere">  </p><h3 id="Annotation版联合主键"><a href="#Annotation版联合主键" class="headerlink" title="Annotation版联合主键"></a><strong>Annotation版联合主键</strong></h3><p><img src="https://viabcde.github.io/images/blog/2018092844.png" alt="enter descriptionhere">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP事务</title>
      <link href="/2018/11/18/2018-11-18-aop/"/>
      <url>/2018/11/18/2018-11-18-aop/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a><strong>Spring事务</strong></h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a><strong>原子性</strong></h3><p>事务要么一致完成，要么全部回滚。ps：一家人就要整整齐齐</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a><strong>一致性</strong></h3><p>事务开始前和结束后的状态保持一致<br>eg . A向B转账过程出错，钱能原路返回，A和B的金额总和不变。</p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a><strong>持久性</strong></h3><p>事务一经提交 不可改变。</p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a><strong>隔离性</strong></h3><p>不同事务互不干扰。<br>Spring是非侵入性的，不改动原有代码</p><h3 id="platformTransactionManager"><a href="#platformTransactionManager" class="headerlink" title="platformTransactionManager"></a><strong>platformTransactionManager</strong></h3><p>事务管理器,有3个方法： commit() getTranscation(TransactionDefinition definition) roolback()</p><h3 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a><strong>TransactionDefinition</strong></h3><p>标志是事务类型</p><h3 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a><strong>TransactionStatus</strong></h3><p>事务的状态<br><img src="https://viabcde.github.io/images/2018-09-24/2018092401.png" alt="enter descriptionhere">  </p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a><strong>事务的隔离级别</strong></h2><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a><strong>不可重复读</strong></h3><p>A事务在进行中，不能有B事务参与<br>否则，A事务的提交或者回滚会使B事务的更新丢失，相当于做了无用功  </p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a><strong>脏读</strong></h3><p>A事务读取到了B事务正在进行中未提交的数据，如果B事务回滚，该数据就是脏数据  </p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a><strong>幻读</strong></h3><p>A事务2次读取相同数据不一致，第一次是在B事物未开启时的数据第二次是在B事务开启后的数据<br><img src="https://viabcde.github.io/images/2018-09-24/2018092402.png" alt="enter descriptionhere">  </p><h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a><strong>事务的传播行为</strong></h2><p>控制多种操作是否处于同一个事务，方便回滚事务<br>eg.取款业务=取钱+打印凭条。<br>虽然这两个操作处于同一个业务中，但不能是同一事务，因为取钱后，如果打印凭条出错，不能把取钱的操作回滚，因为钱已经取出了。<br>eg.删除用户=删除基本信息+删除订单信息。 这两个操作必须处于同一事务，因为在删除订单信息出错，前面的没有回滚，那么订单信息就成了垃圾数据，无法正常删除<br><img src="https://viabcde.github.io/images/2018-09-24/2018092403.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/blog/20180928129.png" alt="enter descriptionhere">    </p><h2 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a><strong>环绕通知</strong></h2><p><img src="https://viabcde.github.io/images/2018-09-17/spring8.png" alt="">  </p><h3 id="织入"><a href="#织入" class="headerlink" title="织入"></a><strong>织入</strong></h3><p>是一个动作 即在被代理的方法前后 执行拦截逻辑的动作</p><h3 id="连接点"><a href="#连接点" class="headerlink" title="连接点"></a><strong>连接点</strong></h3><p>没有被拦截的方法+被拦截的方法</p><h3 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a><strong>切入点</strong></h3><p>特殊的连接点 被拦截的方法</p><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a><strong>通知</strong></h3><p>拦截后执行的逻辑<br>在aop：config中写入拦截的方法aop:before<br><img src="https://viabcde.github.io/images/2018-09-17/spring9.png" alt=""><br><strong>切入点的写法</strong><br><img src="https://viabcde.github.io/images/2018-09-17/spring10.png" alt="">  </p><h3 id="通用切入点-必须配置在切面的前面"><a href="#通用切入点-必须配置在切面的前面" class="headerlink" title="通用切入点 必须配置在切面的前面"></a><strong>通用切入点 必须配置在切面的前面</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-17/spring11.png" alt=""><br><img src="https://viabcde.github.io/images/2018-09-17/spring12.png" alt=""><br><strong>后置只有被拦截的方法正确执行后才会执行</strong></p><h2 id="开始配置事务"><a href="#开始配置事务" class="headerlink" title="开始配置事务"></a><strong>开始配置事务</strong></h2><p><img src="https://viabcde.github.io/images/2018-09-17/spring24.png" alt="">  </p><h2 id="配置事务"><a href="#配置事务" class="headerlink" title="配置事务"></a><strong>配置事务</strong></h2><p><img src="https://viabcde.github.io/images/2018-09-17/spring25.png" alt="">  </p><h3 id="配置事务的通知"><a href="#配置事务的通知" class="headerlink" title="配置事务的通知"></a><strong>配置事务的通知</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-17/spring26.png" alt="">  </p><h3 id="配置aop"><a href="#配置aop" class="headerlink" title="配置aop"></a><strong>配置aop</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-17/spring27.png" alt="">  </p><h2 id="AOP切面拦截器"><a href="#AOP切面拦截器" class="headerlink" title="AOP切面拦截器"></a><strong>AOP切面拦截器</strong></h2><p><strong>AOP是一种编程范式解决特定问题，不能解决所有问题<br>是OOP的补充，不是替代</strong><br><strong>编程范式概览</strong>  </p><pre><code>面向过程编程  面向对象编程  面向函数编程（函数式编程）  事件驱动编程（GUI开发中比较常见）  面向切面编程  </code></pre><p> <strong>AOP的应用场景</strong>  </p><pre><code>权限控制缓存控制事务控制审计日志性能监控分布式追踪异常处理</code></pre><p><img src="https://viabcde.github.io/images/blog/20180928117.png" alt="enter descriptionhere"><br>源码无需改变 编写自己的切面逻辑<br>pointCut指定对哪些方法加切面逻辑<br>本来是写在@Before的括号内的 但为了方便 统一定义为 一个 myMethod(){}并在前指定对哪些方法加切面逻辑<br><img src="https://viabcde.github.io/images/blog/20180928118.png" alt="enter descriptionhere"><br>也可以在xml中实现AOP<br>首先编写自己的切面逻辑<br><img src="https://viabcde.github.io/images/blog/20180928119.png" alt="enter descriptionhere"><br>然后在xml中指定为哪些方法加切面逻辑<br><img src="https://viabcde.github.io/images/blog/20180928120.png" alt="enter descriptionhere"><br>配置事务管理<br><img src="https://viabcde.github.io/images/blog/20180928126.png" alt="enter descriptionhere"><br>在service加注解<br><img src="https://viabcde.github.io/images/blog/20180928127.png" alt="enter descriptionhere"><br>也可以使用XML进行事务管理<br>先指定对哪些方法 进行事务管理 再具体细分各种方法对应的事务管理<br><img src="https://viabcde.github.io/images/blog/20180928128.png" alt="enter descriptionhere">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bean的生命周期用注解</title>
      <link href="/2018/11/18/2018-11-18-bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
      <url>/2018/11/18/2018-11-18-bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="service的初始化以及结束方法"><a href="#service的初始化以及结束方法" class="headerlink" title="service的初始化以及结束方法"></a><strong>service的初始化以及结束方法</strong></h3><p><img src="https://viabcde.github.io/images/blog/20180928104.png" alt="enter descriptionhere">  </p><h3 id="bean的生命周期用注解"><a href="#bean的生命周期用注解" class="headerlink" title="bean的生命周期用注解"></a><strong>bean的生命周期用注解</strong></h3><p><img src="https://viabcde.github.io/images/blog/20180928115.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/blog/20180928116.png" alt="enter descriptionhere">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bean的scope</title>
      <link href="/2018/11/18/2018-11-18-bean%E7%9A%84scope/"/>
      <url>/2018/11/18/2018-11-18-bean%E7%9A%84scope/</url>
      
        <content type="html"><![CDATA[<h3 id="bean的scope"><a href="#bean的scope" class="headerlink" title="bean的scope"></a><strong>bean的scope</strong></h3><p><img src="https://viabcde.github.io/images/blog/20180928101.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/201811/20181113.png" alt="enter descriptionhere"><br>prototype:原始类型，每次用都是全新的<br><img src="https://viabcde.github.io/images/blog/20180928102.png" alt="enter descriptionhere">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Getcurrentsession</title>
      <link href="/2018/11/18/2018-11-18-getcurrentsession/"/>
      <url>/2018/11/18/2018-11-18-getcurrentsession/</url>
      
        <content type="html"><![CDATA[<h3 id="getcurrentsession"><a href="#getcurrentsession" class="headerlink" title="getcurrentsession"></a><strong>getcurrentsession</strong></h3><p>不需要close，事务提交，自动clsoe，在commit前的session都是同一个<br><strong>好处</strong><br>在adduser中要添加setlog方法时，事务的边界是在service层<br>不能使用opensession，因为这是打开了一个新的session<br>在service层做的操作在此事务完全不知晓可以用getcurrentsession代替，由此也可以看出事务边界应该界定在service层。  </p><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a><strong>PS</strong></h2><p>一般事务管理使用thread,但当需要跨数据库时需要使用JTA（使用transactionManager管理一个事务），如商品和财务分离的系统<br>一个管理商品，一个记账，使用JTA可以保证这一操作在同一个事务中<br>先opensession 在getcurrentsession 两个不是同一个，原因，session是一个接口，这两个是不同的实现类，所以不同</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dao接口与xml映射文件</title>
      <link href="/2018/11/18/2018-11-18-dao%E6%8E%A5%E5%8F%A3%E4%B8%8Exml%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/"/>
      <url>/2018/11/18/2018-11-18-dao%E6%8E%A5%E5%8F%A3%E4%B8%8Exml%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"><a href="#Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"></a><strong>Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</strong></h3><p>Dao接口即Mapper接口<br>接口的全限名=映射文件中的namespace的值<br>接口的方法名=映射文件中MappedStatement的id值<br>接口方法内的参数=传递给sql的参数<br>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement<br><strong>举例：</strong><br>在Mybatis中，每一个select、insert、update、delete标签，都会被解析为一个MappedStatement对象。<br>com.mybatis3.mappers.StudentDao.findStudentById，<br>可以唯一找到namespace为com.mybatis3.mappers.StudentDao中id = findStudentById的MappedStatement。<br><strong>注意：</strong><br>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。<br><strong>Dao接口的工作原理：</strong><br>JDK动态代理，Mybatis运行时使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回  </p><h3 id="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a><strong>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</strong></h3><p>namespace不同可以重复，因为我们的Statement实际上就是namespace+id</p><h3 id="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"><a href="#Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？" class="headerlink" title="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"></a><strong>Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</strong></h3><p>完成逻辑判断和动态拼接sql的功能。<br>Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind。<br><strong>执行原理</strong><br>使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Junit</title>
      <link href="/2018/11/18/2018-11-18-junit/"/>
      <url>/2018/11/18/2018-11-18-junit/</url>
      
        <content type="html"><![CDATA[<h3 id="junit"><a href="#junit" class="headerlink" title="junit"></a><strong>junit</strong></h3><p><img src="https://viabcde.github.io/images/blog/2018092846.png" alt="enter descriptionhere">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Log4j日志环境</title>
      <link href="/2018/11/18/2018-11-18-log4j%E6%97%A5%E5%BF%97%E7%8E%AF%E5%A2%83/"/>
      <url>/2018/11/18/2018-11-18-log4j%E6%97%A5%E5%BF%97%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h3 id="log4j日志环境问题"><a href="#log4j日志环境问题" class="headerlink" title="log4j日志环境问题"></a><strong>log4j日志环境问题</strong></h3><p><img src="https://viabcde.github.io/images/blog/2018092845.png" alt="enter descriptionhere"><br>slf4j-api 是日志的接口 log4j 是对前者的实现 slf4j-log4j是将两者的aoi对应起来<br>导入log4j.properties<br>在测试时可以用@Before初始化sessionfactory @After 关闭它 实现单例 ，不用每次都建一个factory</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bean的生命周期用注解</title>
      <link href="/2018/11/18/2018-11-18-service%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E7%BB%93%E6%9D%9F%E6%96%B9%E6%B3%95/"/>
      <url>/2018/11/18/2018-11-18-service%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E7%BB%93%E6%9D%9F%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="service的初始化以及结束方法"><a href="#service的初始化以及结束方法" class="headerlink" title="service的初始化以及结束方法"></a><strong>service的初始化以及结束方法</strong></h3><p><img src="https://viabcde.github.io/images/blog/20180928104.png" alt="enter descriptionhere">  </p><h3 id="bean的生命周期用注解"><a href="#bean的生命周期用注解" class="headerlink" title="bean的生命周期用注解"></a><strong>bean的生命周期用注解</strong></h3><p><img src="https://viabcde.github.io/images/blog/20180928115.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/blog/20180928116.png" alt="enter descriptionhere">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis延迟加载</title>
      <link href="/2018/11/18/2018-11-18-Mybatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/"/>
      <url>/2018/11/18/2018-11-18-Mybatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="Mybatis是否支持延迟加载？实现原理是什么？"><a href="#Mybatis是否支持延迟加载？实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？实现原理是什么？"></a><strong>Mybatis是否支持延迟加载？实现原理是什么？</strong></h2><p>association关联对象，association指的就是一对一<br>collection关联集合对象，collection指的就是一对多查询。<br>在Mybatis配置文件中，可以配置是否启用延迟加载<code>lazyLoadingEnabled=true|false</code></p><p><strong>原理:</strong><br>使用cglib创建代理对象，当调用目标方法时，进入拦截器方法。<br><strong>比如</strong><br>调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。  </p><p>除了Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Update Persist对象</title>
      <link href="/2018/11/18/2018-11-18-update%20persist%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/11/18/2018-11-18-update%20persist%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="update-persist对象"><a href="#update-persist对象" class="headerlink" title="update persist对象"></a><strong>update persist对象</strong></h2><p><img src="https://viabcde.github.io/images/blog/2018092848.png" alt="enter descriptionhere"><br><strong>问题：</strong> commit时会匹配session和数据库是否一致，不一致就update,所有字段都会更新即使只有一个不同</p><h3 id="解决方法：xml中在属性的get方法设置-uptable为false"><a href="#解决方法：xml中在属性的get方法设置-uptable为false" class="headerlink" title="解决方法：xml中在属性的get方法设置@uptable为false"></a><strong>解决方法：xml中在属性的get方法设置@uptable为false</strong></h3><p><img src="https://viabcde.github.io/images/blog/2018092849.png" alt="enter descriptionhere"><br><strong>问题：</strong>跨session时不好使，还是会把属性全部更新<br> <strong>解决方法：使用merge()</strong><br><img src="https://viabcde.github.io/images/blog/2018092850.png" alt="enter descriptionhere"><br><strong>问题：会先select相应的记录再和session的对象匹配</strong><br><strong>解决方法：</strong><br><img src="https://viabcde.github.io/images/blog/2018092851.png" alt="enter descriptionhere"> </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主键生成机制</title>
      <link href="/2018/11/18/2018-11-18-%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/11/18/2018-11-18-%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Hibernate-的的不同属性含义"><a href="#Hibernate-的的不同属性含义" class="headerlink" title="Hibernate 的的不同属性含义"></a><strong>Hibernate 的的不同属性含义</strong></h2><h3 id="assigned"><a href="#assigned" class="headerlink" title="assigned"></a><strong>assigned</strong></h3><p>主键由外部程序生成。</p><h3 id="hilo"><a href="#hilo" class="headerlink" title="hilo"></a><strong>hilo</strong></h3><p>通过hi/lo 算法生成主键，需要额外的数据库表保存主键生成历史状态。</p><h3 id="seqhilo"><a href="#seqhilo" class="headerlink" title="seqhilo"></a><strong>seqhilo</strong></h3><p>与hilo 类似，通过hi/lo 算法生成主键，只是主键历史状态保存在Sequence中，适用于支持Sequence的数据库，如Oracle。</p><h3 id="increment"><a href="#increment" class="headerlink" title="increment"></a><strong>increment</strong></h3><p>主键按数值顺序递增<br>这种方式可能产生的问题是：如果有多个实例访问同一个数据库，那么由于各个实例各自维护主键状态，造成主键重复异常。</p><h3 id="identity"><a href="#identity" class="headerlink" title="identity"></a><strong>identity</strong></h3><p>数据库提供的主键生成机制。如DB2、SQL Server、MySQL </p><h3 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a><strong>sequence</strong></h3><p>采用数据库提供的sequence 机制生成主键。如Oralce的Sequence。  </p><h3 id="native"><a href="#native" class="headerlink" title="native"></a><strong>native</strong></h3><p>由Hibernate根据底层数据库自行采用identity、hilo、sequence其中一种主键生成方式。</p><h3 id="uuid-hex"><a href="#uuid-hex" class="headerlink" title="uuid.hex"></a><strong>uuid.hex</strong></h3><p>由Hibernate基于128 位唯一值产生算法生成16 进制数值（编码后以长度32 的字符串表示）作为主键。  </p><h3 id="uuid-string"><a href="#uuid-string" class="headerlink" title="uuid.string"></a><strong>uuid.string</strong></h3><p>与uuid.hex 类似，只是生成的主键未进行编码（长度16）。在某些数据库中可能出现问题（如PostgreSQL）。</p><h3 id="foreign"><a href="#foreign" class="headerlink" title="foreign"></a><strong>foreign</strong></h3><p>使用外部表的字段作为主键。<br><strong>PS</strong></p><pre><code>一般而言，利用uuid.hex方式生成主键将提供最好的性能和数据库平台适 应性。   另外由于常用的数据库，如Oracle、DB2、SQLServer、MySql 等，都提 供了易用的主键生成机制（Auto-Increase 字段或者Sequence）。我们可以在数 据库提供的主键生成机制上，采用generator-class=native的主键生成方式。      数据库提供的主键生成机制，往往是通过在一个内部表中保存当前主键状 态（如对于自增型主键而言，此内部表中就维护着当前的最大值和递增量）， 之后每次插入数据会读取这个最大值，然后加上递增量作为新记录的主键，之 后再把这个新的最大值更新回内部表中，这样，一次Insert操作可能导致数据 库内部多次表读写操作和数据的加锁解锁操作.</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hibernatetemplate</title>
      <link href="/2018/11/18/2018-11-18-%E4%BD%BF%E7%94%A8hibernatetemplate/"/>
      <url>/2018/11/18/2018-11-18-%E4%BD%BF%E7%94%A8hibernatetemplate/</url>
      
        <content type="html"><![CDATA[<h3 id="使用hibernatetemplate示例"><a href="#使用hibernatetemplate示例" class="headerlink" title="使用hibernatetemplate示例"></a><strong>使用hibernatetemplate示例</strong></h3><p><img src="https://viabcde.github.io/images/blog/20180928131.png" alt="enter descriptionhere">  </p><h2 id="为dao注入hibernateTemplate"><a href="#为dao注入hibernateTemplate" class="headerlink" title="为dao注入hibernateTemplate"></a><strong>为dao注入hibernateTemplate</strong></h2><p><img src="https://viabcde.github.io/images/2018-09-17/spring21.png" alt="">  </p><h2 id="为hibernateTemplate注入session-Factory"><a href="#为hibernateTemplate注入session-Factory" class="headerlink" title="为hibernateTemplate注入session Factory"></a><strong>为hibernateTemplate注入session Factory</strong></h2><p><img src="https://viabcde.github.io/images/2018-09-17/spring22.png" alt="">  </p><h2 id="sessionFactory注入配置文件"><a href="#sessionFactory注入配置文件" class="headerlink" title="sessionFactory注入配置文件"></a><strong>sessionFactory注入配置文件</strong></h2><p><img src="https://viabcde.github.io/images/2018-09-17/spring23.png" alt="">  </p><h3 id="查询所有记录"><a href="#查询所有记录" class="headerlink" title="查询所有记录"></a><strong>查询所有记录</strong></h3><p>使用hibernateTemplate的类必须先继承HibernateDaoSupport<code>public class CategoryDao extends HibernateDaoSupport</code></p><pre><code>public List&lt;Category&gt; findAll() {        String hql = &quot;from Category&quot;;        List&lt;Category&gt; list = this.getHibernateTemplate().find(hql);        return list;    }</code></pre><h3 id="DetachedCriteria离线条件查询热门商品"><a href="#DetachedCriteria离线条件查询热门商品" class="headerlink" title="DetachedCriteria离线条件查询热门商品"></a><strong>DetachedCriteria离线条件查询<code>热门商品</code></strong></h3><p>从product表中查询<br>条件为 is_hot = 1<br>结果按日期的倒序排序输出<br>从第0条记录开始，往后查询20条记录<br>然后组装成list返回</p><pre class=" language-stata"><code class="language-stata">// 首页上热门商品查询    public List<Product> findHot() {        // 使用离线条件查询.        DetachedCriteria criteria = DetachedCriteria.forClass(Product.class);        // 查询热门的商品,条件就是is_host = 1        criteria.add(Restrictions.eq("is_hot", 1));        // 按日期倒序排序输出:        criteria.addOrder(Order.desc("pdate"));        // 执行查询:        List<Product> list = this.getHibernateTemplate().findByCriteria(criteria, 0, 20);        return list;    }</code></pre><h3 id="查询最新商品"><a href="#查询最新商品" class="headerlink" title="查询最新商品"></a><strong>查询最新商品</strong></h3><p><code>这里有个业务逻辑</code>：处理查询最新商品的业务，只需要查询所有记录，然后按日期倒序输出即可<br>从第0条记录开始，往后查询10条记录<br>然后组装成list返回</p><pre class=" language-stata"><code class="language-stata">// 首页上最新商品的查询    public List<Product> findNew() {        // 使用离线条件查询:        DetachedCriteria criteria = DetachedCriteria.forClass(Product.class);        // 按日期进行倒序排序:        criteria.addOrder(Order.desc("pdate"));        // 执行查询:        List<Product> list = this.getHibernateTemplate().findByCriteria(criteria, 0, 10);        return list;    }</code></pre><h3 id="从后台session获取列表并迭代列表里的元素"><a href="#从后台session获取列表并迭代列表里的元素" class="headerlink" title="从后台session获取列表并迭代列表里的元素"></a><strong>从后台session获取列表并迭代列表里的元素</strong></h3><p>迭代的每个元素p<br>获取该元素的id  image<br>p.id    p.image</p><pre class=" language-dust"><code class="language-dust"><s:iterator var="p" value="hList">        <li>                <a href="${ pageContext.request.contextPath }/product_findByPid.action?pid=<s:property value="#p.pid"/>"target="_blank">                        <!-- src="当前面目录下 即webroot下/图片的地址"data-original 可以暂时不管，他只是图片的真实存放地址，用于延迟加载-->            <img src="${pageContext.request.contextPath}/<s:property value="#p.image"/>" data-original="http://storage.shopxx.net/demo-image/3.0/201301/0ff130db-0a1b-4b8d-a918-ed9016317009-thumbnail.jpg" style="display: block;">                </a>        </li></s:iterator>    </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Mapper中如何传递多个参数</title>
      <link href="/2018/11/18/2018-11-18-%E5%9C%A8mapper%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0/"/>
      <url>/2018/11/18/2018-11-18-%E5%9C%A8mapper%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="在mapper中如何传递多个参数"><a href="#在mapper中如何传递多个参数" class="headerlink" title="在mapper中如何传递多个参数"></a><strong>在mapper中如何传递多个参数</strong></h3><p><strong>第一种：使用占位符</strong><br>在映射文件中使用#{0},#{1}代表传递进来的第几个参数<br>在java代码中使用@param注解:来命名参数<br><strong>#{0},#{1}方式</strong><br>//对应的xml,#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数   </p><pre><code>&lt;select id=&quot;selectUser&quot;resultMap=&quot;BaseResultMap&quot;&gt;      select *  fromuser_user_t   whereuser_name = #{0} anduser_area=#{1}  &lt;/select&gt;  </code></pre><p><strong>@param注解方式</strong></p><pre><code>        public interface usermapper {          user selectuser(@param(“username”) string username,          @param(“hashedpassword”) string hashedpassword);         } &lt;select id=”selectuser” resulttype=”user”&gt;          select id, username, hashedpassword          from some_table          where username = #{username}          and hashedpassword = #{hashedpassword}     &lt;/select&gt;</code></pre><p>【当参数超过2个时使用】<strong>第二种：使用Map集合作为参数来装载</strong></p><pre><code>  try{            //映射文件的命名空间.SQL片段的ID，就可以调用对应的映射文件中的SQL            /**             * 由于我们的参数超过了两个，而方法中只有一个Object参数收集             * 因此我们使用Map集合来装载我们的参数             */            Map&lt;String, Object&gt; map = new HashMap();            map.put(&quot;start&quot;, start);            map.put(&quot;end&quot;, end);            return sqlSession.selectList(&quot;StudentID.pagination&quot;, map);        }catch(Exception e){            e.printStackTrace();            sqlSession.rollback();            throw e;        }finally{            MybatisUtil.closeSqlSession();        }        </code></pre><pre><code>&lt;!--分页查询--&gt;    &lt;select id=&quot;pagination&quot; parameterType=&quot;map&quot; resultMap=&quot;studentMap&quot;&gt;        /*根据key自动找到对应Map集合的value*/        select * from students limit #{start},#{end};    &lt;/select&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象的三种状态</title>
      <link href="/2018/11/18/2018-11-18-%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81/"/>
      <url>/2018/11/18/2018-11-18-%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h3 id="对象的三种状态"><a href="#对象的三种状态" class="headerlink" title="对象的三种状态"></a><strong>对象的三种状态</strong></h3><p><img src="https://viabcde.github.io/images/blog/2018092847.png" alt="enter descriptionhere"><br>save之后session中有指向实体的引用（persist）缓存，数据库有id<br>commit之后数据库中有实体（detach），session中对其的缓存销毁了<br>save 之后的数据都暂时保存在session中  persist状态<br>只有事务提交了 才保存在数据库中  detach 状态     </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实体类中的属性名和表中的字段名</title>
      <link href="/2018/11/18/2018-11-18-%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%8D%E5%92%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%8D/"/>
      <url>/2018/11/18/2018-11-18-%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%8D%E5%92%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="当实体类中的属性名和表中的字段名不一样-，怎么办-？"><a href="#当实体类中的属性名和表中的字段名不一样-，怎么办-？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样 ，怎么办 ？"></a><strong>当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</strong></h3><p>1.在sql中设置别名<br>2.在resultMap中通过属性映射数据库的字段<br><strong>示例</strong><br>第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致</p><pre><code>&lt;select id=”selectorder” parametertype=”int” resultetype=”me.gacl.domain.order”&gt;        select order_id id, order_no orderno ,order_price price form orders where order_id=#{id};     &lt;/select&gt; </code></pre><p>第2种： 通过<code>&lt;resultMap&gt;</code>来映射字段名和实体类属性名的一一对应的关系</p><pre><code> &lt;select id=&quot;getOrder&quot; parameterType=&quot;int&quot; resultMap=&quot;orderresultmap&quot;&gt;        select * from orders where order_id=#{id}    &lt;/select&gt;   &lt;resultMap type=”me.gacl.domain.order” id=”orderresultmap”&gt;         &lt;!–用id属性来映射主键字段–&gt;         &lt;id property=”id” column=”order_id”&gt;         &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt;         &lt;result property = “orderno” column =”order_no”/&gt;         &lt;result property=”price” column=”order_price” /&gt;     &lt;/reslutMap&gt;</code></pre><p>我认为第二种方式会好一点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将hibernate的SessionFactory交由spring管理</title>
      <link href="/2018/11/18/2018-11-18-%E5%B0%86hibernate%E7%9A%84SessionFactory%E4%BA%A4%E7%94%B1spring%E7%AE%A1%E7%90%86/"/>
      <url>/2018/11/18/2018-11-18-%E5%B0%86hibernate%E7%9A%84SessionFactory%E4%BA%A4%E7%94%B1spring%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><strong>将hibernate的SessionFactory交由spring管理:sessionFactory需要dataSource</strong><br><img src="https://viabcde.github.io/images/blog/20180928122.png" alt="enter descriptionhere"><br><strong>给session配置自动扫描</strong><br><img src="https://viabcde.github.io/images/blog/20180928123.png" alt="enter descriptionhere"><br><strong>使用方法</strong><br><img src="https://viabcde.github.io/images/blog/20180928125.png" alt="enter descriptionhere">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LOAD and GET</title>
      <link href="/2018/11/18/2018-11-18-LOAD%20and%20GET/"/>
      <url>/2018/11/18/2018-11-18-LOAD%20and%20GET/</url>
      
        <content type="html"><![CDATA[<h3 id="LOAD-and-GET"><a href="#LOAD-and-GET" class="headerlink" title="LOAD and GET"></a><strong>LOAD and GET</strong></h3><p>session get 获取的是实际的对象，发出sql语句，有实际的数据<br>而session load 获取对象的代理，commit后通过代理取不到相应的对象，只有在commit之前，需要用到数据才会发出sql语句，所以没有实际数据<br>比如Teacher t = (Teacher)session.load(Teacher.class, 1000);即使数据库没有id=1000的记录，依旧不会报错，因为没有执行sql，而get会报错，因为它执行了sql </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bean创建的2种规则</title>
      <link href="/2018/11/18/2018-11-18-Bean%E5%88%9B%E5%BB%BA%E7%9A%842%E7%A7%8D%E8%A7%84%E5%88%99/"/>
      <url>/2018/11/18/2018-11-18-Bean%E5%88%9B%E5%BB%BA%E7%9A%842%E7%A7%8D%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>BeanFactory:<br>延迟加载思想创建对象，即用到bean时才创建bean<br>ApplicationContext:<br>立即加载思想创建对象，即解析完配置文件就创建bean<br>⑴. 继承了 BeanFactory，拥有了基本的 IoC 功能；<br>⑵. 除此之外，ApplicationContext 还提供了以下功能：<br>① 支持国际化；② 支持消息机制；③ 支持统一的资源加载；④ 支持AOP功能；<br>【推荐使用】ClassPathXmlApplicationContext:<br>只能加载类路径下的配置文件<br>FileSystemXmlApplicationContext：<br>可以加载磁盘任意位置的配置文件<br><strong>•注意：</strong><br>如果 Bean 没有完全注入，BeanFactory 加载后，会在你第一次调用 getBean 方法找不到依赖才会抛出异常；<br>而 ApplicationContext 会在初始化的时候就加载并且检查，这样的好处是可以及时检查依赖是否完全注入；所以通常我们会选择 ApplicationContext。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装备Bean的多种方式</title>
      <link href="/2018/11/18/2018-11-18-Autowire/"/>
      <url>/2018/11/18/2018-11-18-Autowire/</url>
      
        <content type="html"><![CDATA[<h3 id="service自动装配dao"><a href="#service自动装配dao" class="headerlink" title="service自动装配dao"></a><strong>service自动装配dao</strong></h3><p>byname 是和 service的属性名相同的bean<br>bytype 是和servicec属性类型相同的bean<br><img src="https://viabcde.github.io/images/blog/20180928103.png" alt="enter descriptionhere"></p><h2 id="装备bean的多种方式"><a href="#装备bean的多种方式" class="headerlink" title="装备bean的多种方式"></a><strong>装备bean的多种方式</strong></h2><h3 id="第一种-注解的方式-自动装配dao-autowired"><a href="#第一种-注解的方式-自动装配dao-autowired" class="headerlink" title="第一种.注解的方式 自动装配dao autowired"></a><strong>第一种.注解的方式 自动装配dao autowired</strong></h3><p> 在beans.xml中<br><img src="https://viabcde.github.io/images/blog/20180928107.png" alt="enter descriptionhere"><br>然后便可以在service 的setDao方法上加注解<br>默认bytype 即按照service的 DAO属性类型注入<br>如果按名称需要像下面在serUserDao括号里写明<br><img src="https://viabcde.github.io/images/blog/20180928108.png" alt="enter descriptionhere">  </p><h3 id="或者不写autowired注解，加resource注解"><a href="#或者不写autowired注解，加resource注解" class="headerlink" title="或者不写autowired注解，加resource注解"></a><strong>或者不写autowired注解，加resource注解</strong></h3><p>默认byname<br><img src="https://viabcde.github.io/images/blog/20180928109.png" alt="enter descriptionhere"><br>但这只是指明了各个组件之间的关系 ，仍需要把各个bean 如service， daoimpl写到xml中<br><img src="https://viabcde.github.io/images/blog/20180928110.png" alt="enter descriptionhere">  </p><h3 id="第二种：使用自动扫描"><a href="#第二种：使用自动扫描" class="headerlink" title="第二种：使用自动扫描"></a><strong>第二种：使用自动扫描</strong></h3><p><img src="https://viabcde.github.io/images/blog/20180928111.png" alt="enter descriptionhere"><br>在类上配置bean<br><img src="https://viabcde.github.io/images/blog/20180928112.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/blog/20180928113.png" alt="enter descriptionhere"><br>而UserDaoImpl是userservice的一个资源<br>在serviceimpl的setUserDaoimol上加resource注解<br><img src="https://viabcde.github.io/images/blog/20180928114.png" alt="enter descriptionhere">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读取配置文件的方法</title>
      <link href="/2018/11/18/2018-11-18-%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2018/11/18/2018-11-18-%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="读取配置文件的方法"><a href="#读取配置文件的方法" class="headerlink" title="读取配置文件的方法"></a><strong>读取配置文件的方法</strong></h2><h3 id="1-流读取"><a href="#1-流读取" class="headerlink" title="1.流读取"></a><strong>1.流读取</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-17/spring1.png" alt="">   </p><h3 id="2使用bundle"><a href="#2使用bundle" class="headerlink" title="2使用bundle"></a><strong>2使用bundle</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-17/spring3.png" alt="">    </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的web.xml配置</title>
      <link href="/2018/11/18/2018-11-18-%20Spring%E7%9A%84web.xml%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/11/18/2018-11-18-%20Spring%E7%9A%84web.xml%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a><strong>web.xml</strong></h3><h3 id="内容一："><a href="#内容一：" class="headerlink" title="内容一："></a><strong>内容一：</strong></h3><p>配置默认页面：<br>当用户在浏览器中输入的URL不包含某个servlet名或JSP页面时，welcome-file-list元素可指定显示的默认文件。</p><pre><code>&lt;!-- displayname 只是用来显示项目名称 可配置可不配置 --&gt;    &lt;display-name&gt;ssm-demo&lt;/display-name&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;</code></pre><h3 id="内容二："><a href="#内容二：" class="headerlink" title="内容二："></a><strong>内容二：</strong></h3><pre><code>    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;    &lt;/context-param&gt;</code></pre><p>context-param是以键值对形式存在的<br>context-param使用方法：由于context-param是配置在web下面，属于上下文参数，在整个环境中都可使用，存放在getServletContext对像中，因此使用方法是：getServletContext().getInitParameter(“user”)，如：</p><pre><code>public void service(HttpServletRequest request, HttpServletResponse response)throws ServletException,IOException{        String user=getServletContext().getInitParameter(&quot;user&quot;);        System.out.println(getServletContext().getInitParameter(&quot;user&quot;));        System.out.println(user);           }</code></pre><h3 id="内容三："><a href="#内容三：" class="headerlink" title="内容三："></a><strong>内容三：</strong></h3><p>配置字符编码过滤器<br>先配置过滤的实现类<br>再配置被过滤的请求类型 /* 表示所有</p><pre><code>   &lt;filter&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;</code></pre><h3 id="内容四："><a href="#内容四：" class="headerlink" title="内容四："></a><strong>内容四：</strong></h3><p>配置Spring的监听器<br>和SpribgMVC转发器以及拦截的请求类型</p><pre><code>  &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;        &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;</code></pre><p>init-param使用方法：由于init-param是配置在servlet中，属于某一下servlet，存放在getServletConfig中，因此使用方法是：getServletConfig().getInitParameter(“user1”); 由于它属于当前的servlet类，所以用this替代getServletConfig(), 使用this.getInitParmeter(“user1”) , 如：</p><pre><code>    public void service(HttpServletRequest request, HttpServletResponse response)throws ServletException,IOException{        String user=getServletContext().getInitParameter(&quot;user1&quot;);        System.out.println(getServletConfig().getInitParameter(&quot;user1&quot;));        //或this.getInitParmeter(&quot;user1&quot;);        System.out.println(user1);          }</code></pre><h3 id="内容五："><a href="#内容五：" class="headerlink" title="内容五："></a><strong>内容五：</strong></h3><p>配置各种错误返回类型所对应的返回页面</p><pre><code>&lt;error-page&gt;        &lt;error-code&gt;404&lt;/error-code&gt;        &lt;location&gt;/main.jsp&lt;/location&gt;    &lt;/error-page&gt;    &lt;error-page&gt;        &lt;error-code&gt;500&lt;/error-code&gt;        &lt;location&gt;/main.jsp&lt;/location&gt;    &lt;/error-page&gt;</code></pre><h3 id="beans-xml文件"><a href="#beans-xml文件" class="headerlink" title="beans.xml文件"></a><strong>beans.xml文件</strong></h3><p><img src="https://viabcde.github.io/images/blog/2018092897.png" alt="enter descriptionhere">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hibernate对象关系映射</title>
      <link href="/2018/11/18/2018-11-18-%20Hibernate%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84/"/>
      <url>/2018/11/18/2018-11-18-%20Hibernate%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h3 id="一对一-单向-外键-关联"><a href="#一对一-单向-外键-关联" class="headerlink" title="一对一 单向_外键 关联"></a><strong>一对一 单向_外键 关联</strong></h3><p>1.husband的id是参考wife的;<br>2.2.husband有个wifiId字段是参考wife的<br>husband有一个外键wifeid,只需要在husband配置即可<br>husabnd.java中有个属性:wife,而wife.java没有husband这个属性<br><img src="https://viabcde.github.io/images/blog/2018092854.png" alt="enter descriptionhere"><br>或者<br><strong>【不推荐】xml方式配置</strong>  </p><pre><code>studentIdCard有student的id而student没有StudentIdCard的id  在StuIdCard.xml中配置即可，使用studentId的字段存储来自student的id  </code></pre><p><img src="https://viabcde.github.io/images/blog/2018092855.png" alt="enter descriptionhere">  </p><h3 id="一对一双向外键关联"><a href="#一对一双向外键关联" class="headerlink" title="一对一双向外键关联"></a><strong>一对一双向外键关联</strong></h3><p>husband.java中有wife属性，表中有wifeid，而wife.java中有husband属性,数据库没有husbandId<br>mappyedby=(“wife”)指得是wife.java中的husband是由husband.java中的wife(对应mappedby中的wife)属性映射，不需要在数据库join husbandId<br>在husband.java中注解  @GeneratedValue id自动增长<br>双向表示双方通过属性.属性能互相访问到 mappedby一方被拥有的一方<br>如果没有mappedby 那么双方都生成了对方的主键 任何一张表都无法插入数据<br>只有其中一方设置 mappedby 它先插入数据 另一张表才能成功插入数据<br><img src="https://viabcde.github.io/images/blog/2018092856.png" alt="enter descriptionhere"><br><strong>在wife.java中注解</strong><br><img src="https://viabcde.github.io/images/blog/2018092857.png" alt="enter descriptionhere"><br>或者<br><strong>xml方式配置</strong><br><img src="https://viabcde.github.io/images/blog/2018092858.png" alt="enter descriptionhere">  </p><h3 id="一对一单向主键关联"><a href="#一对一单向主键关联" class="headerlink" title="一对一单向主键关联"></a><strong>一对一单向主键关联</strong></h3><p><img src="https://viabcde.github.io/images/blog/2018092859.png" alt="enter descriptionhere"><br>或者<br><strong>xml方式配置</strong><br><img src="https://viabcde.github.io/images/blog/2018092860.png" alt="enter descriptionhere"><br>这里的id参考的是 student里的 id</p><h3 id="一对一双向主键关联"><a href="#一对一双向主键关联" class="headerlink" title="一对一双向主键关联"></a><strong>一对一双向主键关联</strong></h3><p><strong>在husband.java设置</strong><br>因为2个表的ID是一致的 所以 不用哪一方先插入数据都可以<br><img src="https://viabcde.github.io/images/blog/2018092861.png" alt="enter descriptionhere"><br><strong>在wife.java设置</strong><br><img src="https://viabcde.github.io/images/blog/2018092862.png" alt="enter descriptionhere"><br>或者<br><strong>xml方式配置</strong><br>在student.xml<br>name=”stuIdCard”中的stuIdCard就是指student中的属性名 ref+””指定由studentIdCard.java中的student属性映射<br><img src="https://viabcde.github.io/images/blog/2018092863.png" alt="enter descriptionhere"><br>在studentIdCard.xml<br><img src="https://viabcde.github.io/images/blog/2018092864.png" alt="enter descriptionhere">  </p><h3 id="一对一单向外键（联合主键）"><a href="#一对一单向外键（联合主键）" class="headerlink" title="一对一单向外键（联合主键）"></a><strong>一对一单向外键（联合主键）</strong></h3><p>编写wifePK.java<br>注意implements Serializable<br>在wife.java加注解<br><img src="https://viabcde.github.io/images/blog/2018092865.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/blog/2018092866.png" alt="enter descriptionhere"><br>在husband.java加注解<br>表示在数据库表中的字段为 wife Id 和wifeName<br><img src="https://viabcde.github.io/images/blog/2018092867.png" alt="enter descriptionhere">  </p><h3 id="组件映射"><a href="#组件映射" class="headerlink" title="组件映射"></a><strong>组件映射</strong></h3><p>只需要在husband配置注解即可把wife作为组件，而wife.java无需修改<br>2个对象组装为一个表  没有对应关系<br><img src="https://viabcde.github.io/images/blog/2018092868.png" alt="enter descriptionhere"><br><strong>xml方式配置</strong><br><img src="https://viabcde.github.io/images/blog/2018092869.png" alt="enter descriptionhere">  </p><h3 id="多对一单向"><a href="#多对一单向" class="headerlink" title="多对一单向"></a><strong>多对一单向</strong></h3><p>在user.java中配置对group.java的多对一关系 在多的一方加Many2one<br><img src="https://viabcde.github.io/images/blog/2018092870.png" alt="enter descriptionhere"><br>或者<br><strong>xml方式配置</strong><br><img src="https://viabcde.github.io/images/blog/2018092871.png" alt="enter descriptionhere">  </p><h3 id="一对多单向关联"><a href="#一对多单向关联" class="headerlink" title="一对多单向关联"></a><strong>一对多单向关联</strong></h3><p>在group.java中配置对user.java的一对多关联即可，user.java不需要配置<br><img src="https://viabcde.github.io/images/blog/2018092872.png" alt="enter descriptionhere"><br>或者<br><strong>xml方式配置</strong><br><img src="https://viabcde.github.io/images/blog/2018092873.png" alt="enter descriptionhere">  </p><h3 id="一对多，多对一双向关联"><a href="#一对多，多对一双向关联" class="headerlink" title="一对多，多对一双向关联"></a><strong>一对多，多对一双向关联</strong></h3><p><img src="https://viabcde.github.io/images/blog/2018092874.png" alt="enter descriptionhere"><br>xml:<br>user.xml<br><img src="https://viabcde.github.io/images/blog/2018092875.png" alt="enter descriptionhere"><br>group.xml<br><img src="https://viabcde.github.io/images/blog/2018092876.png" alt="enter descriptionhere">  </p><h3 id="多对多单向关联"><a href="#多对多单向关联" class="headerlink" title="多对多单向关联"></a><strong>多对多单向关联</strong></h3><p>先建立中间表teacher_student 里面的teacher_id student_id分别参考teacher 和student表的id<br><img src="https://viabcde.github.io/images/blog/2018092877.png" alt="enter descriptionhere"><br>xml<br><img src="https://viabcde.github.io/images/blog/2018092878.png" alt="enter descriptionhere"><br>这里有student的路径：指明teacher里能找到student 而student找不到teacher</p><h3 id="多对多双向关联"><a href="#多对多双向关联" class="headerlink" title="多对多双向关联"></a><strong>多对多双向关联</strong></h3><p>先建立中间表teacher_student 里面的teacher_id student_id分别参考teacher 和student表的id<br><img src="https://viabcde.github.io/images/blog/2018092879.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/blog/2018092880.png" alt="enter descriptionhere"><br>xml<br><img src="https://viabcde.github.io/images/blog/2018092881.png" alt="enter descriptionhere"><br>这里有student的路径：指明teacher里能找到student 而student找不到teacher<br><img src="https://viabcde.github.io/images/blog/2018092882.png" alt="enter descriptionhere">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis接口绑定的实现方式</title>
      <link href="/2018/11/18/2018-11-18-%E6%8E%A5%E5%8F%A3%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/11/18/2018-11-18-%E6%8E%A5%E5%8F%A3%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>一种是通过注解绑定,就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定<br>另外一种就是通过xml里面写SQL来绑定,在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清除缓存</title>
      <link href="/2018/11/18/2018-11-18-%E6%B8%85%E9%99%A4%E7%BC%93%E5%AD%98/"/>
      <url>/2018/11/18/2018-11-18-%E6%B8%85%E9%99%A4%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h3 id="清除缓存session"><a href="#清除缓存session" class="headerlink" title="清除缓存session"></a><strong>清除缓存session</strong></h3><p><img src="https://viabcde.github.io/images/blog/2018092852.png" alt="enter descriptionhere">  </p><h3 id="强制session与数据库做同步：即flush一次相当于commit一次"><a href="#强制session与数据库做同步：即flush一次相当于commit一次" class="headerlink" title="强制session与数据库做同步：即flush一次相当于commit一次"></a><strong>强制session与数据库做同步：即flush一次相当于commit一次</strong></h3><p><img src="https://viabcde.github.io/images/blog/2018092853.png" alt="enter descriptionhere">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sprign的注入方式</title>
      <link href="/2018/11/18/2018-11-18-Sprign%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/11/18/2018-11-18-Sprign%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Spring是一个轻量级的控制反转（IOC）和面向切面（AOP）的容器框架<br>–通过控制反转（IOC）的技术达到松耦合的目的<br>–包含并管理应用对象的配置和生命周期，这个意义上是一种容器。<br>–将简单的组件配置、组合成为复杂的应用，这个意义上是框架<br><strong>控制反转与依赖注入：</strong>Spring是依赖注入的容器 控制反转时指依赖关系的管理由代码转到容器由Spring容器进行依赖注入</p><h2 id="2种常用的注入方式"><a href="#2种常用的注入方式" class="headerlink" title="2种常用的注入方式"></a><strong>2种常用的注入方式</strong></h2><h3 id="设值注入"><a href="#设值注入" class="headerlink" title="设值注入"></a><strong>设值注入</strong></h3><pre><code>&lt;bean id=&quot;injectionService&quot; class=&quot;com.aaa.service.Serviceimpl&quot;&gt;    &lt;property name=&quot;injectionDAO&quot; ref=&quot;injectionDAO&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;injectionDAO&quot; class=&quot;com.aaa.dao.DAOimpl&quot;&gt;&lt;/bean&gt;</code></pre><h3 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a><strong>构造方法注入</strong></h3><pre><code>&lt;bean id=&quot;injectionService&quot; class=&quot;com.aaa.service.Serviceimpl&quot;&gt;    &lt;consructor-arg name=&quot;injectionDAO&quot; ref=&quot;injectionDAO&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;injectionDAO&quot; class=&quot;com.aaa.dao.DAOimpl&quot;&gt;&lt;/bean&gt;</code></pre><h3 id="构造方法注入和设值注入有什么区别？"><a href="#构造方法注入和设值注入有什么区别？" class="headerlink" title="构造方法注入和设值注入有什么区别？"></a><strong>构造方法注入和设值注入有什么区别？</strong></h3><p>请注意以下明显的区别：<br>在设值注入方法支持大部分的依赖注入，对于基本类型，不用设值注入，可以设置默认值。    <strong>在对象创建前调用</strong><br>在构造方法注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。 <strong>在对象创建时调用</strong><br>设值注入是为了解决构造方法注入遇到的<strong>2个对象互相依赖无法注入</strong>的问题</p><h3 id="为impl中的简单属性的注入初始值"><a href="#为impl中的简单属性的注入初始值" class="headerlink" title="为impl中的简单属性的注入初始值"></a><strong>为impl中的简单属性的注入初始值</strong></h3><p><img src="https://viabcde.github.io/images/blog/2018092898.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/blog/2018092899.png" alt="enter descriptionhere">  </p><h3 id="为impl注入集合类"><a href="#为impl注入集合类" class="headerlink" title="为impl注入集合类"></a><strong>为impl注入集合类</strong></h3><p><img src="https://viabcde.github.io/images/blog/20180928105.png" alt="enter descriptionhere">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码执行机制</title>
      <link href="/2018/11/15/2018-11-15-java%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/11/15/2018-11-15-java%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="java代码执行机制"><a href="#java代码执行机制" class="headerlink" title="java代码执行机制"></a><strong>java代码执行机制</strong></h3><p><strong>源代码编译机制</strong><br>第一步：  1.分析和输入到符号表（Parse and Enter）Parse  过程所做的是词法和语法分析 Enter  过程是将符号输入到符号表<br>第二步：将annotation生成附加的代码<br>第三步：语法分析后生产class文件，此时class文件可以放入jvm中执行<br><strong>类加载与执行机制</strong><br>第一步：加载class，标记已加载的class<br>第二步：校验class格式，初始化静态变量和静态方法<br>第三步：当执行main方法时，执行静态变量和方法，若有new 则初始化其他类，在执行该类的方法调用<br>当执行某个class时，先从下往上（Application类加载器委托给它的父类加载器Extension类加载器，然后再委托给Bootstrap类加载器），然后再从上往下判断哪个加载器有该class,有则停止判断，使用该class<br>执行顺序：<br>静态方法等 父类静态，子类静态，main 实例对象的方法块 实例对象的构造方法</p><pre><code>public class Demo{    public int j = 10;    public static int i = 0;  //静态成员    //静态块    用于对静态成员初始化    static    {        i=50;        System.out.println(&quot;1、静态块1...&quot;);    }    //静态块    用于对静态成员初始化    static    {        i=100;        System.out.println(&quot;2、静态块2...&quot;);    }    public Demo()    {        System.out.println(&quot;3、构造方法...&quot;);        j=10;    }        //实例块 在构造方法前执行一般也用于初始化成员变量    {        j=90;        System.out.println(&quot;4、实例块2...&quot;);    }    //实例块 在构造方法前执行一般也用于初始化成员变量    {        j=20;        System.out.println(&quot;5、实例块2...&quot;);    }    public static void main(String args[])    {        System.out.println(&quot;6、main方法开始---i=&quot;+i);        Demo d=new Demo();    }}</code></pre><p>执行结果是1、2、6、4、5、3</p><h3 id="程序执行过程"><a href="#程序执行过程" class="headerlink" title="程序执行过程"></a><strong>程序执行过程</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-27/2018092704.png" alt="enter description here">  </p><h3 id="栈区、堆区、代码区"><a href="#栈区、堆区、代码区" class="headerlink" title="栈区、堆区、代码区"></a><strong>栈区、堆区、代码区</strong></h3><p>方法区：存储class的所有变量及方法等静态数据<br>方法栈：存储各种基本数据对象和自定义对象的引用<br>方法堆：存储所有实例出来的对象的内存  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 代码执行机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化与反序列化</title>
      <link href="/2018/11/15/2018-11-15-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2018/11/15/2018-11-15-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="实体类实现序列化"><a href="#实体类实现序列化" class="headerlink" title="实体类实现序列化"></a><strong>实体类实现序列化</strong></h3><p>需要比较是否已有重复的数据<br>先比较首地址是否相同(hashcode)   相同不能存入<br>不同再比较内容是否相同（equals）<br><strong>序列化</strong> (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。<br>一般将一个对象存储至一个储存媒介，例如档案或是记亿体缓冲等。<br>在网络传输过程中，可以是字节或是XML等格式。<br><strong>反序列化</strong>：由字节的或XML编码格式可以还原完全相等的对象。   </p><h3 id="为什么使用序列化"><a href="#为什么使用序列化" class="headerlink" title="为什么使用序列化"></a><strong>为什么使用序列化</strong></h3><p>在Java中，可多种方式来创建对象，只要对象没被回收都可以复用它。<br>这些Java对象都是存在于JVM的堆内存中，只有JVM处于运行状态的时候，这些对象才可能存在。一旦JVM停止运行，这些对象的状态也就随之而丢失了。<br>在真实的应用场景中，需要将对象持久化，在需要时把对象重新读取出来。Java的对象序列化可实现该功能。</p><h3 id="重写equals方法时为什么要同时重写Hashcode方法"><a href="#重写equals方法时为什么要同时重写Hashcode方法" class="headerlink" title="重写equals方法时为什么要同时重写Hashcode方法"></a><strong>重写equals方法时为什么要同时重写Hashcode方法</strong></h3><p>首先equals与hashcode间的关系是这样的：<br>如果两个对象相同（即用equals比较返回true），那么它们的hashCode值必定要相同，但hashCode相同的不一定equals；</p><p>为了提高程序的效率才实现了hashcode方法，先进行hashcode的比较，如果不同，那没必要再进行equals的比较了，这样就大大减少了equals比较的次数，这对比需要比较的数量很大的效率提高是很明显的，一个很好的例子就是在集合中的使用；</p><p>我们都知道java中的List集合是有序的，因此是可以重复的，而set集合是无序的，因此是不能重复的，那么怎么能保证不能被放入重复的元素呢，但靠equals方法一样比较的话，如果原来集合中以后又10000个元素了，那么放入10001个元素，难道要将前面的所有元素都进行比较，看看是否有重复，欧码噶的，这个效率可想而知，因此hashcode就应遇而生了，java就采用了hash表，利用哈希算法（也叫散列算法），就是将对象数据根据该对象的特征使用特定的算法将其定义到一个地址上，那么在后面定义进来的数据只要看对应的hashcode地址上是否有值，那么就用equals比较，如果没有则直接插入，只要就大大减少了equals的使用次数，执行效率就大大提高了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot多环境配置数据库地址，服务器端口等</title>
      <link href="/2018/11/14/2018-11-14-SpringBoot%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/11/14/2018-11-14-SpringBoot%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="多环境配置数据库地址，服务器端口等"><a href="#多环境配置数据库地址，服务器端口等" class="headerlink" title="多环境配置数据库地址，服务器端口等"></a><strong>多环境配置数据库地址，服务器端口等</strong></h3><p>通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容    </p><h2 id="配置文件名称的格式"><a href="#配置文件名称的格式" class="headerlink" title="配置文件名称的格式"></a><strong>配置文件名称的格式</strong></h2><p>在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式，其中{profile}对应环境，比如：<br>application-dev.properties：开发环境<br>application-test.properties：测试环境<br>application-prod.properties：生产环境<br>至于哪个配置文件会被加载，在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值。<br>如：spring.profiles.active=test就会加载application-test.properties配置文件内容<br>下面，以不同环境配置不同的服务端口为例，进行样例实验。<br>针对各环境新建不同的配置文件application-dev.properties、application-test.properties、application-prod.properties<br>在这三个文件均都设置不同的server.port属性，如：dev环境设置为1111，test环境设置为2222，prod环境设置为3333<br>application.properties中设置spring.profiles.active=dev，就是说默认以dev环境设置  </p><h3 id="测试不同配置的加载"><a href="#测试不同配置的加载" class="headerlink" title="测试不同配置的加载"></a><strong>测试不同配置的加载</strong></h3><p>执行java -jar xxx.jar，可以观察到服务端口被设置为1111，也就是默认的开发环境（dev）<br><strong>执行java -jar xxx.jar    –spring.profiles.active=test</strong>可以观察到服务端口被设置为2222，也就是测试环境的配置（test）<br><strong>执行java -jar xxx.jar –spring.profiles.active=prod</strong>可以观察到服务端口被设置为3333，也就是生产环境的配置（prod）<br>按照上面的实验，可以如下总结多环境的配置思路：<br>application.properties中配置通用内容，并设置spring.profiles.active=dev，以开发环境为默认配置<br>application-{profile}.properties中配置各个环境不同的内容<br>通过命令行方式去激活不同环境的配置  </p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Random</title>
      <link href="/2018/11/14/2018-11-14-random/"/>
      <url>/2018/11/14/2018-11-14-random/</url>
      
        <content type="html"><![CDATA[<h3 id="random"><a href="#random" class="headerlink" title="random"></a><strong>random</strong></h3><p>第一种：<br>需要说明的是：你在创建一个Random对象的时候可以给定任意一个合法的种子数，种子数只是随机算法的起源数字，和生成的随机数的区间没有任何关系。如下面的Java代码：  </p><pre><code>Random rand =new Random(25);int i;i=rand.nextInt(100);</code></pre><p>初始化时25并没有起直接作用（注意：不是没有起作用）,rand.nextInt(100);中的100是随机数的上限,产生的随机数为0-100的整数,不包括100。<br>第二种：<br>调用这个Math.Random()函数能够返回带正号的double值，该值大于等于0.0且小于1.0，即取值范围是[0.0,1.0)的左闭右开区间  </p><pre><code> System.out.println(&quot;Math.random()=&quot; + Math.random());// 结果是个double类型的值，区间为[0.0,1.0）            int num = (int) (Math.random()* 10); // 注意不要写成(int)Math.random()*3，这个结果为0，因为先执行了强制转换            System.out.println(&quot;num=&quot; + num);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot 热部署的两种方式</title>
      <link href="/2018/11/14/2018-11-14-springboot%20%E7%83%AD%E9%83%A8%E7%BD%B2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/11/14/2018-11-14-springboot%20%E7%83%AD%E9%83%A8%E7%BD%B2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="springboot-热部署的两种方式"><a href="#springboot-热部署的两种方式" class="headerlink" title="springboot 热部署的两种方式"></a><strong>springboot 热部署的两种方式</strong></h2><h3 id="第一种：使用spring-boot-run"><a href="#第一种：使用spring-boot-run" class="headerlink" title="第一种：使用spring-boot:run"></a><strong>第一种：使用spring-boot:run</strong></h3><p><strong>在pom.xml文件添加依赖包</strong>  </p><pre><code>&lt;plugin&gt;                      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                      &lt;artifactId&gt;spring-boot-maven-plugin &lt;/artifactId&gt;                      &lt;dependencies&gt;                         &lt;!--springloaded  hot deploy --&gt;                         &lt;dependency&gt;                             &lt;groupId&gt;org.springframework&lt;/groupId&gt;                             &lt;artifactId&gt;springloaded&lt;/artifactId&gt;                             &lt;version&gt;1.2.4.RELEASE&lt;/version&gt;                       &lt;/dependency&gt;                      &lt;/dependencies&gt;                      &lt;executions&gt;                         &lt;execution&gt;                             &lt;goals&gt;                                 &lt;goal&gt;repackage&lt;/goal&gt;                             &lt;/goals&gt;                             &lt;configuration&gt;                                 &lt;classifier&gt;exec&lt;/classifier&gt;                             &lt;/configuration&gt;                         &lt;/execution&gt;                         &lt;/executions&gt;                &lt;/plugin&gt;</code></pre><p><strong>PS</strong><br>如果使用的run as – java application，还需要做一些处理:<br>把spring-loader-1.2.4.RELEASE.jar下载下来，放到项目的lib目录中<br>然后把IDEA的run参数里VM参数设置为： -javaagent:.\lib\springloaded-1.2.4.RELEASE.jar -noverify 然后启动就可以了<br>这样在run as的时候，也能进行热部署      </p><h3 id="第二种：springboot-devtools（热部署）"><a href="#第二种：springboot-devtools（热部署）" class="headerlink" title="第二种：springboot + devtools（热部署）"></a><strong>第二种：springboot + devtools（热部署）</strong></h3><p>问题的提出： 通过使用springloaded进行热部署，但是一些代码修改了，并不会进行热部署。<br>spring-boot-devtools<br>spring-boot-devtools 自动应用代码更改到最新的App上面去。<br><strong>原理:</strong><br>发现代码有更改后重新启动应用，但是速度比手动停止后再启动还要更快，更快指的不是节省出来的手工操作的时间。<br><strong>其深层原理是</strong>使用了两个ClassLoader，一个Classloader加载那些不会改变的类（第三方Jar包），另一个ClassLoader加载会更改的类，称为 restart ClassLoader  ,在代码更改时，原来的restart ClassLoader 被丢弃，重新创建一个restart ClassLoader，由于需要加载的类相比较少，所以实现了较快的重启时间（5秒以内）。<br><strong>1、添加依赖包：</strong>  </p><pre><code>&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;&lt;!-- optional=true,依赖不会传递，该项目依赖devtools；之后依赖myboot项目的项目如果想要使用devtools，需要重新引入 --&gt;              &lt;scope&gt;true&lt;/scope&gt;&lt;/dependency&gt;</code></pre><p><strong>2、添加spring-boot-maven-plugin：</strong>  </p><pre><code>&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;fork&gt;true&lt;/fork&gt;     &lt;!--fork :  如果没有该项配置，肯呢个devtools不会起作用，即应用不会restart --&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p><strong>测试方法</strong><br>修改类–&gt;保存：应用会重启<br>修改配置文件–&gt;保存：应用会重启<br>修改页面–&gt;保存：应用会重启，页面会刷新（原理是将spring.thymeleaf.cache设为false）<br><strong>遇到的问题</strong><br>对应的spring-boot版本是否正确，这里使用的是1.4.1版本；<br>是否加入plugin以及属性true<br>Eclipse Project 是否开启了Build Automatically（我自己就在这里栽了坑，不知道为什么我的工具什么时候关闭了自动编译的功能）。<br>如果设置SpringApplication.setRegisterShutdownHook(false)，则自动重启将不起作用。      </p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql</title>
      <link href="/2018/11/14/2018-11-14-mysql/"/>
      <url>/2018/11/14/2018-11-14-mysql/</url>
      
        <content type="html"><![CDATA[<h3 id="传汉字到mysql数据库，显示问号的解决方法"><a href="#传汉字到mysql数据库，显示问号的解决方法" class="headerlink" title="传汉字到mysql数据库，显示问号的解决方法"></a><strong>传汉字到mysql数据库，显示问号的解决方法</strong></h3><p>1、检查jsp显示页面，检查jsp开头有没有设置UTF-8的字符集</p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</code></pre><p>2、检查后台逻辑代<br>根据前台展示页面，找到后台代码，<br>一般设置编码有如下几种方式：<br>设置request</p><pre><code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code></pre><p>设置response</p><pre><code>response.setCharacterEncoding(&quot;UTF-8&quot;);response.setContentType(&quot;text/html;charset=UTF-8&quot;);response.setHeader(&quot;Content-Type&quot;,&quot;text/html;charset=UTF-8&quot;);</code></pre><p>3、检查数据库字符集<br>mysql中可以设置数据库字符集，<br><img src="https://viabcde.github.io/images/2018-10-10/2018101001.png" alt="duotai"><br>也可以设置表的字符集<br><img src="https://viabcde.github.io/images/2018-10-10/2018101002.png" alt="duotai"><br>4、变更数据库URL<br>在连接数据库的URL属性中添加useUnicode=true&amp;characterEncoding=utf8<br>我直接添加的characterEncoding=utf8<br>最终解决了我的中文乱码问题</p><h3 id="mysql启动正常但是访问时还是报错：-ERROR-2003-HY000-Can’t-connect-to-MySQL-server-on-‘localhost’-10061"><a href="#mysql启动正常但是访问时还是报错：-ERROR-2003-HY000-Can’t-connect-to-MySQL-server-on-‘localhost’-10061" class="headerlink" title="mysql启动正常但是访问时还是报错： ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost’ (10061"></a><strong>mysql启动正常但是访问时还是报错： ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost’ (10061</strong></h3><p>mysql以管理员身份在cmd命令行启动<br>net start mysql —&gt;启动成功<br>右键计算机 服务 启动 mysql 成功<br>但是就是在 执行 mysql -uroot -p 是报错，错误如下<br>报错：win7 ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost’ (10061<br>后来发现原来是自己host文件里面，localhost 没有指向：127.0.0.1<br>修改host文件，mysql成功连接  </p><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a><strong>mysql</strong></h3><p>net start mysql<br>cmd 切换到指定路径：比如切换到D盘  直接输入D：即可 然后输入指定目录如：D:\java\mysql-5.7.24-winx64\bin<br>cd mysql bin目录(C:\Program Files\MySQL\MySQL Server 5.1\bin)<br>mysql -u root -p<br>输入密码<br>Source e:/library.sql;<br>Show databases;<br>Use library;<br>Show tables;   </p><h3 id="查看数据库的隔离级别"><a href="#查看数据库的隔离级别" class="headerlink" title="查看数据库的隔离级别"></a><strong>查看数据库的隔离级别</strong></h3><pre><code>mysql&gt; show global variables like &#39;tx_isolation&#39;;</code></pre><h3 id="AUTO-INCREMENT-42"><a href="#AUTO-INCREMENT-42" class="headerlink" title="AUTO_INCREMENT=42"></a><strong>AUTO_INCREMENT=42</strong></h3><p>指定序号的初始值为42，即从42开始递增</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git遇到的问题</title>
      <link href="/2018/11/14/2018-11-14-git%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2018/11/14/2018-11-14-git%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="在push到github的时候出现身份验证失败的问题的解决"><a href="#在push到github的时候出现身份验证失败的问题的解决" class="headerlink" title="在push到github的时候出现身份验证失败的问题的解决"></a>在push到github的时候出现身份验证失败的问题的解决</h3><p>问题：<br>Authentication failed. You may not have permission to access the repository or the repository may have been archived. Open options and verify that you’re signed in with an account that has permission to access this repository.<br>翻译：身份验证失败。您可能没有访问存储库的权限，或者存储库可能已经存档。打开选项，并验证您已与具有访问此存储库权限的帐户进行了签名。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>复制地址：<br><img src="https://viabcde.github.io/images/all/2018092904.png" alt="enter descriptionhere"><br>到githubDesktop设置仓库地址<br><img src="https://viabcde.github.io/images/all/2018092905.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/all/2018092906.png" alt="enter descriptionhere"></p><h3 id="git-add时遇到的LF和CRLF问题"><a href="#git-add时遇到的LF和CRLF问题" class="headerlink" title="git add时遇到的LF和CRLF问题"></a><strong>git add时遇到的LF和CRLF问题</strong></h3><p>windows是CRLF即回车<br>Linux是LF即换行<br>在winows提交时会自动替换回车为换行  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例</title>
      <link href="/2018/11/14/2018-11-14-%E5%8D%95%E4%BE%8B/"/>
      <url>/2018/11/14/2018-11-14-%E5%8D%95%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>单例：</strong> 用map实现 而且map查找比链表方便  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO流</title>
      <link href="/2018/11/14/2018-11-14-IO%E6%B5%81/"/>
      <url>/2018/11/14/2018-11-14-IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h3 id="字节流与字符流"><a href="#字节流与字符流" class="headerlink" title="字节流与字符流"></a><strong>字节流与字符流</strong></h3><p>字节流可以读取所有类型的文件<br>而字符流无法读取二进制文件</p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a><strong>字节流</strong></h2><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a><strong>InputStream</strong></h3><p>InputStream读取控制台输入<br>BufferedReader缓冲区存放InputStream读取的内容<br>由BufferedReader输出内容</p><pre><code>  public static void main(String args[]) {    InputStreamReader isr = new InputStreamReader(System.in);    BufferedReader br = new BufferedReader(isr);    String s = null;    try {      s = br.readLine();      while(s!=null){        if(s.equalsIgnoreCase(&quot;exit&quot;)) break;        s = br.readLine();      }      br.close();    } catch (IOException e) {      e.printStackTrace();    }  }</code></pre><h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a><strong>OutputStream</strong></h3><p>FileOutputStream外部包裹一层OutputStreamWriter<br>由OutputStreamWriter来写出</p><pre><code>  public static void main(String[] args) {    try {      OutputStreamWriter osw = new OutputStreamWriter(           new FileOutputStream(&quot;d:\\bak\\char.txt&quot;));      osw.write(&quot;mircosoftibmsunapplehp&quot;);      osw.close();      osw = new OutputStreamWriter(new FileOutputStream(&quot;d:\\bak\\char.txt&quot;, true),&quot;ISO8859_1&quot;); // latin-1      osw.write(&quot;mircosoftibmsunapplehp&quot;);      osw.close();    } catch (IOException e) {      e.printStackTrace();    }  }</code></pre><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a><strong>字符流</strong></h2><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a><strong>FileReader</strong></h3><p>直接FileReader读取即可</p><pre><code>  public static void main(String[] args) {    FileReader fr = null;     int c = 0;    try {      fr = new FileReader(&quot;d:\\share\\java\\io\\TestFileReader.java&quot;);      int ln = 0;      while ((c = fr.read()) != -1) {        //char ch = (char) fr.read();        System.out.print((char)c);        //if (++ln &gt;= 100) { System.out.println(); ln = 0;}      }      fr.close();    } catch (FileNotFoundException e) {      System.out.println(&quot;找不到指定文件&quot;);    } catch (IOException e) {      System.out.println(&quot;文件读取错误&quot;);    }  }</code></pre><h3 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a><strong>FileWriter</strong></h3><p>直接FileWriter写入文件即可</p><pre><code>    public static void main(String[] args) {    FileWriter fw = null;    try {      fw = new FileWriter(&quot;d:\\bak\\unicode.dat&quot;);      for(int c=0;c&lt;=50000;c++){        fw.write(c);      }      fw.close();    } catch (IOException e1) {        e1.printStackTrace();      System.out.println(&quot;文件写入错误&quot;);      System.exit(-1);    }  }</code></pre><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a><strong>文件</strong></h2><pre><code>public class FileDemo {  public static void main(String[] args) {         //检查文件是否存在        File file = new File( &quot;d:/test.txt&quot;);         boolean fileExists = file.exists();        System. out.println( fileExists);         //创建文件目录,若父目录不存在则返回false        File file2 = new File( &quot;d:/fatherDir/subDir&quot;);         boolean dirCreated = file2.mkdir();        System. out.println( dirCreated);         //创建文件目录,若父目录不存则连同父目录一起创建        File file3 = new File( &quot;d:/fatherDir/subDir2&quot;);         boolean dirCreated2 = file3.mkdirs();        System. out.println( dirCreated2);        File file4= new File( &quot;d:/test.txt&quot;);         //判断长度         long length = file4.length();         //重命名文件         boolean isRenamed = file4.renameTo( new File(&quot;d:/test2.txt&quot;));         //删除文件         boolean isDeleted = file4.delete();        File file5= new File( &quot;d:/fatherDir/subDir&quot;);         //是否是目录         boolean isDirectory = file5.isDirectory();         //列出文件名        String[] fileNames = file5.list();         //列出目录        File[]   files = file4.listFiles();  }</code></pre><h3 id="IO与NIO"><a href="#IO与NIO" class="headerlink" title="IO与NIO"></a><strong>IO与NIO</strong></h3><p>java IO 是面向流的，只有等待流中数据读完才能继续写，除非使用缓冲区<br>java NIO是面向块的，可以动态移动缓冲区中的数据，在读的同时可以写<br>前者一个连接由一个线程处理，后者是多个连接由一个线程处理（更适合一台计算机连接多个网络设备的网络环境）  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置文件（一）</title>
      <link href="/2018/11/14/2018-11-14-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2018/11/14/2018-11-14-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="编译不互相依赖"><a href="#编译不互相依赖" class="headerlink" title="编译不互相依赖"></a><strong>编译不互相依赖</strong></h2><p>即一个程序在编译成class时不需要等另外一个程序编译完成才能继续编译  运行时才互相调用  </p><h3 id="第一代解决方案：-使用反射解决编译级别依赖"><a href="#第一代解决方案：-使用反射解决编译级别依赖" class="headerlink" title="第一代解决方案： 使用反射解决编译级别依赖"></a><strong>第一代解决方案：</strong> 使用反射解决编译级别依赖</h3><p><strong>注意：</strong>虽然编译时没报错，但运行时真正去调用的时候如果找不到相应的class就会报错。<br><strong>缺点：</strong>当更换所依赖的程序时必须停止服务器找到源码更换后还需要把整个项目再重新编译一次<br><strong>改进：</strong> 用配置文件 通过读取配置文件来进行反射 不用改源码重新编译<br><strong>使用类加载器读取文件的原因：</strong>第二种使用流读取，在web发布时没有src目录，不可取。 第一种使用Resourcebundle，类加载器只要文件放在类路径下的文件都能读取（且这种方式只能读取properties文件）  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot核心组件</title>
      <link href="/2018/11/14/2018-11-14-SpringBoot%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
      <url>/2018/11/14/2018-11-14-SpringBoot%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="核心组件starter"><a href="#核心组件starter" class="headerlink" title="核心组件starter"></a><strong>核心组件starter</strong></h3><p>Starter主要用来简化依赖用的。比如我们之前做 MVC时要引入日志组件，那么需要去找到log4j的版本，然后引入，现在有了Starter之后，直接用这个之后，log4j就自动引入了，也不用关心版本这些问题。  </p><h3 id="核心组件actuator"><a href="#核心组件actuator" class="headerlink" title="核心组件actuator"></a><strong>核心组件actuator</strong></h3><p>即<strong>spring-boot-starter-actuator</strong>，主要作用是<strong>监控与管理</strong></p><pre><code>&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>模块解析</strong><br><strong>包含以下三个类：</strong><br><strong>应用配置类：</strong>应用配置、环境变量、自动化配置报告等<br><strong>度量指标类：</strong>内存信息、线程池信息、HTTP请求统计等<br><strong>操作控制类：</strong>提供了对应用的关闭等操作类功能  </p><h1 id="应用配置类"><a href="#应用配置类" class="headerlink" title="应用配置类"></a><strong>应用配置类</strong></h1><h2 id="autoconfig"><a href="#autoconfig" class="headerlink" title="/autoconfig"></a><strong>/autoconfig</strong></h2><p><strong>使用场景：</strong>帮助找到自动化配置为什么没有生效的具体原因。<br><strong>该报告内容将自动化配置内容分为两部分：</strong><br>positiveMatches中返回的是条件匹配成功的自动化配置<br>negativeMatches中返回的是条件匹配不成功的自动化配置     </p><pre><code>{    &quot;positiveMatches&quot;: { // 条件匹配成功的        &quot;EndpointWebMvcAutoConfiguration&quot;: [            {                &quot;condition&quot;: &quot;OnClassCondition&quot;,                &quot;message&quot;: &quot;@ConditionalOnClass classes found: javax.servlet.Servlet,org.springframework.web.servlet.DispatcherServlet&quot;            },            {                &quot;condition&quot;: &quot;OnWebApplicationCondition&quot;,                &quot;message&quot;: &quot;found web application StandardServletEnvironment&quot;            }        ],        ...    },    &quot;negativeMatches&quot;: {  // 条件不匹配成功的        &quot;HealthIndicatorAutoConfiguration.DataSourcesHealthIndicatorConfiguration&quot;: [            {                &quot;condition&quot;: &quot;OnClassCondition&quot;,                &quot;message&quot;: &quot;required @ConditionalOnClass classes not found: org.springframework.jdbc.core.JdbcTemplate&quot;            }        ],        ...    }}</code></pre><p>每个自动化配置候选项中都有一系列的条件，比如上面没有成功匹配的HealthIndicatorAutoConfiguration.DataSourcesHealthIndicatorConfiguration配置。<br>它的先决条件就是需要在工程中包含org.springframework.jdbc.core.JdbcTemplate类，由于没有引入相关的依赖，它就不会执行自动化配置内容。  所以，当发现有一些配置没有生效时，就可以通过该端点来查看没有生效的原因。    </p><h2 id="beans"><a href="#beans" class="headerlink" title="/beans"></a><strong>/beans</strong></h2><p><strong>作用：</strong>该端点用来获取应用上下文中创建的所有Bean  </p><pre><code>[    {        &quot;context&quot;: &quot;hello:dev:8881&quot;,        &quot;parent&quot;: null,        &quot;beans&quot;: [            {                &quot;bean&quot;: &quot;org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration$DispatcherServletConfiguration&quot;,                &quot;scope&quot;: &quot;singleton&quot;,                &quot;type&quot;: &quot;org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration$DispatcherServletConfiguration$$EnhancerBySpringCGLIB$$3440282b&quot;,                &quot;resource&quot;: &quot;null&quot;,                &quot;dependencies&quot;: [                    &quot;serverProperties&quot;,                    &quot;spring.mvc.CONFIGURATION_PROPERTIES&quot;,                    &quot;multipartConfigElement&quot;                ]            },            {                &quot;bean&quot;: &quot;dispatcherServlet&quot;,                &quot;scope&quot;: &quot;singleton&quot;,                &quot;type&quot;: &quot;org.springframework.web.servlet.DispatcherServlet&quot;,                &quot;resource&quot;: &quot;class path resource [org/springframework/boot/autoconfigure/web/DispatcherServletAutoConfiguration$DispatcherServletConfiguration.class]&quot;,                &quot;dependencies&quot;: []            }        ]    }]</code></pre><p>如上示例中，可以看到每个bean都包含了下面这几个信息：<br>bean：Bean的名称<br>scope：Bean的作用域<br>type：Bean的Java类型<br>reource：class文件的具体路径<br>dependencies：依赖的Bean名称  </p><h3 id="configprops"><a href="#configprops" class="headerlink" title="/configprops"></a><strong>/configprops</strong></h3><p><strong>作用：</strong>用来获取应用中配置的属性信息报告。<br>从下面该端点返回示例片段中，返回了关于该短信的配置信息：<br>prefix属性代表了属性的配置前缀<br>properties代表了各个属性的名称和值<br>所以，我们可以通过该报告来看到各个属性的配置路径，比如我们要关闭该端点，就可以通过使用endpoints.configprops.enabled=false来完成设置</p><pre><code>{    &quot;configurationPropertiesReportEndpoint&quot;: {        &quot;prefix&quot;: &quot;endpoints.configprops&quot;,        &quot;properties&quot;: {            &quot;id&quot;: &quot;configprops&quot;,            &quot;sensitive&quot;: true,            &quot;enabled&quot;: true        }    },    ...}</code></pre><h3 id="env"><a href="#env" class="headerlink" title="/env"></a><strong>/env</strong></h3><p><strong>作用：</strong>该端点与/configprops不同，它用来获取应用所有可用的环境属性报告。包括：环境变量、JVM属性、应用的配置配置、命令行中的参数<br>从下面该端点返回的示例片段中，可以看到它不仅返回了应用的配置属性，还返回了系统属性、环境变量等丰富的配置信息，其中也包括了应用还没有没有使用的配置。<br><strong>用途：</strong>帮助看当前应用可以加载的配置信息，并配合@ConfigurationProperties将它们引入到应用来使用。<br>为了配置属性的安全，对于一些类似密码等敏感信息，该端点都会进行隐私保护，但是需要让属性名中包含：password、secret、key这些关键词，这样该端点在返回它们的时候会使用” *  “来替代实际的属性值</p><pre><code>{    &quot;profiles&quot;: [        &quot;dev&quot;    ],    &quot;server.ports&quot;: {        &quot;local.server.port&quot;: 8881    },    &quot;servletContextInitParams&quot;: {    },    &quot;systemProperties&quot;: {        &quot;idea.version&quot;: &quot;2016.1.3&quot;,        &quot;java.runtime.name&quot;: &quot;Java(TM) SE Runtime Environment&quot;,        &quot;sun.boot.library.path&quot;: &quot;C:\\Program Files\\Java\\jdk1.8.0_91\\jre\\bin&quot;,        &quot;java.vm.version&quot;: &quot;25.91-b15&quot;,        &quot;java.vm.vendor&quot;: &quot;Oracle Corporation&quot;,        ...    },    &quot;systemEnvironment&quot;: {        &quot;configsetroot&quot;: &quot;C:\\WINDOWS\\ConfigSetRoot&quot;,        &quot;RABBITMQ_BASE&quot;: &quot;E:\\tools\\rabbitmq&quot;,        ...    },    &quot;applicationConfig: [classpath:/application-dev.properties]&quot;: {        &quot;server.port&quot;: &quot;8881&quot;    },    &quot;applicationConfig: [classpath:/application.properties]&quot;: {        &quot;server.port&quot;: &quot;8885&quot;,        &quot;spring.profiles.active&quot;: &quot;dev&quot;,        &quot;info.app.name&quot;: &quot;spring-boot-hello&quot;,        &quot;info.app.version&quot;: &quot;v1.0.0&quot;,        &quot;spring.application.name&quot;: &quot;hello&quot;    }}</code></pre><h3 id="mappings"><a href="#mappings" class="headerlink" title="/mappings"></a><strong>/mappings</strong></h3><p><strong>作用：</strong>该端点用来返回所有Spring MVC的控制器映射关系报告<br>从下面的示例片段中，可以看该报告的信息<br>与我们在启用Spring MVC的Web应用时输出的日志信息类似，其中bean属性标识了该映射关系的请求处理器，method属性标识了该映射关系的具体处理类和处理函数  </p><pre><code>{    &quot;/webjars/**&quot;: {        &quot;bean&quot;: &quot;resourceHandlerMapping&quot;    },    &quot;/**&quot;: {        &quot;bean&quot;: &quot;resourceHandlerMapping&quot;    },    &quot;/**/favicon.ico&quot;: {        &quot;bean&quot;: &quot;faviconHandlerMapping&quot;    },    &quot;{[/hello]}&quot;: {        &quot;bean&quot;: &quot;requestMappingHandlerMapping&quot;,        &quot;method&quot;: &quot;public java.lang.String com.didispace.web.HelloController.index()&quot;    },    &quot;{[/mappings || /mappings.json],methods=[GET],produces=[application/json]}&quot;: {        &quot;bean&quot;: &quot;endpointHandlerMapping&quot;,        &quot;method&quot;: &quot;public java.lang.Object org.springframework.boot.actuate.endpoint.mvc.EndpointMvcAdapter.invoke()&quot;    },    ...}</code></pre><h3 id="info"><a href="#info" class="headerlink" title="/info"></a><strong>/info</strong></h3><p><strong>作用：</strong>用来返回应用自定义的信息。默认情况下，该端点只会返回一个空的json内容。我们可以在application.properties配置文件中通过info前缀来设置一些属性，比如下面这样：  </p><p>info.app.name=spring-boot-hello<br>info.app.version=v1.0.0<br>再访问/info端点，我们可以得到下面的返回报告，其中就包含了上面我们在应用自定义的两个参数。  </p><pre><code>{    &quot;app&quot;: {        &quot;name&quot;: &quot;spring-boot-hello&quot;,        &quot;version&quot;: &quot;v1.0.0&quot;    }}</code></pre><h2 id="度量指标类"><a href="#度量指标类" class="headerlink" title="度量指标类"></a><strong>度量指标类</strong></h2><p>应用配置类端点所提供的信息报告在应用启动时都已经确定了其返回内容，是一个静态报告。<br>而度量指标类端点提供的报告内容则是动态变化的，这些端点提供了应用程序运行中的信息<br>比如：内存使用情况、HTTP请求统计、外部资源指标等。<br>这些端点对于我们构建微服务架构中的监控系统非常有帮助，由于Spring Boot应用自身实现了这些端点，所以可以利用它们来收集想要的信息，以制定出各种自动化策略。    </p><h3 id="metrics"><a href="#metrics" class="headerlink" title="/metrics"></a><strong>/metrics</strong></h3><p><strong>作用：</strong>该端点用来返回当前应用的比如：内存信息、线程信息、垃圾回收信息等</p><pre><code>{  &quot;mem&quot;: 541305,  &quot;mem.free&quot;: 317864,  &quot;processors&quot;: 8,  &quot;instance.uptime&quot;: 33376471,  &quot;uptime&quot;: 33385352,  &quot;systemload.average&quot;: -1,  &quot;heap.committed&quot;: 476672,  &quot;heap.init&quot;: 262144,  &quot;heap.used&quot;: 158807,  &quot;heap&quot;: 3701248,  &quot;nonheap.committed&quot;: 65856,  &quot;nonheap.init&quot;: 2496,  &quot;nonheap.used&quot;: 64633,  &quot;nonheap&quot;: 0,  &quot;threads.peak&quot;: 22,  &quot;threads.daemon&quot;: 20,  &quot;threads.totalStarted&quot;: 26,  &quot;threads&quot;: 22,  &quot;classes&quot;: 7669,  &quot;classes.loaded&quot;: 7669,  &quot;classes.unloaded&quot;: 0,  &quot;gc.ps_scavenge.count&quot;: 7,  &quot;gc.ps_scavenge.time&quot;: 118,  &quot;gc.ps_marksweep.count&quot;: 2,  &quot;gc.ps_marksweep.time&quot;: 234,  &quot;httpsessions.max&quot;: -1,  &quot;httpsessions.active&quot;: 0,  &quot;gauge.response.beans&quot;: 55,  &quot;gauge.response.env&quot;: 10,  &quot;gauge.response.hello&quot;: 5,  &quot;gauge.response.metrics&quot;: 4,  &quot;gauge.response.configprops&quot;: 153,  &quot;gauge.response.star-star&quot;: 5,  &quot;counter.status.200.beans&quot;: 1,  &quot;counter.status.200.metrics&quot;: 3,  &quot;counter.status.200.configprops&quot;: 1,  &quot;counter.status.404.star-star&quot;: 2,  &quot;counter.status.200.hello&quot;: 11,  &quot;counter.status.200.env&quot;: 1}</code></pre><p>从上面的示例中，有这些重要的度量值：<br>系统信息：包括处理器数量processors、运行时间uptime和instance.uptime、系统平均负载systemload.average<br>mem. <em> ：内存概要信息，包括分配给应用的总内存数量以及当前空闲的内存数量。这些信息来自java.lang.Runtime<br>heap.</em> ：堆内存使用情况。来自java.lang.management.MemoryMXBean接口中getHeapMemoryUsage方法获取的java.lang.management.MemoryUsage。<br>nonheap.<em> ：非堆内存使用情况。来自java.lang.management.MemoryMXBean接口中getNonHeapMemoryUsage方法获取的java.lang.management.MemoryUsage。<br>threads.</em> ： 线程使用情况，包括线程数、守护线程数（daemon）、线程峰值（peak）等，这些数据均来自java.lang.management.ThreadMXBean。<br>classes.<em> ：应用加载和卸载的类统计。这些数据均来自java.lang.management.ClassLoadingMXBean。<br>gc.</em> ：垃圾收集器的详细信息，包括垃圾回收次数gc.ps_scavenge.count、垃圾回收消耗时间gc.ps_scavenge.time、标记-清除算法的次数gc.ps_marksweep.count、标记-清除算法的消耗时间gc.ps_marksweep.time。这些数据均来自java.lang.management.GarbageCollectorMXBean。<br>httpsessions.<em> ：Tomcat容器的会话使用情况。包括最大会话数httpsessions.max和活跃会话数httpsessions.active。该度量指标信息仅在引入了嵌入式Tomcat作为应用容器的时候才会提供。<br>gauge.</em> ：HTTP请求的性能指标之一，它主要用来反映一个绝对数值。比如上面示例中的gauge.response.hello: 5，它表示上一次hello请求的延迟时间为5毫秒。<br>counter.<em> ：HTTP请求的性能指标之一，它主要作为计数器来使用，记录了增加量和减少量。如上示例中counter.status.200.hello: 11，它代表了hello请求返回200状态的次数为11。<br>对于gauge.</em> 和counter.* 的统计，这里有一个特殊的内容请求star-star，它代表了对静态资源的访问。这两类度量指标非常有用，我们不仅可以使用它默认的统计指标，还可以在程序中轻松的增加自定义统计值。只需要通过注入org.springframework.boot.actuate.metrics.CounterService和org.springframework.boot.actuate.metrics.GaugeService来实现自定义的统计指标信息。比如：我们可以像下面这样自定义实现对hello接口的访问次数统计。    </p><pre><code>@RestControllerpublic class HelloController {    @Autowired    private CounterService counterService;    @RequestMapping(&quot;/hello&quot;)    public String greet() {        counterService.increment(&quot;didispace.hello.count&quot;);        return &quot;&quot;;    }}</code></pre><h3 id="metrics-1"><a href="#metrics-1" class="headerlink" title="/metrics"></a><strong>/metrics</strong></h3><p><strong>作用：</strong>提供应用运行状态的完整度量指标报告，对于监控系统中的各项监控功能，它们的监控内容、数据收集频率都不同，如果我们每次都通过全量获取报告的方式来收集，略显粗暴。所以，我们还可以通过/metrics/{name}接口来更细粒度的获取度量信息，比如我们可以通过访问/metrics/mem.free来获取当前可用内存数量。  </p><h3 id="health"><a href="#health" class="headerlink" title="/health"></a><strong>/health</strong></h3><p>用来获取应用的各类健康指标信息。<br>在spring-boot-starter-actuator模块中自带实现了一些常用资源的健康指标检测器。这些检测器通过HealthIndicator接口实现，并且会根据依赖关系的引入实现自动化装配，比如用于检测磁盘的DiskSpaceHealthIndicator、检测DataSource连接是否可用的DataSourceHealthIndicator等。有时候，我们可能还会用到一些Spring Boot的Starter POMs中还没有封装的产品来进行开发，比如：当使用RocketMQ作为消息代理时，由于没有自动化配置的检测器，所以需要自己来实现一个用来采集健康信息的检测器。比如，我们可以在Spring Boot的应用中，为org.springframework.boot.actuate.health.HealthIndicator接口实现一个对RocketMQ的检测器类：</p><pre><code>@Componentpublic class RocketMQHealthIndicator implements HealthIndicator {    @Override    public Health health() {        int errorCode = check();        if (errorCode != 0) {          return Health.down().withDetail(&quot;Error Code&quot;, errorCode).build();        }        return Health.up().build();    }      private int check() {         // 对监控对象的检测操作      }}</code></pre><p>通过重写health()函数来实现健康检查，返回的Heath对象中，共有两项内容，一个是状态信息，除了该示例中的UP与DOWN之外，还有UNKNOWN和OUT_OF_SERVICE，可以根据需要来实现返回；还有一个详细信息，采用Map的方式存储，在这里通过withDetail函数，注入了一个Error Code信息，也可以填入一下其他信息，比如，检测对象的IP地址、端口等。重新启动应用，并访问/health接口，我们在返回的JSON字符串中，将会包含了如下信息：  </p><pre><code>&quot;rocketMQ&quot;: {  &quot;status&quot;: &quot;UP&quot;}</code></pre><h3 id="dump"><a href="#dump" class="headerlink" title="/dump"></a><strong>/dump</strong></h3><p>用来暴露程序运行中的线程信息。它使用java.lang.management.ThreadMXBean的dumpAllThreads方法来返回所有含有同步信息的活动线程详情。  </p><h3 id="trace"><a href="#trace" class="headerlink" title="/trace"></a><strong>/trace</strong></h3><p>用来返回基本的HTTP跟踪信息。默认情况下，跟踪信息的存储采用org.springframework.boot.actuate.trace.InMemoryTraceRepository实现的内存方式，始终保留最近的100条请求记录。它记录的内容格式如下：  </p><pre><code>[    {        &quot;timestamp&quot;: 1482570022463,        &quot;info&quot;: {            &quot;method&quot;: &quot;GET&quot;,            &quot;path&quot;: &quot;/metrics/mem&quot;,            &quot;headers&quot;: {                &quot;request&quot;: {                    &quot;host&quot;: &quot;localhost:8881&quot;,                    &quot;connection&quot;: &quot;keep-alive&quot;,                    &quot;cache-control&quot;: &quot;no-cache&quot;,                    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36&quot;,                    &quot;postman-token&quot;: &quot;9817ea4d-ad9d-b2fc-7685-9dff1a1bc193&quot;,                    &quot;accept&quot;: &quot;*/*&quot;,                    &quot;accept-encoding&quot;: &quot;gzip, deflate, sdch&quot;,                    &quot;accept-language&quot;: &quot;zh-CN,zh;q=0.8&quot;                },                &quot;response&quot;: {                    &quot;X-Application-Context&quot;: &quot;hello:dev:8881&quot;,                    &quot;Content-Type&quot;: &quot;application/json;charset=UTF-8&quot;,                    &quot;Transfer-Encoding&quot;: &quot;chunked&quot;,                    &quot;Date&quot;: &quot;Sat, 24 Dec 2016 09:00:22 GMT&quot;,                    &quot;status&quot;: &quot;200&quot;                }            }        }    },    ...]</code></pre><h2 id="操作控制类"><a href="#操作控制类" class="headerlink" title="操作控制类"></a><strong>操作控制类</strong></h2><p>由于介绍的所有端点都是用来反映应用自身的属性或是运行中的状态，相对于操作控制类端点没有那么敏感，所以他们默认都是启用的。<br>而操作控制类端点拥有更强大的控制能力，如果要使用它们的话，需要通过属性来配置开启。<br>在原生端点中，只提供了一个用来关闭应用的端点：/shutdown。我们可以通过如下配置开启它：<br>endpoints.shutdown.enabled=true<br>在配置了上述属性后，只需要访问应用的/shutdown端点就能实现关闭该应用的远程操作。由于开放关闭应用的操作本身是一件非常危险的事，所以真正在线上使用的时候，我们需要对其加入一定的保护机制，比如：定制Actuator的端点路径、整合Spring Security进行安全校验等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2018/11/14/2018-11-14-JDBC/"/>
      <url>/2018/11/14/2018-11-14-JDBC/</url>
      
        <content type="html"><![CDATA[<h3 id="文件与数据库对比"><a href="#文件与数据库对比" class="headerlink" title="文件与数据库对比"></a><strong>文件与数据库对比</strong></h3><p>文件不安全 查询功能单一 不利于查询<br>数据库按一定的规律存储数据 可用于海量数据的存储</p><h3 id="数据库的选择"><a href="#数据库的选择" class="headerlink" title="数据库的选择"></a><strong>数据库的选择</strong></h3><p>成本 功能多与少 并发量大不大 安全要求高不高</p><h2 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a><strong>jdbc</strong></h2><p>jdbc是规范，而hibernate是对jdbc的进一步封装，如写不同sql语句的jdbc层，只需要面对hibernate层面编程即可 </p><h3 id="java使用jdbc连接mysql数据库"><a href="#java使用jdbc连接mysql数据库" class="headerlink" title="java使用jdbc连接mysql数据库"></a><strong>java使用jdbc连接mysql数据库</strong></h3><pre><code>import java.sql.Connection;import java.sql.Driver;import java.sql.DriverManager;import java.util.Properties;import org.junit.Test;/** * jdbc连接数据库 * @author APPle * */public class Demo1 {    //连接数据库的URL    private String url = &quot;jdbc:mysql://localhost:3306/day17&quot;;                        // jdbc协议:数据库子协议:主机:端口/连接的数据库       private String user = &quot;root&quot;;//用户名    private String password = &quot;root&quot;;//密码    /**     * 第一种方法     * @throws Exception     */    @Test    public void test1() throws Exception{        //1.创建驱动程序类对象        Driver driver = new com.mysql.jdbc.Driver(); //新版本        //Driver driver = new org.gjt.mm.mysql.Driver(); //旧版本        //设置用户名和密码        Properties props = new Properties();        props.setProperty(&quot;user&quot;, user);        props.setProperty(&quot;password&quot;, password);        //2.连接数据库，返回连接对象        Connection conn = driver.connect(url, props);        System.out.println(conn);    }    /**     * 使用驱动管理器类连接数据库(注册了两次，没必要)     * @throws Exception     */    @Test    public void test2() throws Exception{        Driver driver = new com.mysql.jdbc.Driver();        //Driver driver2 = new com.oracle.jdbc.Driver();        //1.注册驱动程序(可以注册多个驱动程序)        DriverManager.registerDriver(driver);        //DriverManager.registerDriver(driver2);        //2.连接到具体的数据库        Connection conn = DriverManager.getConnection(url, user, password);        System.out.println(conn);    }    /**     * （推荐使用这种方式连接数据库）     * 推荐使用加载驱动程序类  来 注册驱动程序      * @throws Exception     */    @Test    public void test3() throws Exception{        //Driver driver = new com.mysql.jdbc.Driver();        //通过得到字节码对象的方式加载静态代码块，从而注册驱动程序        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //Driver driver2 = new com.oracle.jdbc.Driver();        //1.注册驱动程序(可以注册多个驱动程序)        //DriverManager.registerDriver(driver);        //DriverManager.registerDriver(driver2);        //2.连接到具体的数据库        Connection conn = DriverManager.getConnection(url, user, password);        System.out.println(conn);    }}</code></pre><h2 id="JDBCTemplate"><a href="#JDBCTemplate" class="headerlink" title="JDBCTemplate"></a><strong>JDBCTemplate</strong></h2><p>在使用JDBC时，必须自己来管理数据库资源如：获取PreparedStatement，设置SQL语句参数，关闭连接等步骤。<br>JDBCTemplate处理了资源的建立和释放，即Statement的建立和执行，只需提供SQL语句和占位符的值，得到封装好的查询结果集    </p><h3 id="在JDBCTemplate中执行SQL语句的方法大致分为3类"><a href="#在JDBCTemplate中执行SQL语句的方法大致分为3类" class="headerlink" title="在JDBCTemplate中执行SQL语句的方法大致分为3类"></a><strong>在JDBCTemplate中执行SQL语句的方法大致分为3类</strong></h3><p>execute ：可以执行所有SQL语句，一般用于执行DDL语句。<br>update ：用于执行 INSERT 、 UPDATE 、 DELETE 等DML语句。<br>queryXxx ：用于DQL数据查询语句。  </p><h3 id="C3P0基于配置文件实现连接池"><a href="#C3P0基于配置文件实现连接池" class="headerlink" title="C3P0基于配置文件实现连接池"></a><strong>C3P0基于配置文件实现连接池</strong></h3><p><strong>准备C3P0连接池</strong><br>导入依赖的jar包<br>   spring-beans-4.1.2.RELEASE.jar<br>   spring-core-4.1.2.RELEASE.jar<br>   spring-jdbc-4.1.2.RELEASE.jar<br>   spring-tx-4.1.2.RELEASE.jar<br>   com.springsource.org.apache.commons.logging-1.1.1.jar<br><strong>创建 JdbcTemplate 对象，传入连接池对象</strong><br><strong>调用 execute 、 update 、 queryXxx 等方法</strong><br>public JdbcTemplate(DataSource dataSource)<br><strong>创建JdbcTemplate对象，方便执行SQL语句</strong><br>public void execute(final String sql)<br>execute可以执行所有SQL语句，因为没有返回值，一般用于执行DDL语句。  </p><h2 id="JBDCTemplate执行DDL语句示例"><a href="#JBDCTemplate执行DDL语句示例" class="headerlink" title="JBDCTemplate执行DDL语句示例"></a><strong>JBDCTemplate执行DDL语句示例</strong></h2><pre><code>public class Demo {   public static void main(String[] args) {       // 创建表的SQL语句       String sql = &quot;CREATE TABLE product(&quot;      &quot;pid INT PRIMARY KEY AUTO_INCREMENT,&quot;      &quot;pname VARCHAR(20),&quot;      &quot;price DOUBLE&quot;      &quot;);&quot;;      //通过构造方法创建JdbcTemplate对象，传递数据源对象//通过工具类得到数据源      JdbcTemplate jdbcTemplate = new JdbcTemplate(DataSourceUtils.getDataSource());      //调用execute执行DDL语句      jdbcTemplate.execute(sql);  }}</code></pre><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a><strong>使用步骤</strong></h3><p>1.创建JdbcTemplate对象<br>2.编写SQL语句<br>3.使用JdbcTemplate对象的update方法进行增删改  </p><pre><code>public int update(final String sql)用于执行INSERT、UPDATE、DELETE等DML语句。JdbcTemplate的update方法用于执行DML语句。同时还可以在SQL语句中使用?占位符，在update方法的Object... args可变参数中传入对应的参数。使用JdbcTemplate对象的update方法进行增删改// JDBCTemplate添加数据public static void test01() throws Exception {    //通过构造方法创建JdbcTemplate对象，传递数据源对象//通过工具类得到数据源    JdbcTemplate jdbcTemplate = new JdbcTemplate(DataSourceUtils.getDataSource());    String sql = &quot;INSERT INTO product VALUES (NULL, ?, ?);&quot;;    jdbcTemplate.update(sql, &quot;iPhone3GS&quot;, 3333);    jdbcTemplate.update(sql, &quot;iPhone4&quot;, 5000);    jdbcTemplate.update(sql, &quot;iPhone4S&quot;, 5001);    jdbcTemplate.update(sql, &quot;iPhone5&quot;, 5555);    jdbcTemplate.update(sql, &quot;iPhone5C&quot;, 3888);    jdbcTemplate.update(sql, &quot;iPhone5S&quot;, 5666);    jdbcTemplate.update(sql, &quot;iPhone6&quot;, 6666);    jdbcTemplate.update(sql, &quot;iPhone6S&quot;, 7000);    jdbcTemplate.update(sql, &quot;iPhone6SP&quot;, 7777);    jdbcTemplate.update(sql, &quot;iPhoneX&quot;, 8888);}// JDBCTemplate修改数据public static void test02() throws Exception {    JdbcTemplate jdbcTemplate = new JdbcTemplate(DataSourceUtils.getDataSource());    String sql = &quot;UPDATE product SET pname=?, price=? WHERE pid=?;&quot;;    int i = jdbcTemplate.update(sql, &quot;XVIII&quot;, 18888, 10);    System.out.println(&quot;影响的行数: &quot; + i);}// JDBCTemplate删除数据public static void test03() throws Exception {    JdbcTemplate jdbcTemplate = new JdbcTemplate(DataSourceUtils.getDataSource());    String sql = &quot;DELETE FROM product WHERE pid=?;&quot;;    int i = jdbcTemplate.update(sql, 7);    System.out.println(&quot;影响的行数: &quot; + i);}</code></pre><h3 id="JDBCTemplate实现查询"><a href="#JDBCTemplate实现查询" class="headerlink" title="JDBCTemplate实现查询"></a><strong>JDBCTemplate实现查询</strong></h3><p>queryXxx ：用于DQL数据查询语句<br>public int queryForInt(String sql)<br>执行查询语句，返回一个int类型的值。<br>public long queryForLong(String sql)<br>执行查询语句，返回一个long类型的数据。<br>public  T queryForObject(String sql, Class requiredType)<br>执行查询语句，返回一个指定类型的数据。<br>public Map queryForMap(String sql)<br>执行查询语句，将一条记录放到一个Map中。<br>其中键是字符串的列名，值是Object类型<br>注：如果返回多条记录会出现异常<br>public List&gt; queryForList(String sql)<br>执行查询语句，返回一个List集合，List中存放的是Map类型的数据。  </p><ol><li>创建JdbcTemplate对象  </li><li>编写查询的SQL语句  </li><li>使用JdbcTemplate对象的queryXxx 方法  </li><li>输出结果  <h3 id="queryForInt"><a href="#queryForInt" class="headerlink" title="queryForInt"></a><strong>queryForInt</strong></h3></li></ol><pre><code>public static void test02() throws Exception {    // String sql = &quot;SELECT COUNT(*) FROM product;&quot;;    String sql = &quot;SELECT pid FROM product WHERE price=18888;&quot;;    JdbcTemplate jdbcTemplate = new JdbcTemplate(DataSourceUtils.getDataSource());    int forInt = jdbcTemplate.queryForInt(sql);    System.out.println(forInt);}</code></pre><h3 id="queryForLong"><a href="#queryForLong" class="headerlink" title="queryForLong"></a><strong>queryForLong</strong></h3><pre><code>public static void test03() throws Exception {    String sql = &quot;SELECT COUNT(*) FROM product;&quot;;    // String sql = &quot;SELECT pid FROM product WHERE price=18888;&quot;;    JdbcTemplate jdbcTemplate = new JdbcTemplate(DataSourceUtils.getDataSource());    long forLong = jdbcTemplate.queryForLong(sql);    System.out.println(forLong);}</code></pre><h3 id="queryForObject"><a href="#queryForObject" class="headerlink" title="queryForObject"></a><strong>queryForObject</strong></h3><pre><code>public static void test04() throws Exception {String sql = &quot;SELECT pname FROM product WHERE price=7777;&quot;;JdbcTemplate jdbcTemplate = new JdbcTemplate(DataSourceUtils.getDataSource());String str = jdbcTemplate.queryForObject(sql, String.class);System.out.println(str);}</code></pre><h3 id="queryForMap"><a href="#queryForMap" class="headerlink" title="queryForMap"></a><strong>queryForMap</strong></h3><pre><code>public static void test05() throws Exception {    String sql = &quot;SELECT * FROM product WHERE pid=?;&quot;;    JdbcTemplate jdbcTemplate = new JdbcTemplate(DataSourceUtils.getDataSource());    Map map = jdbcTemplate.queryForMap(sql, 6);    System.out.println(map);}</code></pre><h3 id="queryForList"><a href="#queryForList" class="headerlink" title="queryForList"></a><strong>queryForList</strong></h3><pre><code>public static void test06() throws Exception {    String sql = &quot;SELECT * FROM product WHERE pid&lt;?;&quot;;    JdbcTemplate jdbcTemplate = new JdbcTemplate(DataSourceUtils.getDataSource());    List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(sql, 8);    for (Map&lt;String, Object&gt; map : list) {    System.out.println(map);    }}</code></pre><p>查询1条记录封装成自定义的类  </p><h3 id="JDBC操作数据库"><a href="#JDBC操作数据库" class="headerlink" title="JDBC操作数据库"></a><strong>JDBC操作数据库</strong></h3><p>工具准备：Mysql（数据库）、 MyEclipse（开发工具）、Navicat（数据库管理工具）<br>JDBC编程步骤<br>·加载驱动程序:class.forName(driverClass);<br>    加载Mysql驱动<br>        Class.forName(“com.mysql.jdbc.driver”)<br>    加载Oracle驱动<br>        Class.forName(“oracle.jdbc.driver.OracleDriver”)<br>·获得数据库连接：<br>    DriverManager.getConnection(“jdbc.mysql://127.0.0.1:3306/imooc”,”root”,”root”);<br>    ==&gt;参数为(URL,usename, password)  </p><p>·创建Statement对象:<br>    conn.createStatement();  </p><pre><code>        Connection connection = null;        Statement statement = null;        ResultSet resultSet = null;        try {            /*            * 加载驱动有两种方式            *            * 1：会导致驱动会注册两次，过度依赖于mysql的api，脱离的mysql的开发包，程序则无法编译            * 2：驱动只会加载一次，不需要依赖具体的驱动，灵活性高            *            * 我们一般都是使用第二种方式            * */            //1.            //DriverManager.registerDriver(new com.mysql.jdbc.Driver());            //2.            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);            //获取与数据库连接的对象-Connetcion            connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/zhongfucheng&quot;, &quot;root&quot;, &quot;root&quot;);            //获取执行sql语句的statement对象            statement = connection.createStatement();            //执行sql语句,拿到结果集            resultSet = statement.executeQuery(&quot;SELECT * FROM users&quot;);            //遍历结果集，得到数据            while (resultSet.next()) {                System.out.println(resultSet.getString(1));                System.out.println(resultSet.getString(2));            }        } catch (SQLException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        } finally {            /*            * 关闭资源，后调用的先关闭            *            * 关闭之前，要判断对象是否存在            * */            if (resultSet != null) {                try {                    resultSet.close();                } catch (SQLException e) {                    e.printStackTrace();                }            }            if (statement != null) {                try {                    statement.close();                } catch (SQLException e) {                    e.printStackTrace();                }            }            if (connection != null) {                try {                    connection.close();                } catch (SQLException e) {                    e.printStackTrace();                }            }        }</code></pre><h2 id="写出一段JDBC连接本机MySQL数据库的代码"><a href="#写出一段JDBC连接本机MySQL数据库的代码" class="headerlink" title="写出一段JDBC连接本机MySQL数据库的代码"></a><strong>写出一段JDBC连接本机MySQL数据库的代码</strong></h2><pre><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);String url=&quot;jdbc:mysql://localhost/test&quot;;Stirng user=&#39;root&#39;;String password=&#39;root&#39;;Connection conn = DriverManager.getConnection(url,user,password);</code></pre><h3 id="execute，executeQuery，executeUpdate的区别是什么？"><a href="#execute，executeQuery，executeUpdate的区别是什么？" class="headerlink" title="execute，executeQuery，executeUpdate的区别是什么？"></a><strong>execute，executeQuery，executeUpdate的区别是什么？</strong></h3><p>Statement的execute(String query)方法用来执行任意的SQL查询，如果查询的结果是一个ResultSet，这个方法就返回true。如果结果不是ResultSet，比如insert或者update查询，它就会返回false。我们可以通过它的getResultSet方法来获取ResultSet，或者通过getUpdateCount()方法来获取更新的记录条数。<br>Statement的executeQuery(String query)接口用来执行select查询，并且返回ResultSet。即使查询不到记录返回的ResultSet也不会为null。我们通常使用executeQuery来执行查询语句，这样的话如果传进来的是insert或者update语句的话，它会抛出错误信息为 “executeQuery method can not be used for update”的java.util.SQLException。<br>Statement的executeUpdate(String query)方法用来执行insert或者update/delete（DML）语句，或者 什么也不返回DDL语句。返回值是int类型，如果是DML语句的话，它就是更新的条数，如果是DDL的话，就返回0。<br>只有当你不确定是什么语句的时候才应该使用execute()方法，否则应该使用executeQuery或者executeUpdate方法。</p><h3 id="PreparedStatement的缺点是什么，怎么解决这个问题？"><a href="#PreparedStatement的缺点是什么，怎么解决这个问题？" class="headerlink" title="PreparedStatement的缺点是什么，怎么解决这个问题？"></a><strong>PreparedStatement的缺点是什么，怎么解决这个问题？</strong></h3><p>PreparedStatement的一个缺点是，我们不能直接用它来执行in条件语句；需要执行IN条件语句的话，下面有一些解决方案：</p><p>分别进行单条查询——这样做性能很差，不推荐。<br>使用存储过程——这取决于数据库的实现，不是所有数据库都支持。<br>动态生成PreparedStatement——这是个好办法，但是不能享受PreparedStatement的缓存带来的好处了。<br>在PreparedStatement查询中使用NULL值——如果你知道输入变量的最大个数的话，这是个不错的办法，扩展一下还可以支持无限参数。</p><h3 id="JDBC的DriverManager是用来做什么的？"><a href="#JDBC的DriverManager是用来做什么的？" class="headerlink" title="JDBC的DriverManager是用来做什么的？"></a><strong>JDBC的DriverManager是用来做什么的？</strong></h3><p>JDBC的DriverManager是一个工厂类，我们通过它来创建数据库连接。<br>当JDBC的Driver类被加载进来时，它会自己注册到DriverManager类里面<br>然后我们会把数据库配置信息传成DriverManager.getConnection()方法，DriverManager会使用注册到它里面的驱动来获取数据库连接，并返回给调用的程序。</p><h3 id="JDBC的ResultSet是什么"><a href="#JDBC的ResultSet是什么" class="headerlink" title="JDBC的ResultSet是什么?"></a><strong>JDBC的ResultSet是什么?</strong></h3><p>在查询数据库后会返回一个ResultSet，它就像是查询结果集的一张数据表。<br>ResultSet对象维护了一个游标，指向当前的数据行。开始的时候这个游标指向的是第一行。如果调用了ResultSet的next()方法游标会下移一行，如果没有更多的数据了，next()方法会返回false。可以在for循环中用它来遍历数据集。<br>默认的ResultSet是不能更新的，游标也只能往下移。也就是说你只能从第一行到最后一行遍历一遍。不过也可以创建可以回滚或者可更新的ResultSet<br>当生成ResultSet的Statement对象要关闭或者重新执行或是获取下一个ResultSet的时候，ResultSet对象也会自动关闭。<br>可以通过ResultSet的getter方法，传入列名或者从1开始的序号来获取列数据。</p><h3 id="JDBC的DataSource是什么，有什么好处"><a href="#JDBC的DataSource是什么，有什么好处" class="headerlink" title="JDBC的DataSource是什么，有什么好处"></a><strong>JDBC的DataSource是什么，有什么好处</strong></h3><p>DataSource即数据源，它是定义在javax.sql中的一个接口，跟DriverManager相比，它的功能要更强大。我们可以用它来创建数据库连接，当然驱动的实现类会实际去完成这个工作。除了能创建连接外，它还提供了如下的特性：</p><p>缓存PreparedStatement以便更快的执行<br>可以设置连接超时时间<br>提供日志记录的功能<br>ResultSet大小的最大阈值设置<br>通过JNDI的支持，可以为servlet容器提供连接池的功能</p><h3 id="如何通过JDBC的DataSource和Apache-Tomcat的JNDI来创建连接池？"><a href="#如何通过JDBC的DataSource和Apache-Tomcat的JNDI来创建连接池？" class="headerlink" title="如何通过JDBC的DataSource和Apache Tomcat的JNDI来创建连接池？"></a><strong>如何通过JDBC的DataSource和Apache Tomcat的JNDI来创建连接池？</strong></h3><p>Tomcat服务器也给我们提供了连接池，内部其实就是DBCP</p><p>步骤：</p><p>在META-INF目录下配置context.xml文件【文件内容可以在tomcat默认页面的 JNDI Resources下Configure Tomcat’s Resource Factory找到】<br>导入Mysql或oracle开发包到tomcat的lib目录下<br>初始化JNDI-&gt;获取JNDI容器-&gt;检索以XXX为名字在JNDI容器存放的连接池<br>context.xml文件的配置：</p><pre><code>&lt;Context&gt;  &lt;Resource name=&quot;jdbc/EmployeeDB&quot;            auth=&quot;Container&quot;            type=&quot;javax.sql.DataSource&quot;            username=&quot;root&quot;            password=&quot;root&quot;            driverClassName=&quot;com.mysql.jdbc.Driver&quot;            url=&quot;jdbc:mysql://localhost:3306/zhongfucheng&quot;            maxActive=&quot;8&quot;            maxIdle=&quot;4&quot;/&gt;&lt;/Context&gt;        try {            //初始化JNDI容器            Context initCtx = new InitialContext();            //获取到JNDI容器            Context envCtx = (Context) initCtx.lookup(&quot;java:comp/env&quot;);            //扫描以jdbc/EmployeeDB名字绑定在JNDI容器下的连接池            DataSource ds = (DataSource)                    envCtx.lookup(&quot;jdbc/EmployeeDB&quot;);            Connection conn = ds.getConnection();            System.out.println(conn);        } </code></pre><h3 id="Apache的DBCP是什么"><a href="#Apache的DBCP是什么" class="headerlink" title="Apache的DBCP是什么"></a><strong>Apache的DBCP是什么</strong></h3><p>如果用DataSource来获取连接的话，通常获取连接的代码和驱动特定的DataSource是紧耦合的。另外，除了选择DataSource的实现类，剩下的代码基本都是一样的。<br>Apache的DBCP就是用来解决这些问题的，它提供的DataSource实现成为了应用程序和不同JDBC驱动间的一个抽象层。Apache的DBCP库依赖commons-pool库，所以要确保它们都在部署路径下。<br>使用DBCP数据源的步骤：<br>导入两个jar包【Commons-dbcp.jar和Commons-pool.jar】<br>读取配置文件<br>获取BasicDataSourceFactory对象<br>创建DataSource对象</p><pre><code> private static DataSource dataSource = null;    static {        try {            //读取配置文件            InputStream inputStream = Demo3.class.getClassLoader().getResourceAsStream(&quot;dbcpconfig.properties&quot;);            Properties properties = new Properties();            properties.load(inputStream);            //获取工厂对象            BasicDataSourceFactory basicDataSourceFactory = new BasicDataSourceFactory();            dataSource = basicDataSourceFactory.createDataSource(properties);        } catch (IOException e) {            e.printStackTrace();        } catch (Exception e) {            e.printStackTrace();        }    }    public static Connection getConnection() throws SQLException {        return dataSource.getConnection();    }    //这里释放资源不是把数据库的物理连接释放了，是把连接归还给连接池【连接池的Connection内部自己做好了】    public static void release(Connection conn, Statement st, ResultSet rs) {        if (rs != null) {            try {                rs.close();            } catch (Exception e) {                e.printStackTrace();            }            rs = null;        }        if (st != null) {            try {                st.close();            } catch (Exception e) {                e.printStackTrace();            }        }        if (conn != null) {            try {                conn.close();            } catch (Exception e) {                e.printStackTrace();            }        }    }</code></pre><h2 id="常见的JDBC异常有哪些？"><a href="#常见的JDBC异常有哪些？" class="headerlink" title="常见的JDBC异常有哪些？"></a><strong>常见的JDBC异常有哪些？</strong></h2><p>java.sql.SQLException——这是JDBC异常的基类。<br>java.sql.BatchUpdateException——当批处理操作执行失败的时候可能会抛出这个异常。这取决于具体的JDBC驱动的实现，它也可能直接抛出基类异常java.sql.SQLException。<br>java.sql.SQLWarning——SQL操作出现的警告信息。<br>java.sql.DataTruncation——字段值由于某些非正常原因被截断了（不是因为超过对应字段类型的长度限制）。  </p><h2 id="JDBC中存在哪些不同类型的锁"><a href="#JDBC中存在哪些不同类型的锁" class="headerlink" title="JDBC中存在哪些不同类型的锁?"></a><strong>JDBC中存在哪些不同类型的锁?</strong></h2><p>从广义上讲，有两种锁机制来防止多个用户同时操作引起的数据损坏。<br>乐观锁——只有当更新数据的时候才会锁定记录。<br>悲观锁——从查询到更新和提交整个过程都会对数据记录进行加锁。  </p><h2 id="java-util-Date和java-sql-Date有什么区别？"><a href="#java-util-Date和java-sql-Date有什么区别？" class="headerlink" title="java.util.Date和java.sql.Date有什么区别？"></a><strong>java.util.Date和java.sql.Date有什么区别？</strong></h2><p>java.util.Date包含日期和时间，而java.sql.Date只包含日期信息，而没有具体的时间信息。如果你想把时间信息存储在数据库里，可以考虑使用Timestamp或者DateTime字段  </p><h2 id="SQLWarning是什么，在程序中如何获取SQLWarning？"><a href="#SQLWarning是什么，在程序中如何获取SQLWarning？" class="headerlink" title="SQLWarning是什么，在程序中如何获取SQLWarning？"></a><strong>SQLWarning是什么，在程序中如何获取SQLWarning？</strong></h2><p>SQLWarning是SQLException的子类，通过Connection, Statement, Result的getWarnings方法都可以获取到它。 SQLWarning不会中断查询语句的执行，只是用来提示用户存在相关的警告信息。  </p><h2 id="什么是JDBC的最佳实践？"><a href="#什么是JDBC的最佳实践？" class="headerlink" title="什么是JDBC的最佳实践？"></a><strong>什么是JDBC的最佳实践？</strong></h2><p>养成在代码中显式关闭掉ResultSet，Statement，Connection的习惯<br>在finally块中关闭资源，保证即便出了异常也能正常关闭。<br>大量类似的查询应当使用<strong>批处理</strong>完成。<br>尽量使用PreparedStatement而不是Statement，以避免SQL注入，同时还能通过预编译和缓存机制提升执行的效率。<br>如果你要将大量数据读入到ResultSet中，应该合理的设置fetchSize以便提升性能。<br>确认数据库的隔离级别<br>如果在WEB程序中创建数据库连接，最好通过JNDI使用JDBC的数据源，这样可以对连接进行重用<br>长时间对ResultSet进行操作，尽量使用离线的RowSet  </p><h3 id="SQL-约束有哪几种？"><a href="#SQL-约束有哪几种？" class="headerlink" title="SQL 约束有哪几种？"></a><strong>SQL 约束有哪几种？</strong></h3><p>NOT NULL<br>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。<br>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。<br>FOREIGN KEY</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日期的处理</title>
      <link href="/2018/11/14/2018-11-14-%E6%97%A5%E6%9C%9F%E7%9A%84%E5%A4%84%E7%90%86/"/>
      <url>/2018/11/14/2018-11-14-%E6%97%A5%E6%9C%9F%E7%9A%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="日期的处理"><a href="#日期的处理" class="headerlink" title="日期的处理"></a><strong>日期的处理</strong></h3><p>把前端的传过来的数据通过属性编辑器initBind进行格式转换在setAsText时通过SimpleDateFormat转成字符串，在getAsText时再把字符串转为日期格式注入实体类中<br>可以继承数据绑定编辑器的父类来自定义转换，<br>也可以直接使用已经封装好的格式转换</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 日期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web发展历史</title>
      <link href="/2018/11/14/2018-11-14-web%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/"/>
      <url>/2018/11/14/2018-11-14-web%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="纯jsp时代"><a href="#纯jsp时代" class="headerlink" title="纯jsp时代"></a><strong>纯jsp时代</strong></h3><p>使用jsp接收前台数据并通过action=”registerDeal.jsp”跳转到其他的jsp去对数据进行处理<br><img src="https://viabcde.github.io/images/blog/2018092808.png" alt="enter descriptionhere"><br>好处：简单，只有jsp,数据库<br>缺点：java逻辑全部都在jsp中，如果要用新的逻辑必须把java的逻辑按jsp重写一遍</p><h3 id="jsp-model-service时代"><a href="#jsp-model-service时代" class="headerlink" title="jsp+model+service时代"></a><strong>jsp+model+service时代</strong></h3><p>改进：将model 、对数据库的访问 两者与jsp分离<br><img src="https://viabcde.github.io/images/blog/2018092809.png" alt="enter descriptionhere"><br>缺点：1.每次访问数据库都要打开一次数据库;2.存在sql语句，非纯面向对象</p><h3 id="jsp-model-service-hibernate-时代"><a href="#jsp-model-service-hibernate-时代" class="headerlink" title="jsp+model+service(hibernate)时代"></a><strong>jsp+model+service(hibernate)时代</strong></h3><p>改进：解决了频繁连接数据库问题<br><img src="https://viabcde.github.io/images/blog/2018092810.png" alt="enter descriptionhere">  </p><h3 id="jsp-service-impl-dao-impl-hibernate-时代"><a href="#jsp-service-impl-dao-impl-hibernate-时代" class="headerlink" title="jsp+service+impl+dao+impl(hibernate)时代"></a><strong>jsp+service+impl+dao+impl(hibernate)时代</strong></h3><p>改进：service接口实现灵活更换各种业务；dao接口实现了灵活更换数据库<br><img src="https://viabcde.github.io/images/blog/2018092811.png" alt="enter descriptionhere"><br>缺点：处理结果的视图跳转仍然留着jsp里，视图写死在jsp</p><h3 id="jsp-service-impl-dao-impl-struts2-hibernate-时代"><a href="#jsp-service-impl-dao-impl-struts2-hibernate-时代" class="headerlink" title="jsp+service+impl+dao+impl(struts2+hibernate)时代"></a><strong>jsp+service+impl+dao+impl(struts2+hibernate)时代</strong></h3><p>改进：实现了视图跳转<br>!<img src="https://viabcde.github.io/images/blog/2018092812.png" alt="enter descriptionhere"><br>缺点：MVC各组件耦合度极高，即互相之间的调用写死在代码中</p><h3 id="jsp-service-impl-dao-impl-struts2-Spring-hibernate-时代"><a href="#jsp-service-impl-dao-impl-struts2-Spring-hibernate-时代" class="headerlink" title="jsp+service+impl+dao+impl(struts2+Spring+hibernate)时代"></a><strong>jsp+service+impl+dao+impl(struts2+Spring+hibernate)时代</strong></h3><p>改进：实现了MVC各个组件的解耦<br><img src="https://viabcde.github.io/images/blog/2018092813.png" alt="enter descriptionhere">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet</title>
      <link href="/2018/11/14/2018-11-09-Servlet/"/>
      <url>/2018/11/14/2018-11-09-Servlet/</url>
      
        <content type="html"><![CDATA[<h3 id="doGet与doPost方法的两个参数是什么"><a href="#doGet与doPost方法的两个参数是什么" class="headerlink" title="doGet与doPost方法的两个参数是什么"></a><strong>doGet与doPost方法的两个参数是什么</strong></h3><p>HttpServletRequest：封装请求信息<br>HttpServletResponse：封装响应信息   </p><h3 id="为什么get比post更快"><a href="#为什么get比post更快" class="headerlink" title="为什么get比post更快"></a><strong>为什么get比post更快</strong></h3><p>post必须等待服务器有请求回应才会发送下一个请求<br>而get则是不管有没有收到回应都不断发送请求（利用管道传输直接把多个请求发送出去，但不安全，当发送过程中服务器关闭，则之前的请求都相当于做了无用功）<br>get会缓存数据（一般是静态数据）而post不会<br>post比get安全（不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中）  </p><h3 id="获取页面的元素的值有几种方式"><a href="#获取页面的元素的值有几种方式" class="headerlink" title="获取页面的元素的值有几种方式"></a><strong>获取页面的元素的值有几种方式</strong></h3><p>request.getParameter() 返回客户端的请求参数的值<br>request.getParameterNames() 返回所有可用属性名的枚举<br>request.getParameterValues() 返回包含参数的所有值的数组  </p><h3 id="request-getAttribute-和request-getParameter-区别"><a href="#request-getAttribute-和request-getParameter-区别" class="headerlink" title="request.getAttribute()和request.getParameter()区别"></a><strong>request.getAttribute()和request.getParameter()区别</strong></h3><p>用途上:<br>request.getAttribute()， 一般用于获取request域对象的数据(在跳转之前把数据使用setAttribute来放到request对象上)<br>request.getParameter()， 一般用于获取客户端提交的参数<br>存储数据上:<br>request.getAttribute()可以获取Objcet对象<br>request.getParameter()只能获取字符串(这也是为什么它一般用于获取客户端提交的参数)  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot遇到的问题</title>
      <link href="/2018/11/13/2018-11-13-SpringBoot%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2018/11/13/2018-11-13-SpringBoot%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="遇到的问题：端口占用问题"><a href="#遇到的问题：端口占用问题" class="headerlink" title="遇到的问题：端口占用问题"></a><strong>遇到的问题：</strong>端口占用问题</h2><p>运行独立jar包时可能会出现端口占用问题，springboot的内嵌tomcat的端口8080可能会被oracle (我就是)占用或者 tomcat（默认8080）占用    </p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h2><p>重新配置内嵌tomcat的端口号步骤如下    </p><ol><li>在resource目录下新建application.properties文件（文件名一定要application.properties因为这个是默认的配置，如果文件名字不是这个则需要手动的添加识别）配置如下图<br><img src="https://viabcde.github.io/images/2018-10-10/2018101015.png" alt="enter descriptionhere"> </li></ol><h3 id="通过命令行设置属性值-启动的应用的端口号"><a href="#通过命令行设置属性值-启动的应用的端口号" class="headerlink" title="通过命令行设置属性值 启动的应用的端口号"></a><strong>通过命令行设置属性值 启动的应用的端口号</strong></h3><p>在命令行运行时，连续的两个减号–就是对application.properties中的属性值进行赋值的标识。<br>java -jar xxx.jar –server.port=8888命令，等价于我们在application.properties中添加属性server.port=8888</p><p><strong>问题：</strong>通过命令行就能更改应用运行的参数很不安全<br><strong>解决方法：</strong>SpringBoot提供了屏蔽命令行访问属性的设置：SpringApplication.setAddCommandLineProperties(false)。 </p><h3 id="编写SpringBoot-demo过程遇到的2个错误"><a href="#编写SpringBoot-demo过程遇到的2个错误" class="headerlink" title="编写SpringBoot demo过程遇到的2个错误"></a><strong>编写SpringBoot demo过程遇到的2个错误</strong></h3><p><strong>错误1</strong><br>创建完成后，如果项目报红色，(1).需要对项目右键-》属性-》Generate Deloyment Desriptor Stub。(2).项目右键-》Maven-》Update Project<br><strong>错误2</strong><br>运行后出现springboot A resource exists with a different case<br><img src="https://viabcde.github.io/images/201811/20181106.png" alt="enter descriptionhere"><br>groupId 和artifactId 和项目名不一致，我这里项目名SpringBootDemo而pom文件中是springbootDemo，所以出现这个错误，修改如上图即可<br><strong>错误3</strong><br>spring boot javax/annotation/ManagedBean : Unsupported major.minor version 51.0<br>原因jdk版本的问题  ，maven自带的jar版本与javax的jar版本不符，我修改为1.6即可解决<br><strong>错误4</strong><br>Establishing SSL connection without server’s identity verification is not recommended<br><strong>解决方法</strong><br>MySQL 5.5.45+, 5.6.26+ and 5.7.6+ 这些版本的数据库需要手动指定SSL是否开启，所以原来的连接字符串：jdbc.url=jdbc:mysql://127.0.0.1:3306/test就不可以了。<br>解决：<br>需要在其后附加useSSL=true或false，使用新的连接字符串：jdbc.url=jdbc:mysql://127.0.0.1:3306/test&amp;useSSL=false问题就解决了。</p><h3 id="Spring-Boot-启动报错Unable-to-start-ServletWebServerApplicationContext-due-to-missing-ServletWebServerFa"><a href="#Spring-Boot-启动报错Unable-to-start-ServletWebServerApplicationContext-due-to-missing-ServletWebServerFa" class="headerlink" title="Spring Boot 启动报错Unable to start ServletWebServerApplicationContext due to missing ServletWebServerFa"></a><strong>Spring Boot 启动报错Unable to start ServletWebServerApplicationContext due to missing ServletWebServerFa</strong></h3><p><strong>错误代码</strong> </p><pre><code>import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class HelloApplication {    public static void main(String[] args) {        SpringApplication.run(HelloController.class, args);    }}</code></pre><pre><code>import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController {    @RequestMapping(&quot;/&quot;)    public String index() {        return &quot;Hello Spring Boot 2.0!&quot;;    }}</code></pre><p><strong>原因：</strong><br>使用代码自动提示(Alt+/)时粗心了<code>SpringApplication.run(HelloController.class, args);</code><br>应该改为<code>SpringApplication.run(HelloApplication.class, args);</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot访问时怎么没有项目路径？</title>
      <link href="/2018/11/13/2018-11-13-SpringBoot%E8%AE%BF%E9%97%AE%E6%97%B6%E6%80%8E%E4%B9%88%E6%B2%A1%E6%9C%89%E9%A1%B9%E7%9B%AE%E8%B7%AF%E5%BE%84/"/>
      <url>/2018/11/13/2018-11-13-SpringBoot%E8%AE%BF%E9%97%AE%E6%97%B6%E6%80%8E%E4%B9%88%E6%B2%A1%E6%9C%89%E9%A1%B9%E7%9B%AE%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p>按照之前的web项目习惯，你可能会问，SpringBoot怎么没有项目路径？<br>这就是Spring Boot的默认设置了，将项目路径直接设为根路径。<br>当然，我们也可以设置自己的项目路径 – 在classpath下的 application.properties 或者 application.yaml 文件中设置即可。<br>内容如下：  </p><pre><code># application.yaml# Server settings (ServerProperties)server:  port: 8080  address: 127.0.0.1  sessionTimeout: 30  contextPath: /aaa  # Tomcat specifics  tomcat:    accessLogEnabled: false    protocolHeader: x-forwarded-proto    remoteIpHeader: x-forwarded-for    basedir:    backgroundProcessorDelay: 30 # secs</code></pre><pre><code># application.properties# Server settings (ServerProperties)server.port=8080server.address=127.0.0.1#server.sessionTimeout=30server.contextPath=/aaa# Tomcat specifics#server.tomcat.accessLogEnabled=falseserver.tomcat.protocolHeader=x-forwarded-protoserver.tomcat.remoteIpHeader=x-forwarded-forserver.tomcat.basedir=server.tomcat.backgroundProcessorDelay=30</code></pre><p>上面， server.contextPath=/aaa 就是设置了项目路径。所以现在需要访问 <a href="http://localhost:8080/aaa/" target="_blank" rel="noopener">http://localhost:8080/aaa/</a> 才行。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot的配置文件application.properties</title>
      <link href="/2018/11/13/2018-11-13-SpringBoot%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2018/11/13/2018-11-13-SpringBoot%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="SpringBoot的配置文件"><a href="#SpringBoot的配置文件" class="headerlink" title="SpringBoot的配置文件"></a><strong>SpringBoot的配置文件</strong></h3><p>用来配置数据库连接、日志相关配置等<br>自定义属性与加载<br>我们在使用Spring Boot的时候，通常也需要定义一些自己使用的属性，我们可以如下方式直接定义：  </p><pre><code>com.didispace.blog.name=程序猿DDcom.didispace.blog.title=Spring Boot教程</code></pre><p>然后通过@Value(“${属性名}”)注解来加载对应的配置属性，具体如下：  </p><pre><code>@Componentpublic class BlogProperties {    @Value(&quot;${com.didispace.blog.name}&quot;)    private String name;    @Value(&quot;${com.didispace.blog.title}&quot;)    private String title;    // 省略getter和setter}</code></pre><p>按照惯例，通过单元测试来验证BlogProperties中的属性是否已经根据配置文件加载了。  </p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(Application.class)public class ApplicationTests {    @Autowired    private BlogProperties blogProperties;    @Test    public void getHello() throws Exception {        Assert.assertEquals(blogProperties.getName(), &quot;程序猿DD&quot;);        Assert.assertEquals(blogProperties.getTitle(), &quot;Spring Boot教程&quot;);    }}</code></pre><h4 id="配置文件里参数间可以互相引用"><a href="#配置文件里参数间可以互相引用" class="headerlink" title="配置文件里参数间可以互相引用"></a><strong>配置文件里参数间可以互相引用</strong></h4><p>在application.properties中的各个参数之间也可以直接引用来使用，就像下面的设置：  </p><pre><code>com.didispace.blog.name=程序猿DDcom.didispace.blog.title=Spring Boot教程com.didispace.blog.desc=${com.didispace.blog.name}正在努力写《${com.didispace.blog.title}》</code></pre><p>com.didispace.blog.desc参数引用了上文中定义的name和title属性，最后该属性的值就是程序猿DD正在努力写《Spring Boot教程》。</p><h3 id="配置文件的使用方法"><a href="#配置文件的使用方法" class="headerlink" title="配置文件的使用方法"></a><strong>配置文件的使用方法</strong></h3><h4 id="使用随机数"><a href="#使用随机数" class="headerlink" title="使用随机数"></a><strong>使用随机数</strong></h4><p>在一些情况下，有些参数我们需要希望它不是一个固定的值，比如密钥、服务端口等。Spring Boot的属性配置文件中可以通过${random}来产生int值、long值或者string字符串，来支持属性的随机值。  </p><h4 id="随机字符串"><a href="#随机字符串" class="headerlink" title="随机字符串"></a><strong>随机字符串</strong></h4><p>com.didispace.blog.value=${random.value}  </p><h4 id="随机int"><a href="#随机int" class="headerlink" title="随机int"></a><strong>随机int</strong></h4><p>com.didispace.blog.number=${random.int}  </p><h4 id="随机long"><a href="#随机long" class="headerlink" title="随机long"></a><strong>随机long</strong></h4><p>com.didispace.blog.bignumber=${random.long}</p><h4 id="10以内的随机数"><a href="#10以内的随机数" class="headerlink" title="10以内的随机数"></a><strong>10以内的随机数</strong></h4><p>com.didispace.blog.test1=${random.int(10)}  </p><h4 id="10-20的随机数"><a href="#10-20的随机数" class="headerlink" title="10-20的随机数"></a><strong>10-20的随机数</strong></h4><p>com.didispace.blog.test2=${random.int[10,20]}  </p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解EnableAutoConfiguration 和 SpringApplication</title>
      <link href="/2018/11/13/2018-11-13-SpringBoot%E6%B3%A8%E8%A7%A3/"/>
      <url>/2018/11/13/2018-11-13-SpringBoot%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>用于自动配置。根据你的pom配置（实际上应该是根据具体的依赖）来判断这是一个什么应用，并创建相应的环境。<br>在上面这个例子中，@EnableAutoConfiguration 会判断出这是一个web应用，所以会创建相应的web环境。  </p><h3 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h3><p>用于从main方法启动Spring应用的类。默认，它会执行以下步骤：  </p><pre><code>1.创建一个合适的ApplicationContext实例 （取决于classpath）。  2.注册一个CommandLinePropertySource，以便将命令行参数作为Spring properties。  3.刷新application context，加载所有单例beans。  4.激活所有CommandLineRunner beans。  默认，直接使用SpringApplication 的静态方法run()即可。但也可以创建实例，并自行配置需要的设置。  </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运行SpringBoot</title>
      <link href="/2018/11/13/2018-11-13-%E8%BF%90%E8%A1%8CSpringBoot/"/>
      <url>/2018/11/13/2018-11-13-%E8%BF%90%E8%A1%8CSpringBoot/</url>
      
        <content type="html"><![CDATA[<h3 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a><strong>第一种方式</strong></h3><p>1.在UserController中加上@EnableAutoConfiguration开启自动配置<br>2.然后通过SpringApplication.run(UserController.class);运行这个控制器<br><strong>使用场景：</strong>这种方式在运行一个控制器比较方便<br>代码如下：  </p><pre><code>@RestController@EnableAutoConfigurationpublic class Application {@RequestMapping(&quot;user&quot;)public static StringSayHello() {        return&quot;Hello Word!&quot;;}public static voidmain(String[] args){        SpringApplication.run(Application.class,args);}}</code></pre><h3 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a><strong>第二种方式</strong></h3><p>@Configuration+@ComponentScan开启注解扫描并自动注册相应的注解Bean<br>代码如下  </p><pre><code>@Configuration@ComponentScan@EnableAutoConfigurationpublic class Application {public static voidmain(String[] args){        SpringApplication.run(Application.class,args);}</code></pre><h3 id="第三种：将工程打包成独立运行jar包"><a href="#第三种：将工程打包成独立运行jar包" class="headerlink" title="第三种：将工程打包成独立运行jar包"></a><strong>第三种：将工程打包成独立运行jar包</strong></h3><p>进入cmd 定位到项目目录下然后执行   </p><pre><code>mvn clean  package –DskipTests</code></pre><p>执行成功后在项目的target文件夹下出现jar包，例如（spingboot-demo-0.0.1-SNAPSHOT.jar）<br>然后再cmd 的C盘 用户目录下执行命令  </p><pre><code>$ java –jar （jar包的目录）E:\program\spingboot-demo\target\spingboot-demo-0.0.1-SNAPSHOT.jar  </code></pre><p>回车运行会有如下图<br><img src="https://viabcde.github.io/images/2018-10-10/2018101012.png" alt="enter descriptionhere"><br>出现下图表示运行成功<br><img src="https://viabcde.github.io/images/2018-10-10/2018101013.png" alt="enter descriptionhere"><br>然后在浏览器中输入端口号和地址进行访问。<br><img src="https://viabcde.github.io/images/2018-10-10/2018101014.png" alt="enter descriptionhere"><br><strong>spring boot 优势:</strong>  一个jar 包和java 环境就能运行web 项目</p><h2 id="远程下载并启动Spring-boot项目"><a href="#远程下载并启动Spring-boot项目" class="headerlink" title="远程下载并启动Spring boot项目"></a><strong>远程下载并启动Spring boot项目</strong></h2><pre><code>git clone git@github.com:hengyunabc/spring-boot-demo.git  mvn spring-boot-demo  java -jar target/demo-0.0.1-SNAPSHOT.jar  </code></pre><h3 id="部署spring-boot应用"><a href="#部署spring-boot应用" class="headerlink" title="部署spring boot应用"></a><strong>部署spring boot应用</strong></h3><p>要部署运行spring boot应用，首选要打包spring boot应用，你在pom文件中看到的spring-boot-maven-plugin插件就是打包spring boot应用的。<br>进入工程目录   运行mvn package 进行打包<br><img src="https://viabcde.github.io/images/201811/20181108.png" alt="enter descriptionhere"><br>打包之后的文件在工程目录的target目录  使用java的原生命令执行生成的jar文件<br>java  -jar  spring-boot-demo01.jar –server.port=9090  启动spring boot 项目</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回调函数</title>
      <link href="/2018/11/13/2018-11-13-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
      <url>/2018/11/13/2018-11-13-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a><strong>回调函数</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-19/回调.png" alt="enter description here"><br>回调也称委托<br>即类a执行过程中无法完成的逻辑交由类b来完成，完成后并继续执行该委托任务的后续所有方法（这些方法在类a中已有定义，称为回调函数）。<br>A：这工程我做了一半，后面的我做不了了，交给你吧，需要资料找我要<br>B: 好的。我需要xxx<br>这里的xxx就是回调函数 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Boot-Starter</title>
      <link href="/2018/11/13/2018-11-13-spring-boot-starter-web/"/>
      <url>/2018/11/13/2018-11-13-spring-boot-starter-web/</url>
      
        <content type="html"><![CDATA[<h3 id="1-常见的starter会包几个方面的内容？分别是什么？"><a href="#1-常见的starter会包几个方面的内容？分别是什么？" class="headerlink" title="1.常见的starter会包几个方面的内容？分别是什么？"></a><strong>1.常见的starter会包几个方面的内容？分别是什么？</strong></h3><p><strong>自动配置文件</strong><br><strong>spring.factories</strong><br>指导Spring Boot找到指定的自动配置文件<br><strong>endpoint</strong><br>包含对服务的描述、界面、交互(业务信息的查询)<br><strong>health indicator</strong><br>提供的服务的健康指标   </p><h2 id="ConditionalOnMissingBean的作用是"><a href="#ConditionalOnMissingBean的作用是" class="headerlink" title="@ConditionalOnMissingBean的作用是"></a><strong>@ConditionalOnMissingBean的作用是</strong></h2><p>如果用户自己手动创建的bean，则不用它修饰的初始化代码块    </p><h2 id="Spring-Boot-Starter找到自动配置文件-xxxxAutoConfiguration之类的文件-的方式有两种："><a href="#Spring-Boot-Starter找到自动配置文件-xxxxAutoConfiguration之类的文件-的方式有两种：" class="headerlink" title="Spring Boot Starter找到自动配置文件(xxxxAutoConfiguration之类的文件)的方式有两种："></a><strong>Spring Boot Starter找到自动配置文件(xxxxAutoConfiguration之类的文件)的方式有两种：</strong></h2><p>1.spring.factories:由<strong>Spring Boot触发</strong>找classpath目录下的类，进行自动配置<br>2.@EnableXxxxx:有时需要由starter的<strong>用户触发</strong>查找自动配置文件  </p><h2 id="Spring-Boot-Starter的工作原理："><a href="#Spring-Boot-Starter的工作原理：" class="headerlink" title="Spring Boot Starter的工作原理："></a><strong>Spring Boot Starter的工作原理：</strong></h2><p>Spring Boot 在启动时扫描寻找包含spring.factories文件的JAR<br>根据spring.factories配置加载AutoConfigure类<br>根据 @Conditional注解的条件，进行自动配置并将Bean注入Spring Context   </p><h3 id="3-谈谈对Spring-Boot的认识"><a href="#3-谈谈对Spring-Boot的认识" class="headerlink" title="3.谈谈对Spring Boot的认识"></a><strong>3.谈谈对Spring Boot的认识</strong></h3><p>它可用于创建可执行的Spring应用程序，它的@EnableAutoConfiguration注解自动载入应用程序所需的所有Bean——这依赖于Spring Boot在类路径中的查找。<br><strong>@Enablexx注解</strong><br>@EnableTransactionManagement注解:声明事务管理<br>@EnableWebMvc注解:启用Spring MVC<br>@EnableScheduling注解:初始化一个调度器<br><strong>属性映射</strong><br>下面看MongoProperties类，它是一个Spring Boot属性映射的例子：</p><pre><code>@ConfigurationProperties(prefix = &quot;spring.data.mongodb&quot;)public class MongoProperties {    private String host;    private int port = DBPort.PORT;    private String uri = &quot;mongodb://localhost/test&quot;;    private String database;    // ... getters/ setters omitted}</code></pre><p><strong>@ConfigurationProperties注解:</strong> 将POJO关联到指定前缀的每一个属性。<br>例如，spring.data.mongodb.port属性将映射到这个类的端口属性。<br>强烈建议Spring Boot开发者使用这种方式来删除与配置属性相关的瓶颈代码。<br><strong>@Conditional注解</strong><br>此注解使得只有在特定条件满足时才启用一些配置<br>@ConditionalOnBean<br>@ConditionalOnClass<br>@ConditionalOnExpression<br>@ConditionalOnMissingBean<br>@ConditionalOnMissingClass<br>@ConditionalOnNotWebApplication<br>@ConditionalOnResource<br>@ConditionalOnWebApplication<br><strong>应用程序上下文初始化器</strong><br>spring.factories还提供了第二种可能性，即定义应用程序的初始化。这使得我们可以在应用程序载入前操纵Spring的应用程序上下文ApplicationContext。<br>特别是，可以在上下文创建监听器，使用ConfigurableApplicationContext类的addApplicationListener()方法。<br>AutoConfigurationReportLoggingInitializer监听到系统事件时，比如上下文刷新或应用程序启动故障之类的事件，Spring Boot可以执行一些工作。这有助于我们以调试模式启动应用程序时创建自动配置的报告。<br>要以调试模式启动应用程序，可以使用-Ddebug标识，或者在application.properties文件这添加属性debug= true。   </p><h3 id="4-自定义springboot-starter注意事项"><a href="#4-自定义springboot-starter注意事项" class="headerlink" title="4.自定义springboot-starter注意事项"></a><strong>4.自定义springboot-starter注意事项</strong></h3><p>// 1. springboot默认scan的包名是其main类所在的包名。如果引入的starter包名不一样，需要自己添加scan。<br>@ComponentScan(basePackages = {“com.xixicat.demo”,”com.xixicat.sms”})<br>// 2. 对于starter中有feign的，需要额外指定<br>@EnableFeignClients(basePackages = {“com.xixicat.sms”})<br>// 3. 对于exclude一些autoConfig<br>@EnableAutoConfiguration(exclude = {MetricFilterAutoConfiguration.class})     </p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Forward和redirect的区别</title>
      <link href="/2018/11/13/2018-11-13-forward%E5%92%8Credirect%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/11/13/2018-11-13-forward%E5%92%8Credirect%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="forward和redirect的区别"><a href="#forward和redirect的区别" class="headerlink" title="forward和redirect的区别"></a><strong>forward和redirect的区别</strong></h2><h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a><strong>请求转发</strong></h3><p>forword 一次请求，地址栏不变。比如你要问小李借钱，小李说没钱，但是小李帮你从小王那借了钱。<br>这样借钱的路径就一条：到小李家借钱  </p><h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a><strong>请求重定向</strong></h3><p>redirect 两次请求，地址栏变。   同样是问小李借钱，小李说没钱，但是小李告诉你小王有钱，告诉你了小王在哪，这时你就得去小王家借钱，最终借到了钱。<br>这样借钱的路径变成2条，先到小李家，再到小王家  </p><h3 id="forward和redirect的区别-1"><a href="#forward和redirect的区别-1" class="headerlink" title="forward和redirect的区别"></a><strong>forward和redirect的区别</strong></h3><p>•用法不同: 记住一个原则： 给服务器用的直接从资源名开始写，给浏览器用的要把应用名写上<br>◦request.getRequestDispatcher(“/资源名 URI”).forward(request,response)<br>◦转发时”/“代表的是本应用程序的根目录<br>◦response.send(“/web应用/资源名 URI”);<br>◦重定向时”/“代表的是webapps目录<br>因为他们能够去往的URL的范围不一样: ◦转发是服务器跳转只能去往当前web应用的资源，即服务器范围内<br>◦重定向是服务器跳转，可以去往任何的资源，整个网络，所以必须知名应用名<br>•传递数据的类型不同 ◦转发的request对象可以传递各种类型的数据，包括对象<br>◦重定向只能传递字符串<br>•跳转的时间不同 ◦转发时：执行到跳转语句时就会立刻跳转<br>◦重定向：整个页面执行完之后才执行跳转      </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Statement PreparedStatement CallableStatement的区别</title>
      <link href="/2018/11/13/2018-11-13-Statement%20PreparedStatement%20CallableStatement%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/11/13/2018-11-13-Statement%20PreparedStatement%20CallableStatement%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="Statement-PreparedStatement-CallableStatement的区别"><a href="#Statement-PreparedStatement-CallableStatement的区别" class="headerlink" title="Statement PreparedStatement CallableStatement的区别"></a><strong>Statement PreparedStatement CallableStatement的区别</strong></h2><p>1.Statement、PreparedStatement和CallableStatement都是接口(interface)。<br>2.Statement继承自Wrapper、PreparedStatement继承自Statement、CallableStatement继承自PreparedStatement。  </p><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a><strong>Statement</strong></h3><p>用于不带参的查询，支持批量更新,批量删除;   </p><h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a><strong>PreparedStatement</strong></h3><p>用于执行参数化查询  预编译完的sql，只需传入参数即可，可以阻止常见的SQL注入式攻击    可变参数的SQL,编译一次,执行多次,效率高;    安全性好，有效防止Sql注入等问题;  支持批量更新,批量删除; </p><h3 id="CallableStatement"><a href="#CallableStatement" class="headerlink" title="CallableStatement"></a><strong>CallableStatement</strong></h3><p>用于存储过程  继承自PreparedStatement,支持带参数的SQL操作;  支持调用存储过程,提供了对输出和输入/输出参数(INOUT)的支持;  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部类的4种实现方式</title>
      <link href="/2018/11/12/2018-11-12-%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2018/11/12/2018-11-12-%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>为什么需要内部类：当某个类只单独为另一个类提供服务时，可把该类写成内部类<br>成员内部类和局部内部类的区别，一个是和外部内的变量方法同一等级，一个是在外部内的某一个方法中定义的类<br><strong>静态内部类是类中的类 但是它是静态的</strong></p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a><strong>静态内部类</strong></h3><pre><code>public class Test {    public static void main(String[] args) {       Outer.Inner inner =new Outer.Inner();    }}class Outer{    static class Inner{    }}</code></pre><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a><strong>匿名内部类</strong></h3><pre><code>this.addWindowListener(new WindowAdapter(){           @Override           public   void windowClosing(WindowEvent e) {              System.exit(0);           }          });this.addKeyListener(new KeyAdapter(){           @Override           public   void keyPressed(KeyEvent e) {              //   TODO Auto-generated method stub              myTank.keyPressed(e);           }           @Override           public   void keyReleased(KeyEvent e) {              //   TODO Auto-generated method stub              myTank.keyReleased(e);           }});</code></pre><p>局部内部类是方法里的类 成员内部类是类中的类</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a><strong>局部内部类</strong></h3><pre><code>public class Test {    public void show(){       class Inner{           public void fun(){              System.out.println(&quot;helloworld&quot;);           }       }       new Inner().fun();    }    public static void main(String[] args) {       new Test().show();    }}</code></pre><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a><strong>成员内部类</strong></h3><pre><code>public class Outer {    private int age=10;    class Inner{       int age=20;       public void show(){           int age=30;           System.out.println(&quot;内部类方法里的局部变量age:&quot;+age);           System.out.println(&quot;内部类的成员变量age:&quot;+this.age);           System.out.println(&quot;外部类的成员变量age:&quot;+Outer.this.age);       }    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰者模式</title>
      <link href="/2018/11/12/2018-11-12-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/12/2018-11-12-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="创建基类"><a href="#创建基类" class="headerlink" title="创建基类"></a><strong>创建基类</strong></h3><pre><code>public abstract class Person {    String description = &quot;Unkonwn&quot;;    public String getDescription()    {        return description;    }    public abstract double cost(); //子类应该实现的方法}</code></pre><h3 id="被修饰者类"><a href="#被修饰者类" class="headerlink" title="被修饰者类"></a><strong>被修饰者类</strong></h3><pre><code>public class Teenager extends Person {    public Teenager() {        description = &quot;Shopping List:&quot;;    }    @Override    public double cost() {        //什么都没买，不用钱        return 0;    }}</code></pre><h3 id="修饰者"><a href="#修饰者" class="headerlink" title="修饰者"></a><strong>修饰者</strong></h3><p>第一个装饰部门</p><pre><code>public abstract class ClothingDecorator extends Person {    public abstract String getDescription();}</code></pre><p>第二个装饰者部门</p><pre><code>public abstract class HatDecorator extends Person {    public abstract String getDescription();}</code></pre><h3 id="创建具体装饰者"><a href="#创建具体装饰者" class="headerlink" title="创建具体装饰者"></a><strong>创建具体装饰者</strong></h3><p>第一个装饰者</p><pre><code>public class Shirt extends ClothingDecorator {    //用实例变量保存Person的引用    Person person;    public Shirt(Person person)    {        this.person = person;    }    @Override    public String getDescription() {        return person.getDescription() + &quot;a shirt  &quot;;    }    @Override    public double cost() {        return 100 + person.cost(); //实现了cost()方法，并调用了person的cost()方法，目的是获得所有累加值    }}</code></pre><p>第二个装饰者</p><pre><code>public class Casquette extends HatDecorator {    Person person;    public Casquette(Person person) {        this.person = person;    }    @Override    public String getDescription() {        return person.getDescription() + &quot;a casquette  &quot;; //鸭舌帽    }    @Override    public double cost() {        return 75 + person.cost();    }}</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h3><pre><code>public class Shopping {    public static void main(String[] args) {        Person person = new Teenager();        person = new Shirt(person);        person = new Casquette(person);        System.out.println(person.getDescription() + &quot; ￥ &quot; +person.cost());    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="/2018/11/12/2018-11-12-%E5%BC%82%E5%B8%B8/"/>
      <url>/2018/11/12/2018-11-12-%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h3><p>异常分为ERROR和Exception<br>Error 环境问题 计算机问题<br>Exceprion包括运行时异常（数组越界等）和编译异常（语法错误）<br>运行异常 如IOException    编译异常 语法错误<br><strong>除了虚拟机给我们抛出的异常外，有时还需要程序员自己主动抛异常</strong><br>如在一个用户交互的环境下，想知道是哪个用户的输入导致了异常，这个时候系统产生的异常堆栈信息就不能满足我们的要求了，而这个信息在当前类的一个字段中，这时候我们就要主动捕获然后打印出我们想要的。</p><h3 id="解决异常的常用方法思路"><a href="#解决异常的常用方法思路" class="headerlink" title="解决异常的常用方法思路"></a><strong>解决异常的常用方法思路</strong></h3><p>1.写个再试执行一次的代码<br>2.修饰错误页面为友好的错误提示<br>3.用try/catch捕获手工错误的异常<br> <strong>1.对于偶发异常 使用重复尝试</strong><br>例如：当前Socket连接不可用（长时间不用被服务器主动断开，或者网络抖动导致的断开），那么我们捕获这个异常，然后重新建立一个连接来发送。<br>这是最基本的解决方法，再高级一点的就是设置一个重复次数，当出现异常的时候重复发送指定的次数。<br>本质上并没有解决异常，而是解决了连接断开的问题</p><pre><code>//有一个连接中的socketSocket socket=...//要发送的数据String data=&quot;&quot;;try{    socket.write(data);}catch (Excetption e){    //打印日志，并重连Socket    socket=new Socket(host,port);    socket.write(data);}</code></pre><h3 id="2-不想让用户看到堆栈-影响用户体验"><a href="#2-不想让用户看到堆栈-影响用户体验" class="headerlink" title="2.不想让用户看到堆栈 影响用户体验"></a><strong>2.不想让用户看到堆栈 影响用户体验</strong></h3><p>用一个最大的try catch包住一个个方法，当出现异常的时候跳转到友好的错误页面。<br>本质上也没有解决异常，而是用try/catch吞掉了</p><pre><code>public String method(String param){  try {    //逻辑处理  } catch (Exception e) {    e.printStackTrace();    //跳转到错误页面  }}</code></pre><h3 id="对于一定不会出现的异常"><a href="#对于一定不会出现的异常" class="headerlink" title="对于一定不会出现的异常"></a><strong>对于一定不会出现的异常</strong></h3><pre><code>import java.io.UnsupportedEncodingException;public class Utils {  public static String utf8(byte[] bytes) throws UnsupportedEncodingException{    return new String(bytes,&quot;UTF-8&quot;);  }  public static byte[] utf8(String str) throws UnsupportedEncodingException{    return str.getBytes(&quot;UTF-8&quot;);  }}</code></pre><p>就使用try/catch吞了，并打印异常信息，因为可能出现人为输入错误<br>修改如下：  </p><pre><code>public static String utf8(byte[] bytes){  try {    return new String(bytes,&quot;UFO-8&quot;);  } catch (UnsupportedEncodingException e) {    e.printStackTrace();  }  return null;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android</title>
      <link href="/2018/11/12/2018-11-12-Android/"/>
      <url>/2018/11/12/2018-11-12-Android/</url>
      
        <content type="html"><![CDATA[<pre><code>android:id=&quot;@+id/textView&quot;         textView代表该控件的名字android:layout_width=&quot;wrap_content&quot;      控件宽度 wrap_content表示只包含所显示的字符即可android:text=&quot;江苏省GDP排名前三的城市有：&quot;         该控件显示的字android:textSize=&quot;22sp&quot; 显示的字符的大小android:layout_below=&quot;@+id/textView&quot;  表示该控件位于一个名为textView下方</code></pre><h3 id="获取控件示例"><a href="#获取控件示例" class="headerlink" title="获取控件示例"></a><strong>获取控件示例</strong></h3><p>findViewById(R.id.)<br>myTextView = (TextView) findViewById(R.id.textView); </p><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a><strong>hello world</strong></h3><p><strong>效果图</strong><br>app\src\main\res\values\strings.xml<br>\app\src\main\res\drawable\androidlover.jpg<br>app\src\main\res\layout\content_main.xml<br>\app\src\main\java\com\easybook\android\helloworld\MainActivity.java  </p><h3 id="字符显示和编辑TextView-EditText"><a href="#字符显示和编辑TextView-EditText" class="headerlink" title="字符显示和编辑TextView/EditText"></a><strong>字符显示和编辑TextView/EditText</strong></h3><p><strong>效果图</strong><br>修改一下文件：<br>content_main.xml<br>MainActivity.java  </p><h3 id="按钮和图片按钮"><a href="#按钮和图片按钮" class="headerlink" title="按钮和图片按钮"></a><strong>按钮和图片按钮</strong></h3><p>\app\src\main\res\values\strings.xml<br>\app\src\main\res\layout\content_main.xml<br>\app\src\main\java\com\easybook\android\helloworld\MainActivity.java  </p><h3 id="复选框CheckBox"><a href="#复选框CheckBox" class="headerlink" title="复选框CheckBox"></a><strong>复选框CheckBox</strong></h3><p><strong>源代码地址：</strong><br><strong>效果图</strong><br>\app\src\main\res\layout\content_main.xml<br>\app\src\main\java\com\easybook\android\helloworld\MainActivity.java  </p><h3 id="单选按钮RadioGroup里放置多个RadioButton"><a href="#单选按钮RadioGroup里放置多个RadioButton" class="headerlink" title="单选按钮RadioGroup里放置多个RadioButton"></a><strong>单选按钮RadioGroup里放置多个RadioButton</strong></h3><p><strong>效果图</strong><br>\app\src\main\res\layout\content_main.xml<br>\app\src\main\java\com\easybook\android\helloworld\MainActivity.java  </p><h3 id="下拉列表Spinner"><a href="#下拉列表Spinner" class="headerlink" title="下拉列表Spinner"></a><strong>下拉列表Spinner</strong></h3><p><strong>效果图</strong><br>\app\src\main\res\layout\content_main.xml<br>\app\src\main\java\com\easybook\android\helloworld\MainActivity.java  </p><h3 id="列表框ListView"><a href="#列表框ListView" class="headerlink" title="列表框ListView"></a><strong>列表框ListView</strong></h3><p><strong>效果图</strong><br>\app\src\main\res\layout\content_main.xml<br>\app\src\main\java\com\easybook\android\helloworld\MainActivity.java  </p><h3 id="按键事件"><a href="#按键事件" class="headerlink" title="按键事件"></a><strong>按键事件</strong></h3><p><strong>效果图</strong><br>\app\src\main\res\layout\content_main.xml<br>\app\src\main\java\com\easybook\android\helloworld\MainActivity.java  </p><h3 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a><strong>触摸事件</strong></h3><p><strong>效果图</strong><br>\app\src\main\res\layout\content_main.xml<br>\app\src\main\java\com\easybook\android\helloworld\MainActivity.java </p><h3 id="触摸事件-1"><a href="#触摸事件-1" class="headerlink" title="触摸事件"></a><strong>触摸事件</strong></h3><p><strong>效果图</strong><br>\app\src\main\res\layout\content_main.xml<br>\app\src\main\java\com\easybook\android\helloworld\MainActivity.java<br>app\src\main\AndroidManifest.xml<br>app\src\main\res\drawable.png</p><h3 id="高级控件应用WebView"><a href="#高级控件应用WebView" class="headerlink" title="高级控件应用WebView"></a><strong>高级控件应用WebView</strong></h3><p><strong>效果图</strong><br>\app\src\main\res\layout\content_main.xml<br>\app\src\main\java\com\easybook\android\helloworld\MainActivity.java<br>app\src\main\AndroidManifest.xml<br>app\src\main\res\drawable.png</p><h3 id="滚动预览控件HorizontalScrollView"><a href="#滚动预览控件HorizontalScrollView" class="headerlink" title="滚动预览控件HorizontalScrollView"></a><strong>滚动预览控件HorizontalScrollView</strong></h3><p><strong>效果图</strong><br>\app\src\main\res\layout\content_main.xml<br>\app\src\main\java\com\easybook\android\helloworld\MainActivity.java<br>app\src\main\AndroidManifest.xml<br>app\src\main\res\drawable.png</p><h3 id="照片查看器ImageSwitcher"><a href="#照片查看器ImageSwitcher" class="headerlink" title="照片查看器ImageSwitcher"></a><strong>照片查看器ImageSwitcher</strong></h3><p><strong>效果图</strong><br>\app\src\main\res\layout\content_main.xml<br>\app\src\main\java\com\easybook\android\helloworld\MainActivity.java<br>app\src\main\res\drawable.png</p><h3 id="条类控制器SeekBar-RatingBar"><a href="#条类控制器SeekBar-RatingBar" class="headerlink" title="条类控制器SeekBar/RatingBar"></a><strong>条类控制器SeekBar/RatingBar</strong></h3><p><strong>效果图</strong><br>\app\src\main\res\layout\content_main.xml<br>\app\src\main\java\com\easybook\android\helloworld\MainActivity.java<br>app\src\main\res\drawable.png</p><h3 id="线性布局LinearLayout"><a href="#线性布局LinearLayout" class="headerlink" title="线性布局LinearLayout"></a><strong>线性布局LinearLayout</strong></h3><p><strong>效果图</strong><br>\app\src\main\res\layout\content_main.xml<br><strong>替换aaa文件即可</strong><br><strong>相对布局</strong><br><strong>表格布局</strong><br><strong>网格布局</strong>  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ssh员工管理系统</title>
      <link href="/2018/11/10/2018-11-10-ssh%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2018/11/10/2018-11-10-ssh%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>源码地址：<a href="https://github.com/viabcde/mycoding.github.io" target="_blank" rel="noopener">ssh</a>  </p><h3 id="Description-Resource-Path-Location-Type"><a href="#Description-Resource-Path-Location-Type" class="headerlink" title="Description    Resource    Path    Location    Type"></a>Description    Resource    Path    Location    Type</h3><p>The method getModel() of type ProductAction must override a superclass method    ProductAction.java    /30-ssh-simple/src/main/java/com/myimooc/ssh/simple/action    line 35    Java Problem<br>更改jdk版本及其编译版本为1.6<br>这里只是示例怎么改，我实际测试的时候1.8不能，1.6可以<br><img src="https://viabcde.github.io/images/201812/20.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/201812/21.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/201812/22.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/201812/23.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/201812/24.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/201812/25.png" alt="enter descriptionhere"><br>之后点确定<br><img src="https://viabcde.github.io/images/201812/26.png" alt="enter descriptionhere"><br>更改编译版本<br><img src="https://viabcde.github.io/images/201812/27.png" alt="enter descriptionhere"><br>pom文件中的相关注释：<br>1.modelVersion表示版本信息<br>2.groudId表示公司的信息，具体表现在包名：com/myimooc<br>3.modules表示该项目下面的子模块有哪些</p><pre><code>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.myimooc&lt;/groupId&gt;    &lt;artifactId&gt;30-ssh&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;modules&gt;        &lt;module&gt;30-ssh-simple&lt;/module&gt;        &lt;module&gt;30-ssh-employee&lt;/module&gt;    &lt;/modules&gt;</code></pre><p><strong>效果图：</strong><br>登录页面：<br><img src="https://viabcde.github.io/images/201811/20181116.png" alt="enter descriptionhere"><br><strong>登录后后台页面</strong><br><img src="https://viabcde.github.io/images/201811/20181117.png" alt="enter descriptionhere"><br><strong>员工控制类</strong>    </p><pre><code> * 登录执行的方法：主要是通过用户输入的用户名及密码从数据库里查询是否有用户   * 并把信息存到session中   * 分页的方法   * 增删改查员工信息  </code></pre><p><strong>部门控制类</strong>  </p><pre><code> * 分页的方法   * 增删改查部门信息  </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP</title>
      <link href="/2018/11/09/2018-11-09-JSP/"/>
      <url>/2018/11/09/2018-11-09-JSP/</url>
      
        <content type="html"><![CDATA[<p><strong>JSP全名为Java Server Pages，中文名叫java服务器页面，其根本是一个简化的Servlet设计。它是指在传统的HTML页面中可以插入Java代码段。</strong><br>在处理请求时，JSP引擎从磁盘载入JSP，将所有的JSP元素转为java代码，最终转化为Servlet  ，并将原始请求传递给Servlet引擎   ，执行过程中，Servlet产生的HTML格式的输出将内嵌于http response中交给web服务器  ，<br>服务器再以静态的HTML文件将http response返回到浏览器<br>编译后的JSP对应的Setvlet路径：tomcat7\work\Catalina\localhost文件里   </p><h2 id="页码指令page"><a href="#页码指令page" class="headerlink" title="页码指令page"></a><strong>页码指令page</strong></h2><p>用于定义整个JSP页面的相关属性，这些属性在JSP被服务器解析成Servlet时会转换为相应的Java程序代码<br><strong>language属性</strong><br>用于设置JSP页面使用的语言，目前只支持Java语言，默认值是Java<br><strong>示例</strong>   </p><pre><code>&lt;%@ page language=&quot;java&quot; %&gt;</code></pre><p><strong>extends属性</strong><br>设置JSP页面继承的Java类，JSP和Servlet都可以继承指定的父类，有可能影响服务器的性能优化（不常用）<br><strong>import属性 </strong>   </p><p><code>`</code> &lt;%@ page import=”java.util.*” %&gt;</p><pre><code>**pageEccoding属性 **      定义JSP页面的编码格式</code></pre><p>&lt;%@ page pageEncoding=”GBK”%&gt;</p><pre><code>**contentType属性**    设置JSP页面的MIME类型和字符编码   ``` &lt;%@ page contentType=&quot;text/html; charset=GBK&quot;%&gt;</code></pre><p><strong>session属性</strong><br>指定JSP页面是否使用HTTP的session会话对象，默认值是true</p><p><code>`</code> &lt;%@ page session=”false”%&gt;</p><pre><code>**buffer属性**   设置JSP的out输出对象使用的缓冲区大小，默认大小是8kb   </code></pre><p>&lt;%@ page buffer=”128kb”%&gt;</p><pre><code>**autoFlush属性**   设置JSP页面缓存满的时候，是否自动刷新缓存，默认值为true       </code></pre><p>&lt;%@ page autoFlush=”false”%&gt;</p><pre><code>**info属性**     设置JSP页面的相关信息，这个信息可以在Servlet接口的getServletInfo()方法中获取    </code></pre><p>&lt;%@ page info=”这是一个登录页面，是系统的入口”%&gt;</p><pre><code>**isErrorPage属性**  JSP页面设置成错误处理页面，错误处理页面用于处理另一个JSP页面的错误，也就是异常处理。这意味着当前JSP页面业务的改变   ``` &lt;%@ page isELIgnored=&quot;true&quot;%&gt;</code></pre><p><strong>errorPage属性</strong><br>指定处理当前JSP页面异常错误的另一个JSP页面   </p><p><code>`</code> &lt;%@ page errorPage=”error/loginErrorPage.jsp”%&gt;</p><pre><code>**isELIgnored属性**    定义JSP页面是否忽略EL表达式的使用</code></pre><p>&lt;%@ page isELIgnored=”false”%&gt;</p><pre><code>## **文件包含指令include**静态include的结果是把其他jsp引入当前jsp，两者合为一体;    动态include的结构是两者独立，直到输出时才合并  ``` &lt;%@include file=&quot;validate.jsp&quot; %&gt;</code></pre><p>动态INCLUED用jsp:include动作实现，如下面这行代码它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数。</p><pre><code>&lt;jsp:include page=&quot;included.jsp&quot; flush=&quot;true&quot; /&gt;</code></pre><p>静态INCLUDE用include伪码实现，如下面这行代码不会检查所包含文件的变化，适用于包含静态页面。  </p><pre><code>&lt;%@ include file=&quot;included.htm&quot; %&gt;</code></pre><h2 id="引用标签库指令taglib"><a href="#引用标签库指令taglib" class="headerlink" title="引用标签库指令taglib"></a><strong>引用标签库指令taglib</strong></h2><pre><code>&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</code></pre><p>prefix属性：用于指定标签的前缀。该前缀不能命名为jsp、jspx、java、javax、sun、servlet和sunw<br>uri属性：用于指定标签库文件的存放位置     </p><h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a><strong>代码片段</strong></h2><pre><code>&lt;%      Date now = new Date();      String dateStr;      dateStr = String.format(&quot;%tY年%tm月%td日&quot;, now, now, now);%&gt;</code></pre><h2 id="JSP-表达式"><a href="#JSP-表达式" class="headerlink" title="JSP 表达式"></a><strong>JSP 表达式</strong></h2><p>表达式可以是任何Java语言的完整表达式。<br>例如，如果要在Jsp页面中将圆周率显示，可以在Jsp页面中添加如下代码。   </p><pre><code>圆周率是：&lt;%=Math.PI %&gt;</code></pre><h2 id="JSP有哪些内置对象？作用分别是什么？"><a href="#JSP有哪些内置对象？作用分别是什么？" class="headerlink" title="JSP有哪些内置对象？作用分别是什么？"></a><strong>JSP有哪些内置对象？作用分别是什么？</strong></h2><p> JSP共有9种基本内置组件（可与ASP的6种内部组件相对应）。<br> <strong>request：</strong>用户端请求，此请求会包含来自GET/POST请求的参数。<br><strong>response：</strong>网页传回用户端的回应。<br> <strong>pageContext：</strong>jsp的上下文对象,可以获取其他八个内置对象   <code>pageContext.getOut();</code><br> <strong>Session：</strong>与请求有关的会话。<br> <strong>application：</strong>Servlet正在执行的内容。<br> <strong>out：</strong>向客户端输出数据,字节流.<code>out.print(&quot; dgaweyr&quot;);</code><br> <strong>config：</strong>Servlet的构架部件。<br> <strong>Page：</strong>JSP网页本身。<br> <strong>Exception：</strong>针对错误网页，未 捕捉的例外。  </p><h3 id="JSP四个作用域"><a href="#JSP四个作用域" class="headerlink" title="JSP四个作用域"></a><strong>JSP四个作用域</strong></h3><p> page—request—session—Application</p><h2 id="JSP有哪些动作？它们的作用分别是什么？"><a href="#JSP有哪些动作？它们的作用分别是什么？" class="headerlink" title="JSP有哪些动作？它们的作用分别是什么？"></a><strong>JSP有哪些动作？它们的作用分别是什么？</strong></h2><p>// JSP共有以下6种基本动作。<br>// jsp:include： 在网页被请求的时候引入一个文件。<br>// jsp:userBean： 寻找或者实例化一个JavaBean。<br>// jsp:setProperty： 设置JavaBean的属性。<br>// jsp:getProperty： 输出某个JavaBean的属性。<br>// jsp:forward： 把请求转到一个新的页面。<br>// jsp:plugin： 根据浏览器类型为Java插件生成OBJECT或EMBED标记。  </p><h2 id="JSP两种跳转方式分别是什么？有什么区别？"><a href="#JSP两种跳转方式分别是什么？有什么区别？" class="headerlink" title="JSP两种跳转方式分别是什么？有什么区别？"></a><strong>JSP两种跳转方式分别是什么？有什么区别？</strong></h2><p>// 两种跳转方式分别如下。  </p><pre><code>&lt;jsp:include page=&quot;included.jsp&quot; flush=&quot;true&quot;&gt;&lt;jsp:forward page=&quot;nextpage.jsp&quot; /&gt;</code></pre><p>// 前者页面不会转向include所指的页面，只是显示该页的结果，主页面还是原来的页面。执行完以后还会回来，相当于函数调用，并且可以带参数。后者完全转向新页面，不会再回来，相当于GOTO语句。</p><h2 id="使用JSP代码和使用JavaScript进行表单数据验证有什么不同？"><a href="#使用JSP代码和使用JavaScript进行表单数据验证有什么不同？" class="headerlink" title="使用JSP代码和使用JavaScript进行表单数据验证有什么不同？"></a><strong>使用JSP代码和使用JavaScript进行表单数据验证有什么不同？</strong></h2><p>// JavaScript为脚本程序，可以在表单提交前在客户端验证，提高了验证速度，不会使表单内信息丢失。JSP验证需要向服务器请求，服务器对请求页面进行重新编译，并验证数据的合法性，使得服务器负担加重，且验证结果返回较慢，容易使填写的表单信息丢失。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中文乱码问题</title>
      <link href="/2018/11/09/2018-11-09-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
      <url>/2018/11/09/2018-11-09-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="jsp中四种传递参数的方法"><a href="#jsp中四种传递参数的方法" class="headerlink" title="jsp中四种传递参数的方法"></a>jsp中四种传递参数的方法</h2><pre><code>1、form表单  2、request.setAttribute();和request.getAttribute();  3、超链接  &lt;a herf=&quot;index.jsp&quot;?a=a&amp;b=b&amp;c=c&gt;name&lt;/a&gt;4、&lt;jsp:param&gt;  </code></pre><h3 id="form表单"><a href="#form表单" class="headerlink" title="form表单"></a><strong>form表单</strong></h3><p><strong>form.jsp</strong></p><pre><code>&lt;%@page contentType=&quot;text/html; charset=GB2312&quot;%&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;            form.jsp file        &lt;/title&gt;    &lt;/head&gt;    &lt;body style=&quot;background-color:lightblue&quot;&gt;        &lt;h2 style=&quot;font-family:arial;color:red;font-size:25px;text-align:center&quot;&gt;登录页面&lt;/h2&gt;        &lt;form action=&quot;result.jsp&quot; method=&quot;get&quot; align=&quot;center&quot;&gt;            姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; size=&quot;20&quot; value=&quot;&quot; maxlength=&quot;20&quot;&gt;&lt;br/&gt;            密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; size=&quot;20&quot; value=&quot;&quot; maxlength=&quot;20&quot;&gt;&lt;br/&gt;             &lt;!--在爱好前空一个空格，是为了排版好看些--&gt;            &amp;nbsp;爱好：&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;唱歌&quot;&gt;唱歌                  &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;足球&quot;&gt;足球                  &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;篮球&quot;&gt;篮球&lt;br/&gt;&lt;br/&gt;            &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;登录&quot;&gt;            &lt;input type=&quot;reset&quot; name=&quot;reset&quot; value=&quot;重置&quot;&gt;&lt;br/&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>result.jsp</strong></p><pre><code>&lt;%@page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;GB2312&quot;%&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;            result.jsp file        &lt;/title&gt;    &lt;/head&gt;    &lt;body bgcolor=&quot;ffffff&quot;&gt;        &lt;%          request.setCharacterEncoding(&quot;GB2312&quot;);          String name=request.getParameter(&quot;name&quot;);          name=new String(name.getBytes(&quot;iso-8859-1&quot;),&quot;GB2312&quot;);          String pwd=request.getParameter(&quot;password&quot;);          String[] hobby=request.getParameterValues(&quot;hobby&quot;);//注意这里的函数是getParameterValues()接受一个数组的数据        %&gt;        &lt;%            if(!name.equals(&quot;&quot;) &amp;&amp; !pwd.equals(&quot;&quot;))            {        %&gt;                您好！登录成功！&lt;br/&gt;                姓名：&lt;%=name%&gt;&lt;br/&gt;                密码：&lt;%=pwd%&gt;&lt;br/&gt;                爱好：&lt;%                         for(String ho: hobby)                         {                            ho=new String(ho.getBytes(&quot;iso-8859-1&quot;),&quot;GB2312&quot;);                            out.print(ho+&quot; &quot;);                         }                       %&gt;        &lt;%            }            else            {        %&gt;                    请输入姓名或密码！        &lt;%            }        %&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>注意：form表单的提交方式为get，在参数传递时会遇到中文乱码的问题:<br><strong>解决方法</strong>:将接受到的字符串先转换成一个byte数组，再用String构造一个新的编码格式的String，如：  </p><pre><code>String name=request.getParameter(&quot;name&quot;);   name=new String(name.getBytes(&quot;iso-8859-1&quot;),&quot;GB2312&quot;);  </code></pre><p>如果form表单的提交方式为post<br><strong>解决办法:</strong> 使用 request.setCharacterEncoding(“GB2312”);设置request的编码方式。    </p><h2 id="ps-为什么会出现中文乱码问题呢？"><a href="#ps-为什么会出现中文乱码问题呢？" class="headerlink" title="ps: 为什么会出现中文乱码问题呢？"></a><strong>ps: 为什么会出现中文乱码问题呢？</strong></h2><pre><code>因为Tomcat服务器默认的系统编码方式为iso-8859-1，你传递参数给服务器时，使用的是默认的iso-8859-1的编码方式，但是服务器向你返回信息时，是按page指令中设置的编码方式，如：&lt;%@page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;GB2312&quot;%&gt;，这样就混合了两种编码方式，所以会出现乱码，所以解决之道就是统一传递和接收的编码方式。  </code></pre><h3 id="request-setAttribute-和request-getAttribute"><a href="#request-setAttribute-和request-getAttribute" class="headerlink" title="request.setAttribute()和request.getAttribute()"></a><strong>request.setAttribute()和request.getAttribute()</strong></h3><p><strong>set.jsp</strong></p><pre><code>&lt;%@page contentType=&quot;text/html; charset=GB2312&quot;%&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;            set.jsp file        &lt;/title&gt;    &lt;/head&gt;    &lt;body style=&quot;background-color:lightblue&quot;&gt;        &lt;%            request.setAttribute(&quot;name&quot;,&quot;心雨&quot;);        %&gt;        &lt;jsp:forward page=&quot;get.jsp&quot;/&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>get.jsp</strong></p><pre><code>&lt;%@page contentType=&quot;text/html; charset=GB2312&quot;%&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;            get.jsp file        &lt;/title&gt;    &lt;/head&gt;    &lt;body style=&quot;background-color:lightblue&quot;&gt;        &lt;%            out.println(&quot;传递过来的参数是：&quot;+request.getAttribute(&quot;name&quot;));        %&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>request.setAttribute()和request.getAttribute()是配合<a href="jsp:forward" target="_blank" rel="noopener">jsp:forward</a>或是include指令来实现的。</p><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><pre><code>&lt;a herf=&quot;index.jsp?a=a&amp;b=b&amp;c=c&quot;&gt;name&lt;/a&gt;</code></pre><p><strong>href.jsp</strong></p><pre><code>&lt;%@page contentType=&quot;text/html; charset=GB2312&quot;%&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;            href.jsp file        &lt;/title&gt;    &lt;/head&gt;    &lt;body style=&quot;background-color:lightblue&quot;&gt;        &lt;a href=&quot;getHerf.jsp?name=心雨&amp;password=123&quot;&gt;传递参数&lt;/a&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>getHref.jsp</strong></p><pre><code>&lt;%@page contentType=&quot;text/html; charset=GB2312&quot;%&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;            getHref.jsp file        &lt;/title&gt;    &lt;/head&gt;    &lt;body style=&quot;background-color:lightblue&quot;&gt;        &lt;%            String name=request.getParameter(&quot;name&quot;);            name=new String(name.getBytes(&quot;iso-8859-1&quot;),&quot;gb2312&quot;);            out.print(&quot;name:&quot;+name);        %&gt;        &lt;br/&gt;        &lt;%            out.print(&quot;password:&quot;+request.getParameter(&quot;password&quot;));        %&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>这种传递参数的方法和form表单的get方式类似，是通过地址栏传递的参数，其乱码解决方法也和form 的get方式一样。</p><h3 id="第四种"><a href="#第四种" class="headerlink" title="第四种"></a><strong>第四种</strong></h3><pre><code>&lt;jsp:param&gt;</code></pre><p><strong>param.jsp</strong></p><pre><code>&lt;%@page contentType=&quot;text/html; charset=GB2312&quot;%&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;            param.jsp file        &lt;/title&gt;    &lt;/head&gt;    &lt;body style=&quot;background-color:lightblue&quot;&gt;        &lt;%request.setCharacterEncoding(&quot;GB2312&quot;);%&gt;        &lt;jsp:forward page=&quot;getParam.jsp&quot;&gt;            &lt;jsp:param name=&quot;name&quot; value=&quot;心雨&quot;/&gt;            &lt;jsp:param name=&quot;password&quot; value=&quot;123&quot;/&gt;        &lt;/jsp:forward&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>getParam.jsp</strong></p><pre><code>&lt;%@page contentType=&quot;text/html; charset=GB2312&quot;%&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;            getParam.jsp file        &lt;/title&gt;    &lt;/head&gt;    &lt;body style=&quot;background-color:lightblue&quot;&gt;        &lt;%            String name=request.getParameter(&quot;name&quot;);            out.print(&quot;name:&quot;+name);        %&gt;        &lt;br/&gt;        &lt;%            out.print(&quot;password:&quot;+request.getParameter(&quot;password&quot;));        %&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>在form表单的例子中，如果传递方式为post，则只需要在接收参数的页面设置request的编码方式就可以了，即request.setCharacterEncoding(“GB2312”);<br>注意是在接收参数的页面，如果将该句放到form表单里，那么不起作用，仍然是乱码。而在本例中，为了使传递的参数不出现乱码，却是将request.setCharacterEncoding(“GB2312”);放在发送参数的页面中，才会正常显示中文，放在接收参数的页面中，不起作用。<br>也许这就是<a href="jsp:param" target="_blank" rel="noopener">jsp:param</a>和form表单传递参数不同的地方。    </p><h2 id="为什么会有这个不同呢？"><a href="#为什么会有这个不同呢？" class="headerlink" title="为什么会有这个不同呢？"></a>为什么会有这个不同呢？</h2><p>可能是因为form表单中的参数是由客户端传送到服务端上的，需要经过一个request的打包过程，但是<a href="jsp:param" target="_blank" rel="noopener">jsp:param</a>传递的参数本身就是在服务器端的，不需要经历由客户端到服务端这么一个过程，但是服务器里的参数传递是这么回事呢？这个问题，我不知道了！真是知识是一个扩大的圆圈，你知道的越多，那么不知道的就越多！努力吧！</p><h3 id="1-对于-POST-请求："><a href="#1-对于-POST-请求：" class="headerlink" title="1.对于 POST 请求："></a><strong>1.对于 POST 请求：</strong></h3><p> 设置请求的编码方式：request.setCharacterEncoding(“UTF-8”);<br>注意：必须在获取第一个参数之前设置，并且该方式只对 POST 方式有效。</p><h3 id="2-对于-GET-请求："><a href="#2-对于-GET-请求：" class="headerlink" title="2.对于 GET 请求："></a><strong>2.对于 GET 请求：</strong></h3><p> 重新设置 Tomcat 的编码方式，修改 Tomcat 的配置文件:<br>Tomcat根目录/conf/server.xml(修改端口的那一行)<br><img src="https://viabcde.github.io/images/2018-10-10/2018101007.png" alt="duotai"> </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> BUG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis</title>
      <link href="/2018/10/31/2018-10-31-Mybatis/"/>
      <url>/2018/10/31/2018-10-31-Mybatis/</url>
      
        <content type="html"><![CDATA[<h2 id="Hibernate和Mybatis的区别"><a href="#Hibernate和Mybatis的区别" class="headerlink" title="Hibernate和Mybatis的区别"></a><strong>Hibernate和Mybatis的区别</strong></h2><p>首先Hibernate和Mybatis都是对数据库的封装。<br>区别只是在于封装得彻不彻底。<br>hibernate封装得很彻底,屏蔽了sql语句的编写，更加面向对象，但导致了sql调优的困难，怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。<br>而mybatis则部分屏蔽，是一个不完全ORM框架，sql语句需要自己写，而且把sql写在了配置文件里与代码分离开，通过XML或注解方式配置要运行的sql语句，并将java对象和sql映射生成最终执行的sql，最后将sql执行结果映射成java对象，可严格控制sql执行性能，但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。<br><img src="https://viabcde.github.io/images/all/2018092902.png" alt=""></p><h2 id="引入hibernate的原因"><a href="#引入hibernate的原因" class="headerlink" title="引入hibernate的原因"></a><strong>引入hibernate的原因</strong></h2><p> 面向对象是从软件工程基本原则(如耦合、聚合、封装)的基础上发展起来的，而关系数据库则是从数学理论发展而来的.  引入hibernate解决了关系数据库技术与面向对象不匹配的现象</p><h2 id="什么是Mybatis"><a href="#什么是Mybatis" class="headerlink" title="什么是Mybatis"></a><strong>什么是Mybatis</strong></h2><p>MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。  </p><h2 id="Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis是如何进行分页的？分页插件的原理是什么？"></a><strong>Mybatis是如何进行分页的？分页插件的原理是什么？</strong></h2><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。<br>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。<br>举例：select <em> from student，拦截sql后重写为：select t.</em> from （select * from student）t limit 0，10<br>简述Mybatis的插件运行原理，以及如何编写一个插件<br>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。<br>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。  </p><h3 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a><strong>#{}和${}的区别是什么？</strong></h3><p>在Mybatis中，有两种占位符<br><strong>#{}解析传递进来的参数数据</strong><br>${}对传递进来的参数原样拼接在SQL中<br><strong>#{}是预编译处理，${}是字符串替换。</strong><br>使用#{}可以有效的防止SQL注入，提高系统安全性</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>需要掌握的框架架构知识点</title>
      <link href="/2018/10/31/2018-10-31-%E6%A1%86%E6%9E%B6%E6%9E%B6%E6%9E%84%E9%AB%98%E7%BA%A7/"/>
      <url>/2018/10/31/2018-10-31-%E6%A1%86%E6%9E%B6%E6%9E%B6%E6%9E%84%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="MVC模式（Struts2源码）"><a href="#MVC模式（Struts2源码）" class="headerlink" title="MVC模式（Struts2源码）"></a><strong>MVC模式（Struts2源码）</strong></h2><p> <strong>MVC全名是Model ViewController</strong>  是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范。它主要是实现了层与层之间的屏蔽  </p><h3 id="Model（模型）"><a href="#Model（模型）" class="headerlink" title="Model（模型）"></a><strong>Model（模型）</strong></h3><p> 通常负责在数据库中存取数据。使用的框架：Hibernate、Mybatis  </p><h3 id="View（视图）"><a href="#View（视图）" class="headerlink" title="View（视图）"></a><strong>View（视图）</strong></h3><p>是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。  使用的技术：JSP  </p><h3 id="Controller（控制器）"><a href="#Controller（控制器）" class="headerlink" title="Controller（控制器）"></a><strong>Controller（控制器）</strong></h3><p>是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。使用的框架：SpringMVC、Struts2  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="/2018/10/29/2018-10-29-SpringCloud/"/>
      <url>/2018/10/29/2018-10-29-SpringCloud/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringCloud分布式开发de五大神兽"><a href="#SpringCloud分布式开发de五大神兽" class="headerlink" title="SpringCloud分布式开发de五大神兽"></a><strong>SpringCloud分布式开发de五大神兽</strong></h2><p><strong>•服务发现——Netflix Eureka</strong><br><strong>•服务网关——Netflix Zuul</strong><br><strong>•客服端负载均衡——Netflix Ribbon</strong><br><strong>•断路器——Netflix Hystrix</strong><br><strong>•分布式配置——Spring Cloud Config</strong>  </p><h3 id="Eureka服务治理体系"><a href="#Eureka服务治理体系" class="headerlink" title="Eureka服务治理体系"></a><strong>Eureka服务治理体系</strong></h3><p>用来实现微服务实例自动注册和发现<br><strong>服务提供者</strong>向<strong>服务注册中心</strong>注册服务<br><strong>服务消费者</strong>向<strong>服务注册中心</strong>获取服务列表去寻找服务者<br>服务列表（包括服务的主机与端口号、服务版本号、通讯协议等一些附加信息）<br><strong>服务注册</strong><br>在服务治理框架中，通常都会构建一个注册中心，每个服务单元向注册中心登记自己提供的服务，包括服务的主机与端口号、服务版本号、通讯协议等一些附加信息。注册中心按照服务名分类组织服务清单，同时还需要以心跳检测的方式去监测清单中的服务是否可用，若不可用需要从服务清单中剔除，以达到排除故障服务的效果<br> <strong>服务发现</strong><br>在服务治理框架下，服务间的调用不再通过指定具体的实例地址来实现，而是通过服务名发起请求调用实现。服务调用方通过服务名从服务注册中心的服务清单中获取服务实例的列表清单，通过指定的负载均衡策略取出一个服务实例位置来进行服务调用。</p><h2 id="Zuul路由网关"><a href="#Zuul路由网关" class="headerlink" title="Zuul路由网关"></a><strong>Zuul路由网关</strong></h2><h3 id="1-代理："><a href="#1-代理：" class="headerlink" title="1. 代理："></a><strong>1. 代理：</strong></h3><p>Zuul提供外部的请求转发到具体的微服务实例中的服务  </p><h3 id="2-路由："><a href="#2-路由：" class="headerlink" title="2. 路由："></a><strong>2. 路由：</strong></h3><p>Zuul可以对外部访问实现统一的入口  </p><h3 id="3-过滤："><a href="#3-过滤：" class="headerlink" title="3. 过滤："></a><strong>3. 过滤：</strong></h3><p>Zuul可以对外部访问进行干预，如请求校验、服务聚合等  </p><h3 id="4-Zuul需要配合Eureka使用，"><a href="#4-Zuul需要配合Eureka使用，" class="headerlink" title="4. Zuul需要配合Eureka使用，"></a><strong>4. Zuul需要配合Eureka使用，</strong></h3><p>需要在Eureka中注册并获得其他微服务的信息  </p><h3 id="5-理解："><a href="#5-理解：" class="headerlink" title="5. 理解："></a><strong>5. 理解：</strong></h3><p>Zuul就像大楼的保安，可以请他找人（代理），找的人在外面叫什么名字（路由），准不准你进楼（过滤）。因为保安属于物业公司，所以保安要在物业公司注册，所获得的信息也来源于物业公司（与Eureka的关系）。<br> <a href="http://github.com/Netflix/zuul" target="_blank" rel="noopener">Zuul的源码</a>    </p><h3 id="zuul的基本配置"><a href="#zuul的基本配置" class="headerlink" title="zuul的基本配置"></a><strong>zuul的基本配置</strong></h3><p><strong>第一步：构建新的Zuul模块并在pom.xml中加入依赖（Zuul和Eureka必须同时加入）；</strong>  </p><pre><code>&lt;dependencies&gt;        &lt;!-- zuul路由网关 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- actuator监控 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- hystrix容错 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- 日常标配 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.wangcw.springcloud&lt;/groupId&gt;            &lt;artifactId&gt;springclouddemo-api&lt;/artifactId&gt;            &lt;version&gt;${project.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- 热部署插件 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;springloaded&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p><strong>第二步：新建application.yml文件并配置（一定要向Eureka注册，因为Zuul本身也是一个微服务）；</strong></p><pre><code>server:   port: 6001spring:   application:    name: microservicecloud-zuul-gatewayeureka:   client: #客户端注册进eureka服务列表内    service-url:       defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  instance:    instance-id: gateway-zull-6001    prefer-ip-address: true #配置微服务的info信息info:  app.name: wangcw-dept-provider  company.name: www.amoins.top  build.artifactId: $project.artifactId$  build.version: $project.version$</code></pre><p><strong>第三步： 修改hosts文件（非必须，不过能更好看出效果）</strong></p><pre><code>127.0.0.1        zuul.com</code></pre><p><strong>第四步：创建主启动类，并加入@EnableZuulProxy注解</strong></p><pre><code>@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class})@EnableZuulProxypublic class Zuul_6001_App{    public static void main(String[] args)    {        SpringApplication.run(Zuul_6001_App.class, args);    }}</code></pre><p><strong>第五步：启动测试，访问规则：步骤3中指定映射域名 + 端口号 + 微服务名称 + 访问路径。</strong><br>   例子：<a href="http://zuul.com:6001/springclouddemo-provider-dept/provider/dept/list" target="_blank" rel="noopener">http://zuul.com:6001/springclouddemo-provider-dept/provider/dept/list</a><br><img src="https://viabcde.github.io/images/2018-10-10/2018101024.png" alt="enter descriptionhere"> </p><h3 id="路由访问映射规则"><a href="#路由访问映射规则" class="headerlink" title="路由访问映射规则"></a><strong>路由访问映射规则</strong></h3><pre><code>服务名映射和统一公共前缀 : 当不想暴露真实的服务名时，可以对服务名进行映射，只需在application.yml中配置即可。配置如下：</code></pre><pre><code>zuul:   prefix: /wangcw        #设置统一公共前缀   ignored-services: &quot;*&quot;  #对外隐藏所有的服务名，可以使用通配符，配置之后通过这个微服务名访问就失效了，外部无法访问，但是微服务内部依然可用   routes:     mydept.serviceId: springclouddemo-provider-dept     mydept.path: /zull-dept/**          # 访问/zull-dept/*相当于访问微服务【springclouddemo-provider-dept】     #最终访问路径变成了 zuul.com:6001/wangcw/zull-dept/* </code></pre><p>经过上述配置，访问路径变成  <a href="http://zuul.com:6001/wangcw/zull-dept/provider/dept/list" target="_blank" rel="noopener">http://zuul.com:6001/wangcw/zull-dept/provider/dept/list</a><br>测试结果：<br><img src="https://viabcde.github.io/images/2018-10-10/2018101025.png" alt="enter descriptionhere"><br>注：因为Zuul是针对外部访问管理的，所以配置了隐藏的服务，在系统中其他模块进行服务名访问时依然可以正常运行的。</p><h2 id="ribbon"><a href="#ribbon" class="headerlink" title="ribbon"></a><strong>ribbon</strong></h2><p>负载均衡：在微服务之前，客户端与服务端之间是存在专门的负载均衡的中间硬件的<br>微服务出现后，把负载均衡的功能以库的方式集成到客户端的进程中称为软负载均衡</p><h2 id="Netflix-hystrix"><a href="#Netflix-hystrix" class="headerlink" title="Netflix hystrix"></a><strong>Netflix hystrix</strong></h2><p>想象这样一个情况：一个电子商务网站因为在黑色周五发生过载，因为过多访问负载，在线支付延迟半天都没有响应，用户的支付因为太多并发请求导致响应时间过长，在等待很长时间以后最终失败。这样的错误导致退出购物车的用户重新刷新或者再次尝试支付，更加增加了服务器的负载，如同滚雪球一样爆炸，导致更多长时间等待线程和网络拥塞。<br>hystrix用来设计隔离访问远程系统端点或微服务等，防止级联爆炸式的失败<br>如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，也就是不让它们再次访问远程服务器了  </p><h2 id="spring-cloud-config来统一管理配置文件"><a href="#spring-cloud-config来统一管理配置文件" class="headerlink" title="spring cloud config来统一管理配置文件"></a><strong>spring cloud config来统一管理配置文件</strong></h2><p>和Eureka有点你相似，即我们先把配置文件推送到git等服务中，当我们需要配置文件 ConfigClient系统可以通过ConfigServer去获取配置文件</p><h3 id="分布式链路跟踪-Sleuth-与-Zipkin"><a href="#分布式链路跟踪-Sleuth-与-Zipkin" class="headerlink" title="分布式链路跟踪 Sleuth 与 Zipkin"></a><strong>分布式链路跟踪 Sleuth 与 Zipkin</strong></h3><p>随着业务发展，系统拆分导致系统调用链路愈发复杂一个前端请求可能最终需要调用很多次后端服务才能完成，当整个请求变慢或不可用时，我们是无法得知该请求是由某个或某些后端服务引起的，这时就需要解决如何快读定位服务故障点，以对症下药。于是就有了分布式系统调用跟踪的诞生。<br><strong>一般的，一个分布式服务跟踪系统主要由三部分构成</strong><br>数据收集<br>数据存储<br>数据展示<br>每个 trace 中会调用若干个服务，为了记录调用了哪些服务，以及每次调用的消耗时间等信息，在每次调用服务时，埋入一个调用记录，称为一个 span。这样，若干个有序的 span 就组成了一个 trace。<br>附带上 span 中的请求的服务的名称，响应时间，以及请求成功与否等信息，就可以在发生问题的时候，找到异常的服务；根据历史数据，还可以从系统整体层面分析出哪里性能差，定位性能优化的目标。<br>可以用于<br><strong>耗时分析:</strong> 通过 Sleuth 可以很方便的了解到每个采样请求的耗时，从而分析出哪些服务调用比较耗时;<br><strong>可视化错误:</strong> 对于程序未捕捉的异常，可以通过集成 Zipkin 服务界面上看到;<br><strong>链路优化:</strong> 对于调用比较频繁的服务，可以针对这些服务实施一些优化措施。  </p><h3 id="BUS消息总线技术"><a href="#BUS消息总线技术" class="headerlink" title="BUS消息总线技术"></a><strong>BUS消息总线技术</strong></h3><p><strong>路由(routing)</strong>是指分组从源到目的地时，决定端到端路径的网络范围的进程<br>消息代理中间件可以将消息路由到一个或多个目的地，实现对配置信息的实时更新</p><h3 id="RabbitMQ作为消息的总代理"><a href="#RabbitMQ作为消息的总代理" class="headerlink" title="RabbitMQ作为消息的总代理"></a><strong>RabbitMQ作为消息的总代理</strong></h3><p>config-client修改pom.xml增加spring-cloud-starter-bus-amqp模块  </p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>在配置文件中增加关于RabbitMQ的连接和用户信息  </p><pre><code>spring.rabbitmq.host=localhostspring.rabbitmq.port=5672spring.rabbitmq.username=springcloudspring.rabbitmq.password=123456</code></pre><p>启动config-server,再启动两个config-clien(分别在不同的端口上)<br>可以在config-client-eureka中的控制台中看到如下内容，在启动时候，客户端程序多了一个/bus/refresh请求。  </p><pre><code>o.s.b.a.e.mvc.EndpointHandlerMapping     : Mapped &quot;{[/bus/refresh],methods=[POST]}&quot; onto public void org.springframework.cloud.bus.endpoint.RefreshBusEndpoint.refresh(java.lang.String)</code></pre><p>•先访问两个config-client的/from请求，会返回当前config-repo/didispace-dev.properties中的from属性。<br>•接着，我们修改config-repo/didispace-dev.properties中的from属性值，并发送POST请求到其中的一个/bus/refresh。<br>•最后，我们再分别访问启动的两个config-client的/from请求，此时这两个请求都会返回最新的config-repo/didispace-dev.properties中的from属性。<br>上面已经能够通过Spring Cloud Bus来实时更新总线上的属性配置了。  </p><h3 id="消息驱动的微服务"><a href="#消息驱动的微服务" class="headerlink" title="消息驱动的微服务"></a><strong>消息驱动的微服务</strong></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2018/10/28/2018-10-28-Docker/"/>
      <url>/2018/10/28/2018-10-28-Docker/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker的三个概念"><a href="#Docker的三个概念" class="headerlink" title="Docker的三个概念"></a><strong>Docker的三个概念</strong></h2><h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a><strong>Image</strong></h3><p>Docker 镜像和java的类类似，不可改动，只有安装后作为容器（对应类似java的实例）才能改动  </p><h3 id="container"><a href="#container" class="headerlink" title="container"></a><strong>container</strong></h3><p>容器是Image的一个实例，有点像面向对象里new 一个实例。容器类似于一个轻量级的沙盒，Docker利用容器来运行和隔离应用。容器从Image启动时，Docker会在镜像的最上层创建一个可写层，镜像本身保持不变。    </p><h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a><strong>Repository</strong></h3><p> Docker 仓库是存放镜像的地方。（不要把Docker的仓库和注册服务器Registry混淆注册服务器是存放仓库的地方，每个仓库存放某一类不同标签Tag的镜像。） </p><h2 id="优点：Docker利用容器将资源进行有效隔离"><a href="#优点：Docker利用容器将资源进行有效隔离" class="headerlink" title="优点：Docker利用容器将资源进行有效隔离"></a><strong>优点：Docker利用容器将资源进行有效隔离</strong></h2><p><strong>缺点：安全运营与管理，以及具有保密性、完整性和可用性的通用控件的支持</strong></p><h2 id="docker简介"><a href="#docker简介" class="headerlink" title="docker简介"></a><strong>docker简介</strong></h2><p>虚拟机的虚拟化技术依赖物理CPU和内存，是硬件级别的；<br>docker构建在操作系统上，利用操作系统的containerization技术，所以docker甚至可以在虚拟机上运行。  </p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h3><p>运行环境的不统一与需要针对不同系统进行多次配置，影响了开发  </p><h3 id="docker设想"><a href="#docker设想" class="headerlink" title="docker设想"></a><strong>docker设想</strong></h3><p>用户可以通过标准化手段自由组装运行环境，可以由用户自定义，也可以由专业人员制造。这样，交付一个软件，就是一系列标准化组件的集合的交付。    </p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a><strong>解决方法：</strong></h3><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，进行测试运行，然后发布到任何流行的Linux机器上，从而统一了环境，不用针对不同系统的环境进行多次测试，而且启动一个容器是秒级别的，不用手动配置和安装依赖。  </p><h3 id="额外好处："><a href="#额外好处：" class="headerlink" title="额外好处："></a><strong>额外好处：</strong></h3><p>Docker应用间隔离，不易产生依赖冲突，在同一台机器上运行多个配置不同的容器。在更细的粒度上进行资源的管理，比虚拟化技术性能更高，更加节约资源。  </p><h2 id="用户应用程序迁往Docker容器的五个基本步骤"><a href="#用户应用程序迁往Docker容器的五个基本步骤" class="headerlink" title="用户应用程序迁往Docker容器的五个基本步骤"></a><strong>用户应用程序迁往Docker容器的五个基本步骤</strong></h2><p>通过设计和部署把这些服务拆分成为它们自己的容器。<br>（如果一个应用程序能够被拆分成为越多的分布式组件：<br>好处：应用程序扩展的选择越多。<br>坏处：分布式组件越多也意味着管理的复杂性越高。  </p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a><strong>第一步</strong></h3><p>搜索Docker注册库找到一个<strong>基本的Docker映像</strong>作为应用程序的基础来使用   </p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a><strong>第二步</strong></h3><p>更新较老的应用程序以支持联合身份管理方法，<strong>为每一个应用程序组件和数据提供一个唯一的标识符</strong>，在一个细粒度的级别上进行安全性管理。然后<strong>增加日志记录</strong>的方法。  </p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a><strong>第三步</strong></h3><p>使用一个Dockerfile来定义映像开发的必要步骤。一旦创建了映像，就将其<strong>添加至Docer Hub</strong>  </p><h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a><strong>第四步</strong></h3><p><strong>对在容器中应用程序进行配置</strong>，让应用程序知道在哪里连接外部资源或者应用程序集群中的其他容器。  </p><h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a><strong>第五步</strong></h3><p>对基于容器的应用程序的测试和对其他分布式应用程序的<strong>测试</strong>一样，首先对每个容器进行组件测试，然后对容器集群作为一个整体进行测试。 确定应用程序应如何能够在负载增加的前提下进行扩展。如果用户正在使用一个集群管理器（例如Swarm），则可测试其性能。<br>最后，把容器<strong>部署到实际生产环境</strong>中。为了积极主动地关注基于容器的应用程序的运行状况，可考虑实施必要的监控和管理机制。确保打开日志记录功能     </p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a><strong>安装Docker</strong></h2><p><a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a><br>官网上有各种平台的详细安装过程。  </p><pre><code>Docker的安装1.安装条件:   64位CPU架构.    内核版本为3.10及以上的Linux系统.    开启cgroup和namespace功能2.开始安装: 用sudo权限或者切换root用户,   通过yum安装 :$ sudo yum install docker-engine    通过脚本安装:$ curl -fsSL https://get.docker.com/ | sh3.以daemon方式开启docker服务:$ sudo service docker start4.验证安装是否成功: $ sudo docker run hello-world5.建议: 由于docker daemon 必须用root/sudo权限运行,为避免每次使用sudo,可创建一个具有root权限的docker组，并将用户添加到该组。6.将docker服务加入系统启动项:$ sudo chkconfig docker on</code></pre><h2 id="Docker基本用法"><a href="#Docker基本用法" class="headerlink" title="Docker基本用法"></a><strong>Docker基本用法</strong></h2><p>Docker的默认服务器是hub.docker.com 他目前是最大的镜像网站，由于国情原因下载上边的镜像，实在是慢的让人受不了，可以搜一下国内的镜像网站我是用的这个（不是给这个网站做广告，确实挺下载快多了）<a href="https://hub.tenxcloud.com/" target="_blank" rel="noopener">https://hub.tenxcloud.com/</a>  </p><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a><strong>拉取镜像</strong></h3><p>$ docker pull centos # 获取 centos 官方镜像  </p><h3 id="指定国内的镜像地址"><a href="#指定国内的镜像地址" class="headerlink" title="指定国内的镜像地址"></a><strong>指定国内的镜像地址</strong></h3><p>$ docker pull index.tenxcloud.com/tenxcloud/centos:centos7  指定国内的镜像下载地址<br>后边的：centos7是tag，表明我想下载的版本是cent0s7  </p><h3 id="查看现有镜像"><a href="#查看现有镜像" class="headerlink" title="查看现有镜像"></a><strong>查看现有镜像</strong></h3><p>docker images<br><img src="https://viabcde.github.io/images/2018-10-10/2018101020.png" alt="enter descriptionhere"> </p><h3 id="运行container"><a href="#运行container" class="headerlink" title="运行container"></a><strong>运行container</strong></h3><p>我们来运行下载好的centos7<br>docker run -i -t 6e75 /bin/bash<br>docker run       - 运行一个容器<br>-t                        - 分配一个（伪）tty<br>-i                        - 交互模式<br>6e75                - Image Id 我只输入了前几位，  </p><pre><code>                        - 只要能标识出唯一就行  </code></pre><p>/bin/bash         - 运行命令 bash shell<br><img src="https://viabcde.github.io/images/2018-10-10/2018101021.png" alt="enter descriptionhere"><br>运行完命令后我们就已经进入了centos7容器，可以执行linux命令试一下。<br>如果要退出输入exit即可。<br>退出后容器也相应停止，如果想要在后台继续运行可以加可选参数 -d<br>docker run -i -t -d 6e75 /bin/bash  </p><h3 id="查看哪些容器在运行"><a href="#查看哪些容器在运行" class="headerlink" title="查看哪些容器在运行"></a><strong>查看哪些容器在运行</strong></h3><p>docker ps # 会列出在运行的<br><img src="https://viabcde.github.io/images/2018-10-10/2018101022.png" alt="enter descriptionhere"> </p><h3 id="在已存在的容器上运行命令"><a href="#在已存在的容器上运行命令" class="headerlink" title="在已存在的容器上运行命令"></a><strong>在已存在的容器上运行命令</strong></h3><p>如上边截图我们的centos7容器在运行，想在这个容器里运行命令可以用exec命令<br>docker exec -t -i 875c /bin/bash<br><img src="https://viabcde.github.io/images/2018-10-10/2018101023.png" alt="enter descriptionhere"> </p><h2 id="Docker-命令帮助"><a href="#Docker-命令帮助" class="headerlink" title="Docker 命令帮助"></a><strong>Docker 命令帮助</strong></h2><p>$ sudo docker   # docker 命令帮助<br>Commands:</p><pre><code>    attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像    build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像    commit    Create a new image from a container&#39;s changes # 提交当前容器为新的镜像    cp        Copy files/folders from the containers filesystem to the host path              # 从容器中拷贝指定文件或者目录到宿主机中    create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器    diff      Inspect changes on a container&#39;s filesystem   # 查看 docker 容器变化    events    Get real time events from the server          # 从 docker 服务获取容器实时事件    exec      Run a command in an existing container        # 在已存在的容器上运行命令    export    Stream the contents of a container as a tar archive                # 导出容器的内容流作为一个 tar 归档文件[对应 import ]    history   Show the history of an image                  # 展示一个镜像形成历史    images    List images                                   # 列出系统当前镜像    import    Create a new filesystem image from the contents of a tarball               # 从tar包中的内容创建一个新的文件系统映像[对应 export]    info      Display system-wide information               # 显示系统相关信息    inspect   Return low-level information on a container   # 查看容器详细信息    kill      Kill a running container                      # kill 指定 docker 容器    load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]    login     Register or Login to the docker registry server                # 注册或者登陆一个 docker 源服务器    logout    Log out from a Docker registry server         # 从当前 Docker registry 退出    logs      Fetch the logs of a container                 # 输出当前容器日志信息    port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT              # 查看映射端口对应的容器内部源端口    pause     Pause all processes within a container        # 暂停容器    ps        List containers                               # 列出容器列表    pull      Pull an image or a repository from the docker registry server              # 从docker镜像源服务器拉取指定镜像或者库镜像    push      Push an image or a repository to the docker registry server              # 推送指定镜像或者库镜像至docker源服务器    restart   Restart a running container                   # 重启运行的容器    rm        Remove one or more containers                 # 移除一个或者多个容器    rmi       Remove one or more images                               # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]    run       Run a command in a new container              # 创建一个新的容器并运行一个命令    save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]    search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像    start     Start a stopped containers                    # 启动容器    stop      Stop a running containers                     # 停止容器    tag       Tag an image into a repository                # 给源中镜像打标签    top       Lookup the running processes of a container   # 查看容器中运行的进程信息    unpause   Unpause a paused container                    # 取消暂停容器    version   Show the docker version information           # 查看 docker 版本号    wait      Block until a container stops, then print its exit code                # 截取容器停止时的退出状态值Docker之常用命令查看docker信息#查看docker版本$ docker version#查看docker系统信息$ docker info对镜像的操作# 检索image  $ docker search image_name  # 下载image  $ docker pull image_name  # 列出镜像列表; -a, --all=false Show all images; --no-trunc=false Don&#39;t truncate output; -q, --quiet=false Only show numeric IDs$ docker images  # 删除一个或者多个镜像; -f, --force=false Force; --no-prune=false Do not delete untagged parents  $ docker rmi image_name  # 显示一个镜像的历史; --no-trunc=false Don&#39;t truncate output; -q, --quiet=false Only show numeric IDs$ docker history image_name  启动容器# 在容器中运行&quot;echo&quot;命令，输出&quot;hello word&quot;  $ docker run image_name echo &quot;hello word&quot;  # 交互式进入容器中  $ docker run -i -t image_name /bin/bash  # 在容器中安装新的程序  $ docker run image_name apt-get install -y app_name# 在运维中普遍使用的docker命令 $ docker run --name titan-showcase -p 8480:8080 -v /u01/titan-showcase/download:/home/titan-showcase/download  -e TZ=Asia/Shanghai  --restart=always -d titan-showcase:0.1.47注意： 在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失。查看容器# 列出当前所有正在运行的container  $ docker ps # 列出所有的container  $ docker ps -a  # 列出最近一次启动的container $ docker ps -l  对容器的操作# 删除所有容器  $ docker rm `docker ps -a -q`  # 删除单个容器; -f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container$docker rm Name/ID  # 停止、启动、杀死一个容器$ docker stop Name/ID  $ docker start Name/ID  $ docker kill Name/ID  # 从一个容器中取日志; -f, --follow=false Follow log output; -t, --timestamps=false Show timestamps$docker logs Name/ID# 使用比较广泛的读取docker容器日志的后一千行信息的命令$ docker logs -f --tail=1000 Name/ID# 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的$ docker diff Name/ID  # 显示一个运行的容器里面的进程信息  $ docker top Name/ID  # 从容器里面拷贝文件/目录到本地一个路径$ docker cp Name:/container_path to_path$ docker cp ID:/container_path to_path  # 重启一个正在运行的容器; -t, --time=10 Number of seconds to try to stop for before killing the container, Default=10  $ docker restart Name/ID  # 附加到一个运行的容器上面; --no-stdin=false Do not attach stdin; --sig-proxy=true Proxify all received signal to the process  $ docker attach ID  保存和加载镜像当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。# 保存镜像到一个tar包; -o, --output=&quot;&quot; Write to an file $ docker save image_name:image_version -o file_path# 加载一个tar包格式的镜像; -i, --input=&quot;&quot; Read from a tar archive file  $ docker load -i file_path  # 机器a  $ docker save image_name:image_version &gt; /home/save.tar或$ docker save -o /home/save.tar image_name:image_version# 使用scp将save.tar拷到机器b上，然后：$ docker load -i &lt; /home/save.tar登录registry server# 登陆registry server; -e, --email=&quot;&quot; Email; -p, --password=&quot;&quot; Password; -u, --username=&quot;&quot; Username  $ docker login发布镜像# 发布docker镜像  $ docker push new_image_name根据dockerfile构建镜像#build        --no-cache=false Do not use cache when building the image        -q, --quiet=false Suppress the verbose output generated by the containers        --rm=true Remove intermediate containers after a successful build        -t, --tag=&quot;&quot; Repository name (and optionally a tag) to be applied to the resulting image in case of success $ docker build -t image_name:image_version Dockerfile_path 运维中一个比较典型的dockerfile文件示例FROM changan/java:1.8MAINTAINER xxx# set timezone to PRCENV TZ=&quot;Asia/Shanghai&quot; LANG=en_US.UTF-8  PRO_ENV=&quot;prod&quot;ADD build/libs/xxx-0.0.1.jar /home/App.jarENTRYPOINT java -jar /home/App.jar</code></pre><h2 id="Docker的使用"><a href="#Docker的使用" class="headerlink" title="Docker的使用"></a>Docker的使用</h2><pre><code>1.基本使用命令:   查看docker环境: $ docker info2.查看docker命令:   所有命令:$ docker    某条命令:$ docker xxx --help3.启动一次性运行的容器(并在容器中执行命令):$ docker run ubuntu:16.04 /bin/echo &#39;Hello world&#39;4.启动交互模式容器:$ docker run -t-i ubuntu:16.04 (-t:开启一个终端, -i:以交互模式运行)5.启动后台模式容器:$ docker run -d ubuntu:14.04 /bin/sh (-d:以后台Daemon方式运行，执行成功后会返回一个该容器的ID)6.指定容器启动后的名字:$ docker run -i -t --name mytest ubuntu:14.04 /bin/bash (--name:指定启动后的容器名字,如果不指定则docker会帮我们取一个名字)7.以映射端口方式启动一个Web容器:$ docker run -d -P (-P:端口映射，外部端口到容器端口的映射规则由docker负责) $ docker run -d -p 5000:5000 (-p:自己指定端口映射规则，格式为:-p ip:host port:port，将当前物理机的ip的端口映射到容器的端口) # 查看到其端口列的端口映射规则$ docker ps -l# 容器ID或容器名称 可快捷查看容器的端口$ docker port8.查看容器的具体信息:$ docker inspect 容器ID或容器名称9.对运行着的后台容器进入执行命令:$ docker exec -it 容器ID /bin/bash10.查看容器的日志: $ docker logs -f 容器ID或容器名称 (-f:以滚动的形式查看日志)11.重启容器:$ docker restart 容器ID12.暂停容器: $ docker pause 容器ID / $ docker unpause 容器ID13.停止容器:$ docker stop 容器ID或容器名称14.杀死容器:$ docker kill 容器ID或容器名称15.删除容器:$ docker rm 容器ID或容器名称 (正在运行的容器不能删除)16.把一个宿主机上的目录挂载到镜像里:$ docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash (-v:冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径) # 默认挂载的路径权限为读写。# 如果指定为只读可以用ro: $ docker run -it -v /home/dock/Downloads:/usr/Downloads:ro ubuntu64 /bin/bash17.一个容器定义的一个数据挂载信息。其他的容器启动可以直接挂载数据卷容器中定义的挂载信息:$ docker run -v /home/dock/Downloads:/usr/Downloads --name dataVol ubuntu64 /bin/bash $ docker run -it --volumes-from dataVol ubuntu64 /bin/bash (--volumes-from:用来指定要从哪个数据卷来挂载数据)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2018/10/27/2018-10-27-SpringBoot/"/>
      <url>/2018/10/27/2018-10-27-SpringBoot/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/viabcde/mycoding.github.io/tree/master/SpringBootDemo" target="_blank" rel="noopener">示例demo源码地址</a></p><h3 id="Spring-Boot简介—习惯大于约定原则"><a href="#Spring-Boot简介—习惯大于约定原则" class="headerlink" title="Spring Boot简介—习惯大于约定原则"></a><strong>Spring Boot简介—习惯大于约定原则</strong></h3><h2 id="springboot就是一个能够快速搭起spring项目的神器"><a href="#springboot就是一个能够快速搭起spring项目的神器" class="headerlink" title="springboot就是一个能够快速搭起spring项目的神器"></a>springboot就是一个能够快速搭起spring项目的<strong>神器</strong></h2><p><strong>原始Spring问题：</strong>大量的XML配置、复杂的依赖管理；需要手动配置tomcat<br>Spring Boot为了改善传统Spring应用繁杂的配置内容，采用了包扫描和自动化配置的机制来加载原本集中于xml文件中的各项内容<br><strong>Spring Boot</strong>提前配置好xml和依赖包，不需要手动配置服务器。<br><strong>如何做到的呢：</strong>把应用打包成可直接启动的jar/war，不需要另外配置一个Web Server。<br><strong>好处：</strong>既可以快速的创建一个可以立即运行的原型应用，又可以不断的修改和调整以适应应用开发在不同阶段的需要  </p><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a><strong>PS</strong></h2><pre><code>SpringBoot借助Groovy的MetaObject协议、可插拔的AST转换过程以及内置的依赖解决方案引擎实现  Spring Boot默认使用tomcat作为服务器，使用logback提供日志记录  CLI（命令行界面）可在Spring仓库中手动下载和安装，用来运行和测试Boot应用  使用Groovy环境管理器（Groovy enVironment Manager，GVM）处理Boot版本的安装和管理。</code></pre><h2 id="安装Boot"><a href="#安装Boot" class="headerlink" title="安装Boot"></a><strong>安装Boot</strong></h2><p>Boot及其CLI可以通过GVM的命令行gvm install springboot进行安装。  </p><h2 id="spring-boot的启动原理"><a href="#spring-boot的启动原理" class="headerlink" title="spring boot的启动原理"></a><strong>spring boot的启动原理</strong></h2><p>maven打包之后，会生成两个jar文件：<br><strong>demo-0.0.1-SNAPSHOT.jar spring boot</strong><br>由maven插件生成，里面包含了应用的依赖，以及spring boot相关的类<br><strong>demo-0.0.1-SNAPSHOT.jar.original</strong><br>默认的maven-jar-plugin生成的包<br><strong>spring boot打好的包的目录结构</strong>  </p><pre><code>├── META-INF│   ├── MANIFEST.MF├── application.properties├── com│   └── example│       └── SpringBootDemoApplication.class├── lib│   ├── aopalliance-1.0.jar│   ├── spring-beans-4.2.3.RELEASE.jar│   ├── ...└── org    └── springframework        └── boot            └── loader                ├── ExecutableArchiveLauncher.class                ├── JarLauncher.class                ├── JavaAgentDetector.class                ├── LaunchedURLClassLoader.class                ├── Launcher.class                ├── MainMethodRunner.class                ├── ...</code></pre><h3 id="MANIFEST-MF"><a href="#MANIFEST-MF" class="headerlink" title="MANIFEST.MF"></a><strong>MANIFEST.MF</strong></h3><pre><code>Manifest-Version: 1.0Start-Class: com.example.SpringBootDemoApplicationImplementation-Vendor-Id: com.exampleSpring-Boot-Version: 1.3.0.RELEASECreated-By: Apache Maven 3.3.3Build-Jdk: 1.8.0_60Implementation-Vendor: Pivotal Software, Inc.Main-Class: org.springframework.boot.loader.JarLauncher</code></pre><h3 id="Start-Class是com-example-SpringBootDemoApplication："><a href="#Start-Class是com-example-SpringBootDemoApplication：" class="headerlink" title="Start-Class是com.example.SpringBootDemoApplication："></a><strong>Start-Class是com.example.SpringBootDemoApplication：</strong></h3><p>这个是我们应用的Main函数：</p><pre><code>@SpringBootApplicationpublic class SpringBootDemoApplication {    public static void main(String[] args) {        SpringApplication.run(SpringBootDemoApplication.class, args);    }}</code></pre><h3 id="com-example-目录"><a href="#com-example-目录" class="headerlink" title="com/example 目录"></a><strong>com/example 目录</strong></h3><p>应用的.class文件</p><h3 id="lib目录"><a href="#lib目录" class="headerlink" title="lib目录"></a><strong>lib目录</strong></h3><p>应用的Maven依赖的jar包文件，比如spring-beans，spring-mvc等jar。  </p><h3 id="org-springframework-boot-loader-目录"><a href="#org-springframework-boot-loader-目录" class="headerlink" title="org/springframework/boot/loader 目录"></a><strong>org/springframework/boot/loader 目录</strong></h3><p>Spring boot loader的.class文件  </p><h3 id="spring-boot应用打包之后，生成的fat-jar"><a href="#spring-boot应用打包之后，生成的fat-jar" class="headerlink" title="spring boot应用打包之后，生成的fat_jar"></a><strong>spring boot应用打包之后，生成的fat_jar</strong></h3><p>包含应用依赖的jar包，还有Spring boot loader相关的类<br>Fat jar的启动Main函数是JarLauncher，它负责创建LaunchedURLClassLoader加载/lib下面的jar，并以一个新线程启动应用的Main函数。<br><strong>LaunchedURLClassLoader和普通的URLClassLoader的不同之处是</strong><br>它提供了从Archive里加载.class的能力。结合Archive提供的getEntries函数，就可以获取到Archive里的Resource。</p><h2 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a><strong>加载流程</strong></h2><p>1.以demo-0.0.1-SNAPSHOT.jar创建一个Archive<br>2.JarLauncher创建好Archive之后，通过getNestedArchives函数来获取到demo-0.0.1-SNAPSHOT.jar/lib下面的所有jar文件，并创建为List，数组里是lib目录下面的jar的URL，用这个来构造一个自定义的ClassLoader：LaunchedURLClassLoader。<br>3.从MANIFEST.MF里读取到Start-Class，即com.example.SpringBootDemoApplication，然后创建一个新的线程来启动应用的Main函数。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot集成springMVC视图技术</title>
      <link href="/2018/10/26/2018-10-27-SpringBoot%E9%9B%86%E6%88%90%E8%A7%86%E5%9B%BE%E6%8A%80%E6%9C%AF/"/>
      <url>/2018/10/26/2018-10-27-SpringBoot%E9%9B%86%E6%88%90%E8%A7%86%E5%9B%BE%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="能集成的视图技术"><a href="#能集成的视图技术" class="headerlink" title="能集成的视图技术"></a><strong>能集成的视图技术</strong></h3><p>spring boot 在springmvc的视图解析器方面默认集成ContentNegotiatingViewResolver和BeanNameViewResolver<br>在视图引擎上就已经集成自动配置的模版引擎，如下： </p><ol><li>FreeMarker </li><li>Groovy </li><li>Thymeleaf </li><li>Velocity (deprecated in 1.4) </li><li>Mustache</li></ol><p>JSP技术spring boot 官方是不推荐的，原因有三： </p><ol><li>在tomcat上，jsp不能在嵌套的tomcat容器解析即不能在打包成可执行的jar的情况下解析 </li><li>Jetty 嵌套的容器不支持jsp </li><li>Undertow</li></ol><p>而其他的模版引擎spring boot 都支持，并默认会到classpath的templates里面查找模版引擎</p><h3 id="集成freemarker模版引擎"><a href="#集成freemarker模版引擎" class="headerlink" title="集成freemarker模版引擎"></a><strong>集成freemarker模版引擎</strong></h3><p>1.现在pom.xml启动freemarker模版引擎视图</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>2.定义一个模版后缀是ftp,注意是在classpath的templates目录下<br><img src="https://viabcde.github.io/images/2018-10-10/2018101016.png" alt="enter descriptionhere"><br>3.在controller上返回视图路径</p><pre><code>@RestController@RequestMapping(&quot;/task&quot;)public class TaskController {    @RequestMapping(&quot;/mvc1&quot;)    public ModelAndView mvc1() {        return new ModelAndView(&quot;index&quot;);    }}</code></pre><p>@RestController默认就会在每个方法上加上@Responsebody,方法返回值会直接被httpmessageconverter转化，如果想直接返回视图，需要直接指定modelAndView。<br>虽然，jsp技术，spring boot 官方不推荐，但考虑到是常用的技术，这里也来集成下jsp技术<br>1.首先，需要在你项目上加上webapp标准的web项目文件夹<br><img src="https://viabcde.github.io/images/2018-10-10/2018101017.png" alt="enter descriptionhere"><br>2.在配置文件上配置，jsp的前缀和后缀<br>spring.mvc.view.prefix=/WEB-INF/<br>spring.mvc.view.suffix=.jsp<br>3.然后直接在controller中返回视图</p><pre><code>@RestController@RequestMapping(&quot;/task&quot;)public class TaskController {    @RequestMapping(&quot;/mvc1&quot;)    public ModelAndView mvc1() {        return new ModelAndView(&quot;index&quot;);    }</code></pre><p>这里要注意，只能是打成war包在非嵌套的tomcat容器才能看到效果，直接在嵌套的tomcat容器是看不到效果的，因为不支持，例如在IDE直接右键run main函数或者打成可执行的jar包都不行。<br>例外，如果出现freemarker模版引擎和jsp技术同时存在的话，springmvc会根据解析器的优先级来返回具体的视图，默认，FreeMarkerViewResolver的优先级大于InternalResourceViewResolver的优先级，所以同时存在的话，会返回freemarker视图</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式架构学习</title>
      <link href="/2018/10/26/2018-10-26-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/10/26/2018-10-26-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%9A%84%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="冯诺依曼模型（第一台计算机）"><a href="#冯诺依曼模型（第一台计算机）" class="headerlink" title="冯诺依曼模型（第一台计算机）"></a><strong>冯诺依曼模型（第一台计算机）</strong></h3><p>组成部分：输入设备–存储器（运算器+控制器）–输出设备</p><h3 id="IBM大型机时代"><a href="#IBM大型机时代" class="headerlink" title="IBM大型机时代"></a><strong>IBM大型机时代</strong></h3><p>集中式计算机系统，小企业用不起（贵）<br>培养成本高（系统复杂）<br>出现故障，整个系统都坏了  </p><h3 id="集群和分布式"><a href="#集群和分布式" class="headerlink" title="集群和分布式"></a><strong>集群和分布式</strong></h3><p>分布式：一个业务拆分为多个子业务部署在不同的服务器上，保证高性能。比如电商平台拆分为：用户，商品，订单。<br>集群：同一个业务部署在多个服务器上，保证高可用。</p><h3 id="什么是分布式？"><a href="#什么是分布式？" class="headerlink" title="什么是分布式？"></a><strong>什么是分布式？</strong></h3><p>由多个小型计算机服务器通过网络连接起来，组成一个大型的计算机服务器。<br>需要解决两件事情：任务分解，节点通信。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a><strong>节点</strong></h3><p>一个节点就是一个进程，依据分布式协议完成一定的逻辑操作的进程</p><h3 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a><strong>副本机制</strong></h3><p>数据副本指在不同的节点上持久化同一份数据,当出现某一个节点的数据丢失时,可以从副本读取数据。数据副本是分布式系统中结果数据丢失的唯一手段。</p><p>服务副本表示的是多个节点提供相同的服务,通过主从关系来实现服务的高可用方案</p><h3 id="大型网站的特点"><a href="#大型网站的特点" class="headerlink" title="大型网站的特点"></a><strong>大型网站的特点</strong></h3><p>1.访问量（tps、qps）<br>2.数据量（存储数据量）</p><h3 id="主流电商的核心业务"><a href="#主流电商的核心业务" class="headerlink" title="主流电商的核心业务"></a><strong>主流电商的核心业务</strong></h3><p>用户，商品，订单</p><h3 id="电商对应的技术"><a href="#电商对应的技术" class="headerlink" title="电商对应的技术"></a><strong>电商对应的技术</strong></h3><p>容器：tomcat，jsp/servlet<br>数据库存储：MySQL</p><h3 id="第一版-单台服务器应用"><a href="#第一版-单台服务器应用" class="headerlink" title="第一版 单台服务器应用"></a><strong>第一版 单台服务器应用</strong></h3><p>最初的架构，应用程序、数据库、文件都部署在一台服务器上<br>出现以下问题：<br>由于流量越来越大出现服务器性能问题</p><h3 id="第二版-应用服务器和数据库服务器分离"><a href="#第二版-应用服务器和数据库服务器分离" class="headerlink" title="第二版 应用服务器和数据库服务器分离"></a><strong>第二版 应用服务器和数据库服务器分离</strong></h3><p>随着业务的扩展，一台服务器已经不能满足性能需求，故将应用程序、数据库、文件各自部署在独立的服务器上，并且根据服务器的用途配置不同的硬件，达到最佳的性能效果，有效的缓解了应用服务器负载的压力。<br>出现以下问题：<br>随着请求流量得进一步增大出现应用服务器性能问题。</p><h3 id="第三版-应用服务器集群"><a href="#第三版-应用服务器集群" class="headerlink" title="第三版 应用服务器集群"></a><strong>第三版 应用服务器集群</strong></h3><p>流量请求得到缓解。<br>应用服务器集群后出现以下问题：<br>这么多的服务器该交由那一台服务器，或者说怎么合理分配任务利用率最高呢？<br>1.需要使用session+cookie维护用户<br>2.如何做请求转发（cdn，前端做负载均衡器）</p><h3 id="第四版-负载均衡器"><a href="#第四版-负载均衡器" class="headerlink" title="第四版 负载均衡器"></a><strong>第四版 负载均衡器</strong></h3><p>1.负载均衡器优化了访问请求在服务器组之间的分配，消除了服务器之间的负载不平衡，从而提高了系统的反应速度与总体性能；<br>2.负载均衡器可以对服务器的运行状况进行监控，及时发现运行异常的服务器，并将访问请求转移到其它可以正常工作的服务器上，从而提高服务器组的可靠性采用了负均衡器器以后，可以根据业务量的发展情况灵活增加服务器，系统的扩展能力得到提高，同时简化了管理。</p><p>负载均衡器之后出现以下问题：<br>解决了应用服务器集群问题，但随着流量的新增，数据库服务器也出现了性能压力，数据库遇到瓶颈。</p><h3 id="第五版-数据库服务器集群"><a href="#第五版-数据库服务器集群" class="headerlink" title="第五版 数据库服务器集群"></a><strong>第五版 数据库服务器集群</strong></h3><p>数据库服务器集群后出现以下问题：<br>这么多的数据库服务器，该如何制定存取策略，哪些服务器是负责存的，而哪些又是负责取得呢<br>1.数据库读写分离<br>2.数据库数据同步<br>3.数据库路由<br>而且如果是电商平台，用户量是没有上限的，数据该实时同步还是定时隔时同步呢？</p><h3 id="第六、七版"><a href="#第六、七版" class="headerlink" title="第六、七版"></a><strong>第六、七版</strong></h3><p>解决方法：搜索引擎集群和在读取之上增加缓存服务器</p><h3 id="第八版-数据库水平-垂直拆分"><a href="#第八版-数据库水平-垂直拆分" class="headerlink" title="第八版 数据库水平/垂直拆分"></a><strong>第八版 数据库水平/垂直拆分</strong></h3><p>数据库服务器按照不同业务模块分离，单独使用服务器</p><h3 id="第九版-应用拆分"><a href="#第九版-应用拆分" class="headerlink" title="第九版 应用拆分"></a><strong>第九版 应用拆分</strong></h3><p>不同的应用负责相应的业务<br>问题：应用之间如何通信</p><h3 id="第十版-SOA服务（分布式架构）"><a href="#第十版-SOA服务（分布式架构）" class="headerlink" title="第十版 SOA服务（分布式架构）"></a><strong>第十版 SOA服务（分布式架构）</strong></h3><p>最后第十版就不是web应用服务了，应用服务拆分为服务节点，属于微服务了。<br>———-完美的分割线———-</p><h3 id="CDN加速静态文件的访问"><a href="#CDN加速静态文件的访问" class="headerlink" title="CDN加速静态文件的访问"></a><strong>CDN加速静态文件的访问</strong></h3><p>CDN即内容分发网络，☞针对一些更新频率不是很高的静态文件进行缓存处理，并尽可能地将用户的请求重新导向离用户最近的的服务节点上，减少用户访问资源的时间</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop</title>
      <link href="/2018/10/08/2018-10-27-hadoop/"/>
      <url>/2018/10/08/2018-10-27-hadoop/</url>
      
        <content type="html"><![CDATA[<p><img src="https://viabcde.github.io/images/2018-10-08/2018100801.png" alt="enter description here"><br>文件的每一行是一个键值对 ：<br>第一行从0开始 hello a共占7个，再加回车也占1位，所以是8位；<br>所以第二行从8开始，以此类推</p><h3 id="ETL"><a href="#ETL" class="headerlink" title="ETL"></a><strong>ETL</strong></h3><p>数据从来源端经过抽取(extract)、交互转换(transform)、加载(load)至目的端的过程</p><h3 id="hadoop生态圈"><a href="#hadoop生态圈" class="headerlink" title="hadoop生态圈"></a><strong>hadoop生态圈</strong></h3><p><img src="https://viabcde.github.io/images/2018-10-08/2018100802.png" alt="enter description here">  </p><h3 id="一次性启动hadoop所有服务"><a href="#一次性启动hadoop所有服务" class="headerlink" title="一次性启动hadoop所有服务"></a><strong>一次性启动hadoop所有服务</strong></h3><p>start-all.sh</p><h3 id="启动HDFS系统"><a href="#启动HDFS系统" class="headerlink" title="启动HDFS系统"></a><strong>启动HDFS系统</strong></h3><p>start-dfs.sh</p><h3 id="查看HDFS系统是否启动"><a href="#查看HDFS系统是否启动" class="headerlink" title="查看HDFS系统是否启动"></a><strong>查看HDFS系统是否启动</strong></h3><p>jps</p><h3 id="查看HDFS-shell命令的解释"><a href="#查看HDFS-shell命令的解释" class="headerlink" title="查看HDFS shell命令的解释"></a><strong>查看HDFS shell命令的解释</strong></h3><p>hdfs dfs -help</p><h3 id="在本地simple文件夹下新建word-txt"><a href="#在本地simple文件夹下新建word-txt" class="headerlink" title="在本地simple文件夹下新建word.txt"></a><strong>在本地simple文件夹下新建word.txt</strong></h3><p>hdfs dfs -put /simple/word.txt/</p><h3 id="查看hdfs目录下的文件"><a href="#查看hdfs目录下的文件" class="headerlink" title="查看hdfs目录下的文件"></a><strong>查看hdfs目录下的文件</strong></h3><p>hdfs dfs -cat /word.txt</p><h3 id="把hdfs根目录下的words-txt下载到本地simple文件夹下"><a href="#把hdfs根目录下的words-txt下载到本地simple文件夹下" class="headerlink" title="把hdfs根目录下的words.txt下载到本地simple文件夹下"></a><strong>把hdfs根目录下的words.txt下载到本地simple文件夹下</strong></h3><p>hdfs dfs -get /words.txt   /simple/wordss.txt</p><h3 id="把hdfs的文件移动到指定的hdfs位置"><a href="#把hdfs的文件移动到指定的hdfs位置" class="headerlink" title="把hdfs的文件移动到指定的hdfs位置"></a><strong>把hdfs的文件移动到指定的hdfs位置</strong></h3><p>hdfs dfs -mv  /word.txt   wordscp.txt</p><h3 id="查看hdfs目录下的文件-1"><a href="#查看hdfs目录下的文件-1" class="headerlink" title="查看hdfs目录下的文件"></a><strong>查看hdfs目录下的文件</strong></h3><p>hdfs dfs -ls /</p><h3 id="查看dfs管理命令注释"><a href="#查看dfs管理命令注释" class="headerlink" title="查看dfs管理命令注释"></a><strong>查看dfs管理命令注释</strong></h3><p>hadoop dfsadmin -help</p><h3 id="访问某一文件如tmp受限"><a href="#访问某一文件如tmp受限" class="headerlink" title="访问某一文件如tmp受限"></a><strong>访问某一文件如tmp受限</strong></h3><p>解决方法：Hadoopdfs chmod -R 755   /tmp</p><h2 id="Linux-环境下安装Eclipse"><a href="#Linux-环境下安装Eclipse" class="headerlink" title="Linux 环境下安装Eclipse"></a><strong>Linux 环境下安装Eclipse</strong></h2><h3 id="上传-eclipse-java-mars-2-llinux-gtk-X86-64-tar-gz到目录-soft下"><a href="#上传-eclipse-java-mars-2-llinux-gtk-X86-64-tar-gz到目录-soft下" class="headerlink" title="上传 eclipse-java-mars-2-llinux-gtk-X86_64.tar.gz到目录/soft下"></a><strong>上传 eclipse-java-mars-2-llinux-gtk-X86_64.tar.gz到目录/soft下</strong></h3><h3 id="解压到-usr"><a href="#解压到-usr" class="headerlink" title="解压到/usr"></a><strong>解压到/usr</strong></h3><p>tar -zxvf eclipse-java-mars-2-linux-gtk-X86_64.tar.gz   -C/usr</p><p>##</p><h3 id="进入hadoop目录"><a href="#进入hadoop目录" class="headerlink" title="进入hadoop目录"></a><strong>进入hadoop目录</strong></h3><p>cd $HADOOP_HOME/share/hadoop/hdfs</p><h3 id="拷贝jar到hadoop工程的lib下"><a href="#拷贝jar到hadoop工程的lib下" class="headerlink" title="拷贝jar到hadoop工程的lib下"></a><strong>拷贝jar到hadoop工程的lib下</strong></h3><p>cp hadoop-hdfs-2.4.1.jar   /root/workspace/hadoop/lib/</p><h3 id="将hadoop目录lib下的jar拷贝到java-工程的lib下"><a href="#将hadoop目录lib下的jar拷贝到java-工程的lib下" class="headerlink" title="将hadoop目录lib下的jar拷贝到java 工程的lib下"></a><strong>将hadoop目录lib下的jar拷贝到java 工程的lib下</strong></h3><p>cd $HADOOP_HOME/share/hadoop/hdfs/lib/<br>cp /root/workspace/hadoop/lib/</p><h3 id="查看导入的jar"><a href="#查看导入的jar" class="headerlink" title="查看导入的jar"></a><strong>查看导入的jar</strong></h3><p>ls /root/workspace/hadoop/lib/</p><h3 id="查看hadoop副本数量"><a href="#查看hadoop副本数量" class="headerlink" title="查看hadoop副本数量"></a><strong>查看hadoop副本数量</strong></h3><p>cd /simple/hadoop-2.4.1/etc/hadoop<br>cat hdfs-site.xml</p><h3 id="上传大文件，将目录-soft下的jdk7u79-linux-x64-tar-gz上传到hdfs目录下"><a href="#上传大文件，将目录-soft下的jdk7u79-linux-x64-tar-gz上传到hdfs目录下" class="headerlink" title="上传大文件，将目录/soft下的jdk7u79-linux-x64.tar.gz上传到hdfs目录下"></a><strong>上传大文件，将目录/soft下的jdk7u79-linux-x64.tar.gz上传到hdfs目录下</strong></h3><p>hadoop fs  -put/soft/jdk7u79-linux-x64.tar.gz  /<br>查看是否上传成功：hadoop fs -ls  /</p><h3 id="查看hadoop-dataNode信息"><a href="#查看hadoop-dataNode信息" class="headerlink" title="查看hadoop dataNode信息"></a><strong>查看hadoop dataNode信息</strong></h3><p>cd /simple/hadoop-2.4.1/hdfs/data/current/BP*/current/finalized<br>ls -lrt<br><img src="https://viabcde.github.io/images/201811/20181110.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/201811/20181111.png" alt="enter description here">  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven常用命令</title>
      <link href="/2018/09/28/2018-9-28-Maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/09/28/2018-9-28-Maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Maven常用命令："><a href="#Maven常用命令：" class="headerlink" title="Maven常用命令："></a>Maven常用命令：</h2><h3 id="1-创建Maven的普通Java项目"><a href="#1-创建Maven的普通Java项目" class="headerlink" title="1. 创建Maven的普通Java项目"></a><strong>1. 创建Maven的普通Java项目</strong></h3><p>mvn archetype:create<br>    -DgroupId=packageName<br>    -DartifactId=projectName  </p><h3 id="2-创建Maven的Web项目"><a href="#2-创建Maven的Web项目" class="headerlink" title="2. 创建Maven的Web项目"></a><strong>2. 创建Maven的Web项目</strong></h3><p>mvn archetype:create<br>    -DgroupId=packageName<br>    -DartifactId=webappName<br>    -DarchetypeArtifactId=maven-archetype-webapp  </p><h3 id="3-反向生成-maven-项目的骨架"><a href="#3-反向生成-maven-项目的骨架" class="headerlink" title="3. 反向生成 maven 项目的骨架"></a><strong>3. 反向生成 maven 项目的骨架</strong></h3><p>mvn archetype:generate<br>　　你是怎么创建你的maven项目的?是不是像这样:<br>mvn archetype:create -DarchetypeArtifactId=maven-archetype-quickstart -DgroupId=com.ryanote -Dartifact=common<br>　　如果你还再用的话,那你就out了,现代人都用mvn archetype:generate了,它将创建项目这件枯燥的事更加人性化,你再也不需要记那么多的archetypeArtifactId,你只需输入archetype:generate,剩下的就是做”选择题”了.<br>　　缩写写法：<br>mvn archetype:generate -DgroupId=otowa.user.dao -DartifactId=user-dao -Dversion=0.01-SNAPSHOT  </p><h3 id="4-编译源代码"><a href="#4-编译源代码" class="headerlink" title="4. 编译源代码"></a><strong>4. 编译源代码</strong></h3><p>mvn compile  </p><h3 id="5-编译测试代码"><a href="#5-编译测试代码" class="headerlink" title="5. 编译测试代码"></a><strong>5. 编译测试代码</strong></h3><p>mvn test-compile  </p><h3 id="6-运行测试"><a href="#6-运行测试" class="headerlink" title="6. 运行测试"></a><strong>6. 运行测试</strong></h3><p>mvn test  </p><h3 id="7-产生site"><a href="#7-产生site" class="headerlink" title="7. 产生site"></a><strong>7. 产生site</strong></h3><p>mvn site  </p><h3 id="8-打包"><a href="#8-打包" class="headerlink" title="8. 打包"></a><strong>8. 打包</strong></h3><p>mvn package  </p><h3 id="9-在本地Repository中安装jar"><a href="#9-在本地Repository中安装jar" class="headerlink" title="9. 在本地Repository中安装jar"></a><strong>9. 在本地Repository中安装jar</strong></h3><p>mvn install<br>例：installing D:\xxx\xx.jar to D:\xx\xxxx  </p><h3 id="10-清除产生的项目"><a href="#10-清除产生的项目" class="headerlink" title="10. 清除产生的项目"></a><strong>10. 清除产生的项目</strong></h3><p>mvn clean  </p><h3 id="11-生成eclipse项目"><a href="#11-生成eclipse项目" class="headerlink" title="11. 生成eclipse项目"></a><strong>11. 生成eclipse项目</strong></h3><p>mvn eclipse:eclipse  </p><h3 id="12-生成idea项目"><a href="#12-生成idea项目" class="headerlink" title="12. 生成idea项目"></a><strong>12. 生成idea项目</strong></h3><p>mvn idea:idea  </p><h3 id="13-组合使用goal命令，如只打包不测试"><a href="#13-组合使用goal命令，如只打包不测试" class="headerlink" title="13. 组合使用goal命令，如只打包不测试"></a><strong>13. 组合使用goal命令，如只打包不测试</strong></h3><p>mvn -Dtest package  </p><h3 id="14-编译测试的内容"><a href="#14-编译测试的内容" class="headerlink" title="14. 编译测试的内容"></a><strong>14. 编译测试的内容</strong></h3><p>mvn test-compile  </p><h3 id="15-只打jar包"><a href="#15-只打jar包" class="headerlink" title="15. 只打jar包"></a><strong>15. 只打jar包</strong></h3><p>mvn jar:jar  </p><h3 id="16-只测试而不编译，也不测试编译"><a href="#16-只测试而不编译，也不测试编译" class="headerlink" title="16. 只测试而不编译，也不测试编译"></a><strong>16. 只测试而不编译，也不测试编译</strong></h3><p>mvn test -skipping compile -skipping test-compile<br> ( -skipping 的灵活运用，当然也可以用于其他组合命令) </p><h3 id="17-清除eclipse的一些系统设置"><a href="#17-清除eclipse的一些系统设置" class="headerlink" title="17. 清除eclipse的一些系统设置:"></a><strong>17. 清除eclipse的一些系统设置:</strong></h3><p>mvn eclipse:clean </p><h3 id="18-查看当前项目已被解析的依赖"><a href="#18-查看当前项目已被解析的依赖" class="headerlink" title="18.查看当前项目已被解析的依赖"></a><strong>18.查看当前项目已被解析的依赖</strong></h3><p>mvn dependency:list</p><h3 id="19-上传到私服"><a href="#19-上传到私服" class="headerlink" title="19.上传到私服"></a><strong>19.上传到私服</strong></h3><p>mvn deploy</p><h3 id="20-强制检查更新，由于快照版本的更新策略-一天更新几次、隔段时间更新一次-存在，如果想强制更新就会用到此命令"><a href="#20-强制检查更新，由于快照版本的更新策略-一天更新几次、隔段时间更新一次-存在，如果想强制更新就会用到此命令" class="headerlink" title="20. 强制检查更新，由于快照版本的更新策略(一天更新几次、隔段时间更新一次)存在，如果想强制更新就会用到此命令:"></a><strong>20. 强制检查更新，由于快照版本的更新策略(一天更新几次、隔段时间更新一次)存在，如果想强制更新就会用到此命令:</strong></h3><p>mvn clean install-U</p><h3 id="21-源码打包"><a href="#21-源码打包" class="headerlink" title="21. 源码打包"></a><strong>21. 源码打包</strong></h3><p>mvn source:jar<br>或<br>mvn source:jar-no-fork  </p><h3 id="mvn-compile与mvn-install、mvn-deploy的区别"><a href="#mvn-compile与mvn-install、mvn-deploy的区别" class="headerlink" title="mvn compile与mvn install、mvn deploy的区别"></a><strong>mvn compile与mvn install、mvn deploy的区别</strong></h3><p>1.mvn compile，编译类文件<br>2.mvn install，包含mvn compile，mvn package，然后上传到本地仓库<br>3.mvn deploy,包含mvn install,然后，上传到私服  </p><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a><strong>PS</strong></h2><p>　　一般使用情况是这样，首先通过cvs或svn下载代码到本机，然后执行mvn eclipse:eclipse生成ecllipse项目文件，然后导入到eclipse就行了；修改代码后执行mvn compile或mvn test检验，也可以下载eclipse的maven插件。  </p><h3 id="1-显示版本信息"><a href="#1-显示版本信息" class="headerlink" title="1. 显示版本信息"></a><strong>1. 显示版本信息</strong></h3><p>mvn -version/-v  </p><h3 id="2-创建mvn项目"><a href="#2-创建mvn项目" class="headerlink" title="2. 创建mvn项目"></a><strong>2. 创建mvn项目</strong></h3><p>mvn archetype:create -DgroupI=com.oreilly -DartifactId=my-app  </p><h3 id="3-生成target目录，编译、测试代码，生成测试报告，生成jar-war文件"><a href="#3-生成target目录，编译、测试代码，生成测试报告，生成jar-war文件" class="headerlink" title="3. 生成target目录，编译、测试代码，生成测试报告，生成jar/war文件"></a><strong>3. 生成target目录，编译、测试代码，生成测试报告，生成jar/war文件</strong></h3><p>mvn package</p><h3 id="4-运行项目于jetty上"><a href="#4-运行项目于jetty上" class="headerlink" title="4. 运行项目于jetty上"></a><strong>4. 运行项目于jetty上</strong></h3><p>mvn jetty:run  </p><h3 id="5-显示详细错误-信息"><a href="#5-显示详细错误-信息" class="headerlink" title="5. 显示详细错误 信息"></a><strong>5. 显示详细错误 信息</strong></h3><p>mvn -e</p><h3 id="6-验证工程是否正确，所有需要的资源是否可用"><a href="#6-验证工程是否正确，所有需要的资源是否可用" class="headerlink" title="6. 验证工程是否正确，所有需要的资源是否可用"></a><strong>6. 验证工程是否正确，所有需要的资源是否可用</strong></h3><p>mvn validate</p><h3 id="7-在集成测试可以运行的环境中处理和发布包"><a href="#7-在集成测试可以运行的环境中处理和发布包" class="headerlink" title="7. 在集成测试可以运行的环境中处理和发布包"></a><strong>7. 在集成测试可以运行的环境中处理和发布包</strong></h3><p>mvn integration-test</p><h3 id="8-运行任何检查，验证包是否有效且达到质量标准"><a href="#8-运行任何检查，验证包是否有效且达到质量标准" class="headerlink" title="8. 运行任何检查，验证包是否有效且达到质量标准"></a><strong>8. 运行任何检查，验证包是否有效且达到质量标准</strong></h3><p>mvn verify</p><h3 id="9-产生应用需要的任何额外的源代码，如xdoclet"><a href="#9-产生应用需要的任何额外的源代码，如xdoclet" class="headerlink" title="9. 产生应用需要的任何额外的源代码，如xdoclet"></a><strong>9. 产生应用需要的任何额外的源代码，如xdoclet</strong></h3><p>mvn generate-sources</p><h3 id="10-使用-help-插件的-describe-目标来输出-Maven-Help-插件的信息"><a href="#10-使用-help-插件的-describe-目标来输出-Maven-Help-插件的信息" class="headerlink" title="10. 使用 help 插件的  describe 目标来输出 Maven Help 插件的信息"></a><strong>10. 使用 help 插件的  describe 目标来输出 Maven Help 插件的信息</strong></h3><p>mvn help:describe -Dplugin=help</p><h3 id="11-使用Help-插件输出完整的带有参数的目标列"><a href="#11-使用Help-插件输出完整的带有参数的目标列" class="headerlink" title="11. 使用Help 插件输出完整的带有参数的目标列"></a><strong>11. 使用Help 插件输出完整的带有参数的目标列</strong></h3><p>mvn help:describe -Dplugin=help -Dfull</p><h3 id="12-获取单个目标的信息-设置-mojo-参数和-plugin-参数。此命令列出了Compiler-插件的compile-目标的所有信息"><a href="#12-获取单个目标的信息-设置-mojo-参数和-plugin-参数。此命令列出了Compiler-插件的compile-目标的所有信息" class="headerlink" title="12. 获取单个目标的信息,设置  mojo 参数和  plugin 参数。此命令列出了Compiler 插件的compile 目标的所有信息"></a><strong>12. 获取单个目标的信息,设置  mojo 参数和  plugin 参数。此命令列出了Compiler 插件的compile 目标的所有信息</strong></h3><p>mvn help:describe -Dplugin=compiler -Dmojo=compile -Dfull</p><h3 id="13-列出所有-Maven-Exec-插件可用的目标"><a href="#13-列出所有-Maven-Exec-插件可用的目标" class="headerlink" title="13. 列出所有 Maven Exec 插件可用的目标"></a><strong>13. 列出所有 Maven Exec 插件可用的目标</strong></h3><p>mvn help:describe -Dplugin=exec -Dfull</p><h3 id="14-看这个“有效的-effective-”POM，它暴露了-Maven的默认设置"><a href="#14-看这个“有效的-effective-”POM，它暴露了-Maven的默认设置" class="headerlink" title="14. 看这个“有效的 (effective)”POM，它暴露了 Maven的默认设置"></a><strong>14. 看这个“有效的 (effective)”POM，它暴露了 Maven的默认设置</strong></h3><p>mvn help:effective-pom</p><h3 id="15-想要查看完整的依赖踪迹，包含那些因为冲突或者其它原因而被拒绝引入的构件，打开-Maven-的调试标记运行"><a href="#15-想要查看完整的依赖踪迹，包含那些因为冲突或者其它原因而被拒绝引入的构件，打开-Maven-的调试标记运行" class="headerlink" title="15. 想要查看完整的依赖踪迹，包含那些因为冲突或者其它原因而被拒绝引入的构件，打开 Maven 的调试标记运行"></a><strong>15. 想要查看完整的依赖踪迹，包含那些因为冲突或者其它原因而被拒绝引入的构件，打开 Maven 的调试标记运行</strong></h3><p>mvn install -X</p><h3 id="16-给任何目标添加maven-test-skip-属性就能跳过测试"><a href="#16-给任何目标添加maven-test-skip-属性就能跳过测试" class="headerlink" title="16. 给任何目标添加maven.test.skip 属性就能跳过测试"></a><strong>16. 给任何目标添加maven.test.skip 属性就能跳过测试</strong></h3><p>mvn install -Dmaven.test.skip=true</p><h3 id="17-构建装配Maven-Assembly-插件是一个用来创建你应用程序特有分发包的插件"><a href="#17-构建装配Maven-Assembly-插件是一个用来创建你应用程序特有分发包的插件" class="headerlink" title="17. 构建装配Maven Assembly 插件是一个用来创建你应用程序特有分发包的插件"></a><strong>17. 构建装配Maven Assembly 插件是一个用来创建你应用程序特有分发包的插件</strong></h3><p>mvn install assembly:assembly</p><h3 id="18-生成Wtp插件的Web项目"><a href="#18-生成Wtp插件的Web项目" class="headerlink" title="18. 生成Wtp插件的Web项目"></a><strong>18. 生成Wtp插件的Web项目</strong></h3><p>mvn -Dwtpversion=1.0 eclipse:eclipse</p><h3 id="19-清除Eclipse项目的配置信息-Web项目"><a href="#19-清除Eclipse项目的配置信息-Web项目" class="headerlink" title="19. 清除Eclipse项目的配置信息(Web项目)"></a><strong>19. 清除Eclipse项目的配置信息(Web项目)</strong></h3><p>mvn -Dwtpversion=1.0 eclipse:clean</p><h3 id="20-将项目转化为Eclipse项目"><a href="#20-将项目转化为Eclipse项目" class="headerlink" title="20. 将项目转化为Eclipse项目"></a><strong>20. 将项目转化为Eclipse项目</strong></h3><p>mvn eclipse:eclipse</p><h3 id="21-mvn-exec命令可以执行项目中的main函数"><a href="#21-mvn-exec命令可以执行项目中的main函数" class="headerlink" title="21. mvn exec命令可以执行项目中的main函数"></a><strong>21. mvn exec命令可以执行项目中的main函数</strong></h3><p>首先需要编译java工程：mvn compile<br>不存在参数的情况下：mvn exec:java -Dexec.mainClass=”<strong><em>.Main”<br>存在参数：mvn exec:java -Dexec.mainClass=”</em></strong>.Main” -Dexec.args=”arg0 arg1 arg2”<br>指定运行时库：mvn exec:java -Dexec.mainClass=”***.Main” -Dexec.classpathScope=runtime  </p><h3 id="22-打印出已解决依赖的列表"><a href="#22-打印出已解决依赖的列表" class="headerlink" title="22. 打印出已解决依赖的列表"></a><strong>22. 打印出已解决依赖的列表</strong></h3><p>mvn dependency:resolve</p><h3 id="23-打印整个依赖树"><a href="#23-打印整个依赖树" class="headerlink" title="23. 打印整个依赖树"></a><strong>23. 打印整个依赖树</strong></h3><p>mvn dependency:tree</p><h3 id="在应用程序用使用多个存储库"><a href="#在应用程序用使用多个存储库" class="headerlink" title="在应用程序用使用多个存储库"></a><strong>在应用程序用使用多个存储库</strong></h3><pre><code>&lt;repositories&gt;        &lt;repository&gt;             &lt;id&gt;Ibiblio&lt;/id&gt;             &lt;name&gt;Ibiblio&lt;/name&gt;             &lt;url&gt;http://www.ibiblio.org/maven/&lt;/url&gt;       &lt;/repository&gt;       &lt;repository&gt;             &lt;id&gt;PlanetMirror&lt;/id&gt;             &lt;name&gt;Planet Mirror&lt;/name&gt;             &lt;url&gt;http://public.planetmirror.com/pub/maven/&lt;/url&gt;       &lt;/repository&gt;  &lt;/repositories&gt;</code></pre><p>mvn deploy:deploy-file -DgroupId=com -DartifactId=client -Dversion=0.1.0 -Dpackaging=jar -Dfile=d:\client-0.1.0.jar -DrepositoryId=maven-repository-inner -Durl=<a href="ftp://xxxxxxx/opt/maven/repository/" target="_blank" rel="noopener">ftp://xxxxxxx/opt/maven/repository/</a></p><h3 id="发布第三方Jar到本地库中"><a href="#发布第三方Jar到本地库中" class="headerlink" title="发布第三方Jar到本地库中"></a><strong>发布第三方Jar到本地库中</strong></h3><p>mvn install:install-file -DgroupId=com -DartifactId=client -Dversion=0.1.0 -Dpackaging=jar -Dfile=d:\client-0.1.0.jar<br>-DdownloadSources=true<br>-DdownloadJavadocs=true  </p><h2 id="附加"><a href="#附加" class="headerlink" title="附加"></a><strong>附加</strong></h2><p>mvn help:describe<br>你是否因为记不清某个插件有哪些goal而痛苦过,你是否因为想不起某个goal有哪些参数而苦恼,那就试试这个命令吧,它会告诉你一切的.<br>参数: 1. -Dplugin=pluginName   2. -Dgoal(或-Dmojo)=goalName:与-Dplugin一起使用,它会列出某个插件的goal信息,<br>如果嫌不够详细,同样可以加-Ddetail.(注:一个插件goal也被认为是一个 “Mojo”)<br>下面大家就运行mvn help:describe -Dplugin=help -Dmojo=describe感受一下吧!<br>mvn tomcat:run<br>用了maven后,你再也不需要用eclipse里的tomcat来运行web项目(实际工作中经常会发现用它会出现不同步更新的情况),只需在对应目录里运行 mvn tomat:run命令,然后就可在浏览器里运行查看了.如果你想要更多的定制,可以在pom.xml文件里加下面配置:<br>01 02 03 04 org.codehaus.mojo 05 tomcat-maven-plugin 06 07 /web 08 9090 09 10 11 12 当然你也可以在命令里加参数来实现特定的功能,<br>下面几个比较常用:<br>　　1&gt;. 跳过测试:-Dmaven.test.skip(=true)<br>　　2&gt;. 指定端口:-Dmaven.tomcat.port=9090<br>　　3&gt;. 忽略测试失败:-Dmaven.test.failure.ignore=true 当然,如果你的其它关联项目有过更新的话,一定要在项目根目录下运行mvn clean install来执行更新,再运行mvn tomcat:run使改动生效.   </p><h3 id="mvnDebug-tomcat-run"><a href="#mvnDebug-tomcat-run" class="headerlink" title="mvnDebug tomcat:run"></a><strong>mvnDebug tomcat:run</strong></h3><p>这条命令主要用来远程测试,它会监听远程测试用的8000端口,在eclipse里打开远程测试后,它就会跑起来了,设断点,调试,一切都是这么简单.上面提到的那几个参数在这里同样适用.</p><h3 id="mvn-dependency-sources"><a href="#mvn-dependency-sources" class="headerlink" title="mvn dependency:sources"></a><strong>mvn dependency:sources</strong></h3><p>故名思义,有了它,你就不用到处找源码了,运行一下,你项目里所依赖的jar包的源码就都有了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2018/09/28/2018-9-28-Maven/"/>
      <url>/2018/09/28/2018-9-28-Maven/</url>
      
        <content type="html"><![CDATA[<h2 id="Maven库"><a href="#Maven库" class="headerlink" title="Maven库"></a><strong>Maven库</strong></h2><h2 id="命令行模式安装maven-jar包"><a href="#命令行模式安装maven-jar包" class="headerlink" title="命令行模式安装maven jar包"></a><strong>命令行模式安装maven jar包</strong></h2><p>mvn install:install-file -Dfile=C:\Users\Administrator\Desktop\hibernate-c3p0-4.2.1.final.jar -DgroupId=org.hibernate -DartifactId=hibernate-c3p0 -Dversion=4.2.1 -Dpackaging=jar </p><h3 id="可以到这里下载jar包"><a href="#可以到这里下载jar包" class="headerlink" title="可以到这里下载jar包"></a><strong>可以到这里下载jar包</strong></h3><p><a href="http://repo2.maven.org/maven2/" target="_blank" rel="noopener">http://repo2.maven.org/maven2/</a></p><h3 id="可以到这里复制jar包的pom代码"><a href="#可以到这里复制jar包的pom代码" class="headerlink" title="可以到这里复制jar包的pom代码"></a><strong>可以到这里复制jar包的pom代码</strong></h3><p><a href="http://mvnrepository.com/" target="_blank" rel="noopener">http://mvnrepository.com/</a></p><h2 id="安装配置Maven及其仓库"><a href="#安装配置Maven及其仓库" class="headerlink" title="安装配置Maven及其仓库"></a><strong>安装配置Maven及其仓库</strong></h2><h3 id="maven程序安装的环境准备"><a href="#maven程序安装的环境准备" class="headerlink" title="maven程序安装的环境准备"></a><strong>maven程序安装的环境准备</strong></h3><p>1.maven程序java开发 2.它运行所依赖的jdk<br> <img src="https://viabcde.github.io/images/blog/20180928174.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/blog/20180928175.png" alt="enter descriptionhere">  </p><h3 id="maven的下载和安装"><a href="#maven的下载和安装" class="headerlink" title="maven的下载和安装"></a><strong>maven的下载和安装</strong></h3><p> <strong>找到资料</strong><br> <img src="https://viabcde.github.io/images/blog/20180928176.png" alt="enter descriptionhere"><br><strong>解压到本地磁盘（解压目录不要有中文，空格）</strong><br><img src="https://viabcde.github.io/images/blog/20180928177.png" alt="enter descriptionhere"> </p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a><strong>配置环境变量</strong></h3><p>Jdk环境变量：JAVA_HOME<br><img src="https://viabcde.github.io/images/blog/20180928178.png" alt="enter descriptionhere"><br><strong>将maven_home环境变量配置到path环境变量中</strong><br> <img src="https://viabcde.github.io/images/blog/20180928179.png" alt="enter descriptionhere"><br><strong>检查Maven是否已配置到计算机查询maven的版本信息</strong><br><img src="https://viabcde.github.io/images/blog/20180928180.png" alt="enter descriptionhere"> </p><h4 id="配置本地仓库"><a href="#配置本地仓库" class="headerlink" title="配置本地仓库"></a><strong>配置本地仓库</strong></h4><h3 id="解释Maven仓库"><a href="#解释Maven仓库" class="headerlink" title="解释Maven仓库"></a><strong>解释Maven仓库</strong></h3><p>有三个仓库 本地仓库（自己计算机的、私服（公司内部的）、 和远程仓库（推荐使用阿里巴巴的）<br>仓库类型：<br> <img src="https://viabcde.github.io/images/blog/20180928181.png" alt="enter descriptionhere"><br>配置本地仓库：<br>1、    找到jar包仓库压缩包<br><img src="https://viabcde.github.io/images/blog/20180928182.png" alt="enter descriptionhere"><br>2、    解压到本地磁盘<br>3、    配置本地仓库：让maven程序知道仓库在哪<br>如果是新的仓库 这里的路径可以自己设置 在pom.xml文件会把用到的jar包下载到仓库<br><img src="https://viabcde.github.io/images/blog/20180928183.png" alt="enter descriptionhere"> </p><h2 id="构建SSM工程、java-web工程步骤"><a href="#构建SSM工程、java-web工程步骤" class="headerlink" title="构建SSM工程、java web工程步骤"></a><strong>构建SSM工程、java web工程步骤</strong></h2><h3 id="Maven-三种archetype说明"><a href="#Maven-三种archetype说明" class="headerlink" title="Maven 三种archetype说明"></a><strong>Maven 三种archetype说明</strong></h3><p>1、cocoon-22-archetype-webapp<br>这个项目结构里包含了applicationContext.xml、log4j.xml、web.xml<br>2、maven-archetype-quickstart<br>除了pom.xml外，没有其他的xml了，但是有main、test两个包，包里放了一个App、AppTest类<br>3、maven-archetype-webapp<br>有WEB-INF目录，并且有web.xml和一个index.jsp<br>创建你的maven项目的<br>只需输入archetype:generate,剩下的就是做”选择题”了<br><img src="https://viabcde.github.io/images/2018-10-10/2018101011.png" alt="enter descriptionhere"><br>1、    配置m2e插件，Mars2版本自带maven插件<br>2、    需要配置maven程序<br><img src="https://viabcde.github.io/images/blog/20180928184.png" alt="enter descriptionhere"><br>3、    配置userSetting:让eclipse知道maven仓库位置<br><img src="https://viabcde.github.io/images/blog/20180928185.png" alt="enter descriptionhere"><br>4、    构建索引<br> <img src="https://viabcde.github.io/images/blog/20180928186.png" alt="enter descriptionhere"> </p><h4 id="Maven整合servlet"><a href="#Maven整合servlet" class="headerlink" title="Maven整合servlet"></a><strong>Maven整合servlet</strong></h4><p> <img src="https://viabcde.github.io/images/blog/20180928187.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/blog/20180928188.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/blog/20180928189.png" alt="enter descriptionhere"><br>创建好的web项目，错误：<br>1、    web.xml缺失<br> <img src="https://viabcde.github.io/images/blog/20180928190.png" alt="enter descriptionhere"><br>2、    jdk编译版本1.5，在pom.xml中添加插件<br><img src="https://viabcde.github.io/images/blog/20180928191.png" alt="enter descriptionhere"><br>3、    创建servlet,serlvet编译报错，原因：缺失servlet-api-xx.jar包<br> <img src="https://viabcde.github.io/images/blog/20180928192.png" alt="enter descriptionhere"> </p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a><strong>添加依赖</strong></h3><p>注意：选择依赖选择[jar]<br> <img src="https://viabcde.github.io/images/blog/20180928193.png" alt="enter descriptionhere">  </p><h3 id="传递依赖"><a href="#传递依赖" class="headerlink" title="传递依赖"></a><strong>传递依赖</strong></h3><p>最强的jar依赖 Complie 编译 运行 测试 打包 都包含<br>test 测试<br>runtime 除了编译 其他都包含<br>provied 处理打包 其他都包含<br>system  从本地文件系统拿jar 而非maven仓库<br>传递性：层级最短的，最先被引用的被传递。<br>如A项目有x.jar,B项目也要想x.jar，如果c项目先引用的A又引用的B，则使用A里的jar，如果A里的jar是通过A0引用得到的，则先使用B里的jar。<br>排除不需要的依赖<br>a依赖b，b依赖c,如果我们只想依赖b不依赖c,就要用exclusions  </p><h3 id="解决包冲突问题"><a href="#解决包冲突问题" class="headerlink" title="解决包冲突问题"></a><strong>解决包冲突问题</strong></h3><p>过滤串使用groupId:artifactId:version的方式进行过滤，可以不写全啦，如：<br>mvn dependency:tree -Dverbose -Dincludes=asm:asm<br>然后在pom.xml中把不需要的jar删除<br>引起jar冲突的原因：1.先加载的被引用，后加载的不被引用  </p><h3 id="Caused-by-java-lang-NoClassDefFoundError"><a href="#Caused-by-java-lang-NoClassDefFoundError" class="headerlink" title="Caused by: java.lang.NoClassDefFoundError:"></a><strong>Caused by: java.lang.NoClassDefFoundError:</strong></h3><p>总结了以下，关于maven下的项目，如果出现jar包的问题，应该这样查<br>是否下载完整—可以将该jar包坐在的文件，删除重新下载<br>是否版本一致—可以全局定义一个version，下载相关使用version<br>是否被打包—查看tomcat文件下对应项目中的webinf-lib下有没有对应的jar包，然后在看看pom.xml中是怎样配置的  </p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><strong>生命周期</strong></h3><p>举个例子来说就是maven 对一个工程进行：<br>验证（validate）<br>编译源码（compile）<br>编译测试源码（test-compile）<br>单元测试（test）<br>打包（package）<br>安装至本地仓库（install）<br>部署到远程仓库（deploy）<br>执行后面的会把前面的步骤也执行  </p><h3 id="私服搭建和使用"><a href="#私服搭建和使用" class="headerlink" title="私服搭建和使用"></a><strong>私服搭建和使用</strong></h3><h3 id="Maven三种打包方式"><a href="#Maven三种打包方式" class="headerlink" title="Maven三种打包方式"></a><strong>Maven三种打包方式</strong></h3><p>Maven可以使用mvn package指令对项目进行打包，如果使用Java -jar xxx.jar执行运行jar文件，会出现”no main manifest attribute, in xxx.jar”（没有设置Main-Class）、ClassNotFound Exception（找不到依赖包）等错误。<br>要想jar包能直接通过java -jar xxx.jar运行，需要满足：<br>1、在jar包中的META-INF/MANIFEST.MF中指定Main-Class，这样才能确定程序的入口在哪里；<br>2、要能加载到依赖包。<br>使用Maven有以下几种方法可以生成能直接运行的jar包，可以根据需要选择一种合适的方法。<br>方法一：使用maven-jar-plugin和maven-dependency-plugin插件打包<br>在pom.xml中配置：  </p><pre><code>&lt;build&gt;      &lt;plugins&gt;          &lt;plugin&gt;              &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;              &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;              &lt;version&gt;2.6&lt;/version&gt;              &lt;configuration&gt;                  &lt;archive&gt;                      &lt;manifest&gt;                          &lt;addClasspath&gt;true&lt;/addClasspath&gt;                          &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;                          &lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt;                      &lt;/manifest&gt;                  &lt;/archive&gt;              &lt;/configuration&gt;          &lt;/plugin&gt;          &lt;plugin&gt;              &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;              &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;              &lt;version&gt;2.10&lt;/version&gt;              &lt;executions&gt;                  &lt;execution&gt;                      &lt;id&gt;copy-dependencies&lt;/id&gt;                      &lt;phase&gt;package&lt;/phase&gt;                      &lt;goals&gt;                          &lt;goal&gt;copy-dependencies&lt;/goal&gt;                      &lt;/goals&gt;                      &lt;configuration&gt;                        &lt;outputDirectory&gt;${project.build.directory}/lib&lt;/outputDirectory&gt;                      &lt;/configuration&gt;                  &lt;/execution&gt;              &lt;/executions&gt;          &lt;/plugin&gt;      &lt;/plugins&gt;  &lt;/build&gt;  </code></pre><p>maven-jar-plugin用于生成META-INF/MANIFEST.MF文件的部分内容，  </p><pre><code>&lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt;</code></pre><p>指定MANIFEST.MF中的Main-Class，</p><pre><code>&lt;addClasspath&gt;true&lt;/addClasspath&gt;</code></pre><p>会在MANIFEST.MF加上Class-Path项并配置依赖包，</p><pre><code>&lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;</code></pre><p>指定依赖包所在目录。<br>例如下面是一个通过maven-jar-plugin插件生成的MANIFEST.MF文件片段：<br>Class-Path: lib/commons-logging-1.2.jar lib/commons-io-2.4.jar<br>Main-Class: com.xxg.Main<br>只是生成MANIFEST.MF文件还不够，maven-dependency-plugin插件用于将依赖包拷贝到 </p><pre><code> &lt;outputDirectory&gt;${project.build.directory}/lib&lt;/outputDirectory&gt;</code></pre><p>指定的位置，即lib目录下。<br>配置完成后，通过mvn package指令打包，会在target目录下生成jar包，并将依赖包拷贝到target/lib目录下，目录结构如下：<br>指定了Main-Class，有了依赖包，那么就可以直接通过java -jar xxx.jar运行jar包。<br>这种方式生成jar包有个缺点，就是生成的jar包太多不便于管理，下面两种方式只生成一个jar文件，包含项目本身的代码、资源以及所有的依赖包。<br>方法二：使用maven-assembly-plugin插件打包<br>在pom.xml中配置：  </p><pre><code>&lt;build&gt;      &lt;plugins&gt;          &lt;plugin&gt;              &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;              &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;              &lt;version&gt;2.5.5&lt;/version&gt;              &lt;configuration&gt;                  &lt;archive&gt;                      &lt;manifest&gt;                          &lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt;                      &lt;/manifest&gt;                  &lt;/archive&gt;                  &lt;descriptorRefs&gt;                      &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;                  &lt;/descriptorRefs&gt;              &lt;/configuration&gt;          &lt;/plugin&gt;      &lt;/plugins&gt;  &lt;/build&gt;  </code></pre><p>打包方式：<br>mvn package assembly:single<br>打包后会在target目录下生成一个xxx-jar-with-dependencies.jar文件，这个文件不但包含了自己项目中的代码和资源，还包含了所有依赖包的内容。所以可以直接通过java -jar来运行。<br>此外还可以直接通过mvn package来打包，无需assembly:single，不过需要加上一些配置：  </p><pre><code>&lt;build&gt;      &lt;plugins&gt;          &lt;plugin&gt;              &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;              &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;              &lt;version&gt;2.5.5&lt;/version&gt;              &lt;configuration&gt;                  &lt;archive&gt;                      &lt;manifest&gt;                          &lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt;                      &lt;/manifest&gt;                  &lt;/archive&gt;                  &lt;descriptorRefs&gt;                      &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;                  &lt;/descriptorRefs&gt;              &lt;/configuration&gt;              &lt;executions&gt;                  &lt;execution&gt;                      &lt;id&gt;make-assembly&lt;/id&gt;                      &lt;phase&gt;package&lt;/phase&gt;                      &lt;goals&gt;                          &lt;goal&gt;single&lt;/goal&gt;                      &lt;/goals&gt;                  &lt;/execution&gt;              &lt;/executions&gt;          &lt;/plugin&gt;      &lt;/plugins&gt;  &lt;/build&gt;  </code></pre><p>其中  </p><pre><code>&lt;phase&gt;package&lt;/phase&gt;、&lt;goal&gt;single&lt;/goal&gt;</code></pre><p>即表示在执行package打包时，执行assembly:single，所以可以直接使用mvn package打包。<br>不过，如果项目中用到spring Framework，用这种方式打出来的包运行时会出错，使用下面的方法三可以处理。<br>方法三：使用maven-shade-plugin插件打包<br>在pom.xml中配置：  </p><pre class=" language-&lt;build&gt;"><code class="language-&lt;build&gt;">    <plugins>          <plugin>              <groupId>org.apache.maven.plugins</groupId>              <artifactId>maven-shade-plugin</artifactId>              <version>2.4.1</version>              <executions>                  <execution>                      <phase>package</phase>                      <goals>                          <goal>shade</goal>                      </goals>                      <configuration>                          <transformers>                              <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">                                  <mainClass>com.xxg.Main</mainClass>                              </transformer>                          </transformers>                      </configuration>                  </execution>              </executions>          </plugin>      </plugins>  </build>  </code></pre><p>配置完成后，执行mvn package即可打包。在target目录下会生成两个jar包，注意不是original-xxx.jar文件，而是另外一个。和maven-assembly-plugin一样，生成的jar文件包含了所有依赖，所以可以直接运行。<br>如果项目中用到了Spring Framework，将依赖打到一个jar包中，运行时会出现读取XML schema文件出错。原因是Spring Framework的多个jar包中包含相同的文件spring.handlers和spring.schemas，如果生成一个jar包会互相覆盖。为了避免互相影响，可以使用AppendingTransformer来对文件内容追加合并：  </p><pre><code>&lt;build&gt;      &lt;plugins&gt;          &lt;plugin&gt;              &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;              &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;              &lt;version&gt;2.4.1&lt;/version&gt;              &lt;executions&gt;                  &lt;execution&gt;                      &lt;phase&gt;package&lt;/phase&gt;                      &lt;goals&gt;                          &lt;goal&gt;shade&lt;/goal&gt;                      &lt;/goals&gt;                      &lt;configuration&gt;                          &lt;transformers&gt;                              &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;                                  &lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt;                              &lt;/transformer&gt;                              &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;&gt;              &lt;resource&gt;META-INF/spring.handlers&lt;/resource&gt;                              &lt;/transformer&gt;                              &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;&gt;                               &lt;resource&gt;META-INF/spring.schemas&lt;/resource&gt;                              &lt;/transformer&gt;                          &lt;/transformers&gt;                      &lt;/configuration&gt;                  &lt;/execution&gt;              &lt;/executions&gt;          &lt;/plugin&gt;      &lt;/plugins&gt;  &lt;/build&gt;  </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="/2018/09/26/2018-9-26-html/"/>
      <url>/2018/09/26/2018-9-26-html/</url>
      
        <content type="html"><![CDATA[<h3 id="lt-b-gt-、-lt-p-gt"><a href="#lt-b-gt-、-lt-p-gt" class="headerlink" title="&lt;b&gt;、&lt;p&gt;"></a><code>&lt;b&gt;、&lt;p&gt;</code></h3><p><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/34.png" alt="enter descriptionhere"><br><strong>代码</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;这是普通文本 - &lt;b&gt;这是粗体文本&lt;/b&gt;。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="lt-h-gt"><a href="#lt-h-gt" class="headerlink" title="&lt;h&gt;"></a><code>&lt;h&gt;</code></h3><p><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/37.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;h1&gt;This is heading 1&lt;/h1&gt;&lt;h2&gt;This is heading 2&lt;/h2&gt;&lt;h3&gt;This is heading 3&lt;/h3&gt;&lt;h4&gt;This is heading 4&lt;/h4&gt;&lt;h5&gt;This is heading 5&lt;/h5&gt;&lt;h6&gt;This is heading 6&lt;/h6&gt;&lt;p&gt;请仅仅把标题标签用于标题文本。不要仅仅为了产生粗体文本而使用它们。请使用其它标签或 CSS 代替。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a><strong>链接</strong></h3><pre><code>&lt;a href=&quot;http://www.runoob.com&quot;&gt;这是一个链接&lt;/a&gt;</code></pre><h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a><strong>图像</strong></h3><pre><code>&lt;img src=&quot;/images/logo.png&quot; width=&quot;258&quot; height=&quot;39&quot; /&gt;</code></pre><h3 id="HTML-水平线-lt-hr-gt-标签在-HTML-页面中创建水平线"><a href="#HTML-水平线-lt-hr-gt-标签在-HTML-页面中创建水平线" class="headerlink" title="HTML 水平线&lt;hr&gt; 标签在 HTML 页面中创建水平线"></a><strong>HTML 水平线<code>&lt;hr&gt;</code> 标签在 HTML 页面中创建水平线</strong></h3><h3 id="HTML-折行如果您希望在不产生一个新段落的情况下进行换行（新行），请使用-lt-br-gt-标签："><a href="#HTML-折行如果您希望在不产生一个新段落的情况下进行换行（新行），请使用-lt-br-gt-标签：" class="headerlink" title="HTML 折行如果您希望在不产生一个新段落的情况下进行换行（新行），请使用 &lt;br&gt; 标签："></a><strong>HTML 折行如果您希望在不产生一个新段落的情况下进行换行（新行），请使用 <code>&lt;br&gt;</code> 标签：</strong></h3><h3 id="下拉列表标签和选项标签"><a href="#下拉列表标签和选项标签" class="headerlink" title="下拉列表标签和选项标签"></a><strong>下拉列表标签和选项标签</strong></h3><pre><code>&lt;select name = “名称”&gt;&lt;option value = “value1”&gt; 选项1&lt;/option&gt;&lt;/select&gt;</code></pre><h3 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a><strong>文本域</strong></h3><pre><code>&lt;textarea rows =”行数” cols = “列数” name = “名称” &gt;文本内容&lt;/textarea&gt;</code></pre><h3 id="块标签"><a href="#块标签" class="headerlink" title="块标签"></a><strong>块标签</strong></h3><pre><code>&lt;div position = absolute|relative visibility = visible|hidden|inherit top =”像素”right=”像素” bottom = “像素” left = “像素” margin = “像素” height = “像素” width = “像素”&gt;&lt;div&gt;</code></pre><h3 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a><strong>超链接标签</strong></h3><pre><code>&lt;a href =”目标页面” target “打开方式”&gt;超链接名称或图片&lt;/a&gt;</code></pre><h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a><strong>声明变量</strong></h3><p>&lt;%!  %&gt;</p><h3 id="声明方法-备注-：页面级的，仅在所在页面有效"><a href="#声明方法-备注-：页面级的，仅在所在页面有效" class="headerlink" title="声明方法 备注 ：页面级的，仅在所在页面有效"></a><strong>声明方法</strong> <em>备注</em> ：页面级的，仅在所在页面有效</h3><p>&lt;%!  %&gt;      </p><h3 id="表达式-备注：-不需要分号“；”"><a href="#表达式-备注：-不需要分号“；”" class="headerlink" title="表达式 备注： 不需要分号“；”"></a><strong>表达式</strong> <em>备注：</em> 不需要分号“；”</h3><p>&lt;%=  %&gt; </p><h3 id="java程序段"><a href="#java程序段" class="headerlink" title="java程序段"></a><strong>java程序段</strong></h3><p>&lt;%  %&gt; 可分为不同的part，但最终JSP转为Servlet(即java类)时，都是合在一起放入到service()</p><h3 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a><strong>include指令</strong></h3><p> &lt;%@ include file = “url” %&gt;<br> <em>备注：</em> 指令与主文件不能冲突，变量也不能与主文件变量同名，因为这两个文件是同时编译的，即include是静态包含，指令会重复</p><h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a><strong>PreparedStatement</strong></h3><p> 所执行的动态SQL语句将被预编译并保存到PreparedStatement中，从而可以反复并高效的执行SQL语句，有效减少程序员拼写SQL字符串导致的语法错误<br>Ctrl+U查看网页源代码</p><h3 id="lt-noscrtpt-gt"><a href="#lt-noscrtpt-gt" class="headerlink" title="&lt;noscrtpt&gt;"></a><strong><code>&lt;noscrtpt&gt;</code></strong></h3><p>noscript 元素用来定义在脚本未被执行时的替代内容（文本）<br>效果：<br><img src="https://viabcde.github.io/images/201812/46.png" alt="enter descriptionhere"><br>代码：  </p><pre><code>&lt;script&gt;document.write(&quot;Hello World!&quot;)&lt;/script&gt;&lt;noscript&gt;抱歉，你的浏览器不支持 JavaScript!&lt;/noscript&gt;</code></pre><h3 id="input"><a href="#input" class="headerlink" title="input"></a><strong>input</strong></h3><p>accept    mime_type    规定通过文件上传来提交的文件的类型。<br>如果不限制图像的格式，可以写为：<code>accept=&quot;image/*&quot;</code>。<br>定义和用法<br>accept 属性只能与 <code>&lt;input type=&quot;file&quot;&gt;</code> 配合使用。它规定能够通过文件上传进行提交的文件类型。   </p><p>提示：请避免使用该属性。应该在服务器端验证文件上传。<br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/77.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;demo_form.asp&quot;&gt;  &lt;input type=&quot;file&quot; name=&quot;pic&quot; accept=&quot;image/*&quot;&gt;  &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;p&gt;&lt;strong&gt;注释：&lt;/strong&gt;Internet Explorer 9 以及更早的版本不支持 input 标签的 accept 属性。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注释：&lt;/strong&gt;鉴于安全考虑，该例不允许您上传文件。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>align    ：left、right、top、middle、bottom不赞成使用。规定图像输入的对齐方式。<br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/78.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html/form_action.asp&quot; method=&quot;get&quot;&gt;  &lt;p&gt;First name: &lt;input type=&quot;text&quot; name=&quot;fname&quot; /&gt;&lt;/p&gt;  &lt;p&gt;Last name: &lt;input type=&quot;text&quot; name=&quot;lname&quot; /&gt;&lt;/p&gt;  &lt;input type=&quot;image&quot; src=&quot;/i/eg_submit.jpg&quot; alt=&quot;Submit&quot; align=&quot;right&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>alt    text    定义图像输入的替代文本。<br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html/form_action.asp&quot; method=&quot;get&quot;&gt;  &lt;p&gt;First name: &lt;input type=&quot;text&quot; name=&quot;fname&quot; /&gt;&lt;/p&gt;  &lt;p&gt;Last name: &lt;input type=&quot;text&quot; name=&quot;lname&quot; /&gt;&lt;/p&gt;  &lt;input type=&quot;image&quot; src=&quot;/i/eg_submit.jpg&quot; alt=&quot;Submit&quot; align=&quot;right&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>autocomplete    ：on、off规定是否使用输入字段的自动完成功能。<br>自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。   </p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html5/demo_form.asp&quot; method=&quot;get&quot; autocomplete=&quot;on&quot;&gt;First name:&lt;input type=&quot;text&quot; name=&quot;fname&quot; /&gt;&lt;br /&gt;Last name: &lt;input type=&quot;text&quot; name=&quot;lname&quot; /&gt;&lt;br /&gt;E-mail: &lt;input type=&quot;email&quot; name=&quot;email&quot; autocomplete=&quot;off&quot; /&gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>autofocus    autofocus    规定输入字段在页面加载时是否获得焦点。</p><p>（不适用于 type=”hidden”）</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;demo_form.asp&quot;&gt;  First name: &lt;input type=&quot;text&quot; name=&quot;fname&quot; autofocus&gt;&lt;br&gt;  Last name: &lt;input type=&quot;text&quot; name=&quot;lname&quot;&gt;&lt;br&gt;  &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>checked    checked    规定此 input 元素首次加载时应当被选中。<br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/79.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html/form_action.asp&quot; method=&quot;get&quot;&gt;  &lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Bike&quot; /&gt; I have a bike&lt;/p&gt;  &lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Car&quot; checked=&quot;checked&quot; /&gt; I have a car&lt;/p&gt;  &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;&lt;p&gt;请在提交按钮上单击，输入会发送到服务器上名为 &quot;form_action.asp&quot; 的页面。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>disabled    disabled    当 input 元素加载时禁用此元素。<br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/80.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html/form_action.asp&quot; method=&quot;get&quot;&gt;  &lt;p&gt;First name: &lt;input type=&quot;text&quot; name=&quot;fname&quot; /&gt;&lt;/p&gt;  &lt;p&gt;Last name: &lt;input type=&quot;text&quot; name=&quot;lname&quot; disabled=&quot;disabled&quot; /&gt;&lt;/p&gt;  &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;&lt;p&gt;请在提交按钮上单击，输入会发送到服务器上名为 &quot;form_action.asp&quot; 的页面。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>form    formname    规定输入字段所属的一个或多个表单。<br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/80.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html5/demo_form.asp&quot; method=&quot;get&quot; id=&quot;form1&quot;&gt;First name: &lt;input type=&quot;text&quot; name=&quot;fname&quot; /&gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;p&gt;下面的 &quot;Last name&quot; 字段位于 form 元素之外，但仍然是表单的一部分。&lt;/p&gt;Last name: &lt;input type=&quot;text&quot; name=&quot;lname&quot; form=&quot;form1&quot; /&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>formaction    URL    覆盖表单的 action 属性。<br>（适用于 type=”submit” 和 type=”image”）<br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/81.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html5/demo_form.asp&quot; method=&quot;get&quot;&gt;First name: &lt;input type=&quot;text&quot; name=&quot;fname&quot; /&gt;&lt;br /&gt;Last name: &lt;input type=&quot;text&quot; name=&quot;lname&quot; /&gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; formaction=&quot;/example/html5/demo_admin.asp&quot; value=&quot;以管理员身份提交&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>formenctype    见注释    覆盖表单的 enctype 属性。  </p><p>（适用于 type=”submit” 和 type=”image”）<br>enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。<br>application/x-www-form-urlencoded    在发送前编码所有字符（默认）<br>multipart/form-data    不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。<br>text/plain    空格转换为 “+” 加号，但不对特殊字符编码。   </p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html5/demo_post_enctype.asp&quot; method=&quot;post&quot;&gt;  First name: &lt;input type=&quot;text&quot; name=&quot;fname&quot; /&gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;input type=&quot;submit&quot; formenctype=&quot;multipart/form-data&quot; value=&quot;以 Multipart/form-data 编码提交&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>formmethod    :get、post覆盖表单的 method 属性。</p><p>（适用于 type=”submit” 和 type=”image”）</p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html5/demo_form.asp&quot; method=&quot;get&quot;&gt;  First name: &lt;input type=&quot;text&quot; name=&quot;fname&quot; /&gt;&lt;br /&gt;  Last name: &lt;input type=&quot;text&quot; name=&quot;lname&quot; /&gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;input type=&quot;submit&quot; formmethod=&quot;post&quot; formaction=&quot;/example/html5/demo_post.asp&quot; value=&quot;使用 POST 提交&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>formnovalidate    formnovalidate<br>覆盖表单的 novalidate 属性。<br>如果使用该属性，则提交表单时不进行验证。</p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html5/demo_form.asp&quot; method=&quot;get&quot;&gt;E-mail: &lt;input type=&quot;email&quot; name=&quot;userid&quot; /&gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; formnovalidate=&quot;formnovalidate&quot; value=&quot;进行没有验证的提交&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>formtarget    ：_blank、_self、_parent、_top、framename覆盖表单的 target 属性。</p><p>（适用于 type=”submit” 和 type=”image”）</p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html5/demo_form.asp&quot; method=&quot;get&quot;&gt;  First name: &lt;input type=&quot;text&quot; name=&quot;fname&quot; /&gt;&lt;br /&gt;  Last name: &lt;input type=&quot;text&quot; name=&quot;lname&quot; /&gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;input type=&quot;submit&quot; formtarget=&quot;_blank&quot; value=&quot;提交到新窗口/选项卡&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>height    ：pixels、%、定义 input 字段的高度。（适用于 type=”image”）</p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html5/demo_form.asp&quot; method=&quot;get&quot;&gt;  First name: &lt;input type=&quot;text&quot; name=&quot;fname&quot; /&gt;&lt;br /&gt;  Last name: &lt;input type=&quot;text&quot; name=&quot;lname&quot; /&gt;&lt;br /&gt;  &lt;input type=&quot;image&quot; src=&quot;/i/eg_submit.jpg&quot; alt=&quot;Submit&quot; width=&quot;128&quot; height=&quot;128&quot;/&gt;&lt;/form&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;默认地，image 输入类型会发生点击图像按钮时的 X 和 Y 坐标。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;    </code></pre><p>list    datalist-id    引用包含输入字段的预定义选项的 datalist 。<br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/83.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html5/demo_form.asp&quot;&gt;网页：&lt;input type=&quot;url&quot; list=&quot;url_list&quot; name=&quot;link&quot; /&gt;&lt;datalist id=&quot;url_list&quot;&gt;    &lt;option label=&quot;W3School&quot; value=&quot;http://www.w3school.com.cn&quot; /&gt;    &lt;option label=&quot;Google&quot; value=&quot;http://www.google.com&quot; /&gt;    &lt;option label=&quot;Microsoft&quot; value=&quot;http://www.microsoft.com&quot; /&gt;&lt;/datalist&gt;&lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>max    ：number、date、规定输入字段的最大值。请与 “min” 属性配合使用，来创建合法值的范围。</p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html5/demo_form.asp&quot; method=&quot;get&quot;&gt;Points: &lt;input type=&quot;number&quot; name=&quot;points&quot; min=&quot;0&quot; max=&quot;10&quot; /&gt;&lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>maxlength    number    规定输入字段中的字符的最大长度。</p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html/form_action.asp&quot; method=&quot;get&quot;&gt;  &lt;p&gt;Name: &lt;input type=&quot;text&quot; name=&quot;fullname&quot; maxlength=&quot;85&quot; /&gt;&lt;/p&gt;  &lt;p&gt;Email: &lt;input type=&quot;text&quot; name=&quot;email&quot; maxlength=&quot;55&quot; /&gt;&lt;/p&gt;  &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;&lt;p&gt;请在提交按钮上单击，输入会发送到服务器上名为 &quot;form_action.asp&quot; 的页面。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>multiple    multiple    如果使用该属性，则允许一个以上的值。<br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/84.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html5/demo_form.asp&quot; method=&quot;get&quot;&gt;选择图片：&lt;input type=&quot;file&quot; name=&quot;img&quot; multiple=&quot;multiple&quot; /&gt;&lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;p&gt;请尝试在浏览文件时选取一个以上的文件。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>name    field_name    定义 input 元素的名称。<br>name 属性规定 input 元素的名称。   </p><p>name 属性用于对提交到服务器后的表单数据进行标识，或者在客户端通过 JavaScript 引用表单数据。   </p><p>注释：只有设置了 name 属性的表单元素才能在提交表单时传递它们的值。   </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html/form_action.asp&quot; method=&quot;get&quot;&gt;  &lt;p&gt;Name: &lt;input type=&quot;text&quot; name=&quot;fullname&quot; /&gt;&lt;/p&gt;  &lt;p&gt;Email: &lt;input type=&quot;text&quot; name=&quot;email&quot; /&gt;&lt;/p&gt;  &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;&lt;p&gt;请在提交按钮上单击，输入会发送到服务器上名为 &quot;form_action.asp&quot; 的页面。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>pattern    regexp_pattern<br>规定输入字段的值的模式或格式。</p><p>例如 pattern=”[0-9]” 表示输入值必须是 0 与 9 之间的数字。<br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/85.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html5/demo_form.asp&quot; method=&quot;get&quot;&gt;国家代码：&lt;input type=&quot;text&quot; name=&quot;country_code&quot; pattern=&quot;[A-z]{3}&quot;title=&quot;三个字母的国家代码&quot; /&gt;&lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>placeholder    text    规定帮助用户填写输入字段的提示。</p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html5/demo_form.asp&quot; method=&quot;get&quot;&gt;&lt;input type=&quot;search&quot; name=&quot;user_search&quot; placeholder=&quot;Search W3School&quot; /&gt;&lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>readonly    readonly    规定输入字段为只读。</p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html/form_action.asp&quot; method=&quot;get&quot;&gt;  &lt;p&gt;Name:&lt;input type=&quot;text&quot; name=&quot;email&quot; /&gt;&lt;/p&gt;  &lt;p&gt;Country:&lt;input type=&quot;text&quot; name=&quot;country&quot;   value=&quot;China&quot; readonly=&quot;readonly&quot; /&gt;&lt;/p&gt;  &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;&lt;p&gt;请在提交按钮上单击，输入会发送到服务器上名为 &quot;form_action.asp&quot; 的页面。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>required    required    指示输入字段的值是必需的。</p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html5/demo_form.asp&quot; method=&quot;get&quot;&gt;Name: &lt;input type=&quot;text&quot; name=&quot;usr_name&quot; required=&quot;required&quot; /&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>size    ：number_of_char    定义输入字段的宽度。</p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html/form_action.asp&quot; method=&quot;get&quot;&gt;  &lt;p&gt;Email: &lt;input type=&quot;text&quot; name=&quot;email&quot; size=&quot;35&quot; /&gt;&lt;/p&gt;  &lt;p&gt;PIN: &lt;input type=&quot;text&quot; name=&quot;pin&quot; maxlength=&quot;18&quot; size=&quot;18&quot; /&gt;&lt;/p&gt;  &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;&lt;p&gt;请在提交按钮上单击，输入会发送到服务器上名为 &quot;form_action.asp&quot; 的页面。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>src：    URL    定义以提交按钮形式显示的图像的 URL。<br>src 属性只能与 <code>&lt;input type=&quot;image&quot;&gt;</code> 配合使用。它规定作为提交按钮显示的图像的 URL。</p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html/form_action.asp&quot; method=&quot;get&quot;&gt;  &lt;p&gt;First name: &lt;input type=&quot;text&quot; name=&quot;fname&quot; /&gt;&lt;/p&gt;  &lt;p&gt;Last name: &lt;input type=&quot;text&quot; name=&quot;lname&quot; /&gt;&lt;/p&gt;  &lt;input type=&quot;image&quot; src=&quot;/i/eg_submit.jpg&quot; alt=&quot;Submit&quot; /&gt;&lt;/form&gt;&lt;p&gt;请在这幅图像上单击，输入会发送到服务器上名为 &quot;form_action.asp&quot; 的页面。&lt;/p&gt;&lt;p&gt;注释：如果 type 属性设置为 image，当用户单击图像时，浏览器将以像素为单位，将鼠标相对于图像边界的偏移量发送到服务器，其中包括从图像左边界开始的水平偏移量，以及从图像上边界开始的垂直偏移量。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>step    number    规定输入字的的合法数字间隔。step 属性规定输入字段的合法数字间隔（假如 step=”3”，则合法数字应该是 -3、0、3、6，以此类推）。</p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html5/demo_form.asp&quot; method=&quot;get&quot;&gt;&lt;input type=&quot;number&quot; name=&quot;points&quot; step=&quot;3&quot; /&gt;&lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>type    ：button、checkbox、file、hidden、image、password、radio、reset、submit、text规定 input 元素的类型。<br>value    value    规定 input 元素的值。<br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/86.png" alt="enter descriptionhere"><br><strong>代码</strong>   </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/example/html/form_action.asp&quot; method=&quot;get&quot;&gt;  First name: &lt;input type=&quot;text&quot; name=&quot;fname&quot; value=&quot;George&quot; /&gt;&lt;br /&gt;  Last name: &lt;input type=&quot;text&quot; name=&quot;lname&quot; value=&quot;Bush&quot; /&gt;&lt;br /&gt;  &lt;input type=&quot;submit&quot; value=&quot;Submit form&quot; /&gt;&lt;/form&gt;&lt;p&gt;请单击重置按钮，可以清空表单。&lt;/p&gt;&lt;p&gt;请单击确认按钮，输入会发送到服务器上名为 &quot;form_action.asp&quot; 的页面。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>width<br>pixels<br>%<br>定义 input 字段的宽度。（适用于 type=”image”）</p><h3 id="form标签"><a href="#form标签" class="headerlink" title="form标签"></a><strong>form标签</strong></h3><p>每个元素都有一个 type 属性，其字符串值说明了元素的类型<br><strong>文本域text</strong><br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/54.png" alt="enter descriptionhere"><br><strong>代码</strong>   </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form&gt;名：&lt;input type=&quot;text&quot; name=&quot;firstname&quot;&gt;&lt;br /&gt;姓：&lt;input type=&quot;text&quot; name=&quot;lastname&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>密码域password</strong><br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/55.png" alt="enter descriptionhere">         </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form&gt;用户：&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br /&gt;密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/form&gt;&lt;p&gt;请注意，当您在密码域中键入字符时，浏览器将使用项目符号来代替这些字符。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>复选框checkbox</strong><br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/56.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form&gt;我喜欢自行车：&lt;input type=&quot;checkbox&quot; name=&quot;Bike&quot;&gt;&lt;br /&gt;我喜欢汽车：&lt;input type=&quot;checkbox&quot; name=&quot;Car&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>单选框radio</strong><br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/57.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form&gt;男性：&lt;input type=&quot;radio&quot; checked=&quot;checked&quot; name=&quot;Sex&quot; value=&quot;male&quot; /&gt;&lt;br /&gt;女性：&lt;input type=&quot;radio&quot; name=&quot;Sex&quot; value=&quot;female&quot; /&gt;&lt;/form&gt;&lt;p&gt;当用户点击一个单选按钮时，该按钮会变为选中状态，其他所有按钮会变为非选中状态。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>下拉列表selection-option</strong><br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/58.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form&gt;&lt;select name=&quot;cars&quot;&gt;&lt;option value=&quot;volvo&quot;&gt;Volvo&lt;/option&gt;&lt;option value=&quot;saab&quot;&gt;Saab&lt;/option&gt;&lt;option value=&quot;fiat&quot;&gt;Fiat&lt;/option&gt;&lt;option value=&quot;audi&quot;&gt;Audi&lt;/option&gt;&lt;/select&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>指定预选值的下拉列表selection-option</strong><br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/59.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form&gt;&lt;select name=&quot;cars&quot;&gt;&lt;option value=&quot;volvo&quot;&gt;Volvo&lt;/option&gt;&lt;option value=&quot;saab&quot;&gt;Saab&lt;/option&gt;&lt;option value=&quot;fiat&quot; selected=&quot;selected&quot;&gt;Fiat&lt;/option&gt;&lt;option value=&quot;audi&quot;&gt;Audi&lt;/option&gt;&lt;/select&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>文本域textarea</strong><br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/60.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;p&gt;This example cannot be editedbecause our editor uses a textareafor input,and your browser does not allowa textarea inside a textarea.&lt;/p&gt;&lt;textarea rows=&quot;10&quot; cols=&quot;30&quot;&gt;The cat was playing in the garden.</code></pre><p><strong>按钮type=”button”</strong><br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/61.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form&gt;&lt;input type=&quot;button&quot; value=&quot;Hello world!&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>带标题的文本框Fieldset</strong><br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/62.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;body&gt;&lt;form&gt;  &lt;fieldset&gt;    &lt;legend&gt;健康信息&lt;/legend&gt;    身高：&lt;input type=&quot;text&quot; /&gt;    体重：&lt;input type=&quot;text&quot; /&gt;  &lt;/fieldset&gt;&lt;/form&gt;&lt;p&gt;如果表单周围没有边框，说明您的浏览器太老了。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>输入框加确认按钮的表单</strong><br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/63.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/demo/demo_form.asp&quot;&gt;First name:&lt;br&gt;&lt;input type=&quot;text&quot; name=&quot;firstname&quot; value=&quot;Mickey&quot;&gt;&lt;br&gt;Last name:&lt;br&gt;&lt;input type=&quot;text&quot; name=&quot;lastname&quot; value=&quot;Mouse&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt; &lt;p&gt;如果您点击提交，表单数据会被发送到名为 demo_form.asp 的页面。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>多选框的表单</strong><br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/64.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form name=&quot;input&quot; action=&quot;/html/html_form_action.asp&quot; method=&quot;get&quot;&gt;I have a bike:&lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Bike&quot; checked=&quot;checked&quot; /&gt;&lt;br /&gt;I have a car: &lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Car&quot; /&gt;&lt;br /&gt;I have an airplane: &lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Airplane&quot; /&gt;&lt;br /&gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt; &lt;p&gt;如果您点击 &quot;Submit&quot; 按钮，您将把输入传送到名为 html_form_action.asp 的新页面。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>单选框的表单</strong><br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/65.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot; checked&gt;Male&lt;br&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;Female&lt;/form&gt; &lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>表单发送电子邮件</strong><br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/66.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;form action=&quot;MAILTO:someone@w3school.com.cn&quot; method=&quot;post&quot; enctype=&quot;text/plain&quot;&gt;&lt;h3&gt;这个表单会把电子邮件发送到 W3School。&lt;/h3&gt;姓名：&lt;br /&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;yourname&quot; size=&quot;20&quot;&gt;&lt;br /&gt;电邮：&lt;br /&gt;&lt;input type=&quot;text&quot; name=&quot;mail&quot; value=&quot;yourmail&quot; size=&quot;20&quot;&gt;&lt;br /&gt;内容：&lt;br /&gt;&lt;input type=&quot;text&quot; name=&quot;comment&quot; value=&quot;yourcomment&quot; size=&quot;40&quot;&gt;&lt;br /&gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; value=&quot;发送&quot;&gt;&lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="table标签"><a href="#table标签" class="headerlink" title="table标签"></a><strong>table标签</strong></h2><p><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/67.png" alt="enter descriptionhere"><br><strong>代码</strong><br>tr 元素定义表格行，th 元素定义表头，td 元素定义表格单元</p><pre><code>&lt;html&gt;&lt;body&gt;&lt;table border=&quot;1&quot;&gt;  &lt;tr&gt;    &lt;th&gt;Month&lt;/th&gt;    &lt;th&gt;Savings&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;January&lt;/td&gt;    &lt;td&gt;$100&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>align    ：left、center、right<br>规定表格相对周围元素的对齐方式。<br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/68.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;table border=&quot;1&quot; align=&quot;right&quot;&gt;  &lt;tr&gt;    &lt;th&gt;Month&lt;/th&gt;    &lt;th&gt;Savings&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;January&lt;/td&gt;    &lt;td&gt;$100&lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;February&lt;/td&gt;    &lt;td&gt;$80&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;&lt;p&gt;align 属性可以使文本围绕在表格周围。&lt;/p&gt;&lt;p&gt;在 HTML 4.01 中，不赞成使用 body 元素的 align 属性；在 XHTML 1.0 Strict DTD 中，不支持 body 元素的 align 属性。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>bgcolor    ：rgb(x,x,x)、#xxxxxx、colorname<br>规定表格的背景颜色。<br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/69.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;table border=&quot;1&quot; bgcolor=&quot;#00FF00&quot;&gt;  &lt;tr&gt;    &lt;th&gt;Month&lt;/th&gt;    &lt;th&gt;Savings&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;January&lt;/td&gt;    &lt;td&gt;$100&lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;February&lt;/td&gt;    &lt;td&gt;$80&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;&lt;p&gt;在 HTML 4.01 中，不赞成使用 body 元素的 bgcolor 属性；在 XHTML 1.0 Strict DTD 中，不支持 body 元素的 bgcolor 属性。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>border    pixels    规定表格边框的宽度。<br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/70.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;table border=&quot;5&quot;&gt;  &lt;tr&gt;    &lt;th&gt;Month&lt;/th&gt;    &lt;th&gt;Savings&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;January&lt;/td&gt;    &lt;td&gt;$100&lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;February&lt;/td&gt;    &lt;td&gt;$80&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>cellpadding    ：pixels、%<br>规定单元边沿与其内容之间的空白。<br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/71.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;h4&gt;没有 cellpadding：&lt;/h4&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;  &lt;td&gt;First&lt;/td&gt;  &lt;td&gt;Row&lt;/td&gt;&lt;/tr&gt;   &lt;tr&gt;  &lt;td&gt;Second&lt;/td&gt;  &lt;td&gt;Row&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;h4&gt;带有 cellpadding：&lt;/h4&gt;&lt;table border=&quot;1&quot; cellpadding=&quot;10&quot;&gt;&lt;tr&gt;  &lt;td&gt;First&lt;/td&gt;  &lt;td&gt;Row&lt;/td&gt;&lt;/tr&gt;   &lt;tr&gt;  &lt;td&gt;Second&lt;/td&gt;  &lt;td&gt;Row&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>cellspacing    ：pixels、%<br>规定单元格之间、的空白。<br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/72.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;h4&gt;没有 cellspacing：&lt;/h4&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;  &lt;td&gt;First&lt;/td&gt;  &lt;td&gt;Row&lt;/td&gt;&lt;/tr&gt;   &lt;tr&gt;  &lt;td&gt;Second&lt;/td&gt;  &lt;td&gt;Row&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;h4&gt;带有 cellspacing：&lt;/h4&gt;&lt;table border=&quot;1&quot; cellspacing=&quot;10&quot;&gt;&lt;tr&gt;  &lt;td&gt;First&lt;/td&gt;  &lt;td&gt;Row&lt;/td&gt;&lt;/tr&gt;   &lt;tr&gt;  &lt;td&gt;Second&lt;/td&gt;  &lt;td&gt;Row&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>frame    ：void、above、below、hsides、lhs、rhs、vsides、box、border<br>规定外侧边框的哪个部分是可见的。<br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/73.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;frame 属性无法在 Internet Explorer 中正确地显示。&lt;/p&gt;&lt;p&gt;Table with frame=&quot;box&quot;:&lt;/p&gt;&lt;table frame=&quot;box&quot;&gt;  &lt;tr&gt;    &lt;th&gt;Month&lt;/th&gt;    &lt;th&gt;Savings&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;January&lt;/td&gt;    &lt;td&gt;$100&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;&lt;p&gt;Table with frame=&quot;above&quot;:&lt;/p&gt;&lt;table frame=&quot;above&quot;&gt;  &lt;tr&gt;    &lt;th&gt;Month&lt;/th&gt;    &lt;th&gt;Savings&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;January&lt;/td&gt;    &lt;td&gt;$100&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;&lt;p&gt;Table with frame=&quot;below&quot;:&lt;/p&gt;&lt;table frame=&quot;below&quot;&gt;  &lt;tr&gt;    &lt;th&gt;Month&lt;/th&gt;    &lt;th&gt;Savings&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;January&lt;/td&gt;    &lt;td&gt;$100&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;&lt;p&gt;Table with frame=&quot;hsides&quot;:&lt;/p&gt;&lt;table frame=&quot;hsides&quot;&gt;  &lt;tr&gt;    &lt;th&gt;Month&lt;/th&gt;    &lt;th&gt;Savings&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;January&lt;/td&gt;    &lt;td&gt;$100&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;&lt;p&gt;Table with frame=&quot;vsides&quot;:&lt;/p&gt;&lt;table frame=&quot;vsides&quot;&gt;  &lt;tr&gt;    &lt;th&gt;Month&lt;/th&gt;    &lt;th&gt;Savings&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;January&lt;/td&gt;    &lt;td&gt;$100&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>rules    ：none、groups、rows、cols、all<br>规定内侧边框的哪个部分是可见的。<br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/74.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;rules 属性无法在 Internet Explorer、Chrome 或者 Safari 中正确地显示。&lt;/p&gt;&lt;p&gt;Table with rules=&quot;rows&quot;:&lt;/p&gt;&lt;table rules=&quot;rows&quot;&gt;  &lt;tr&gt;    &lt;th&gt;Month&lt;/th&gt;    &lt;th&gt;Savings&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;January&lt;/td&gt;    &lt;td&gt;$100&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;&lt;p&gt;Table with rules=&quot;cols&quot;:&lt;/p&gt;&lt;table rules=&quot;cols&quot;&gt;  &lt;tr&gt;    &lt;th&gt;Month&lt;/th&gt;    &lt;th&gt;Savings&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;January&lt;/td&gt;    &lt;td&gt;$100&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;&lt;p&gt;Table with rules=&quot;all&quot;:&lt;/p&gt;&lt;table rules=&quot;all&quot;&gt;  &lt;tr&gt;    &lt;th&gt;Month&lt;/th&gt;    &lt;th&gt;Savings&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;January&lt;/td&gt;    &lt;td&gt;$100&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>summary    text    规定表格的摘要。<br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/75.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;table border=&quot;1&quot; summary=&quot;Monthly savings for the Flintstones family&quot;&gt;  &lt;tr&gt;    &lt;th&gt;Month&lt;/th&gt;    &lt;th&gt;Savings&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;January&lt;/td&gt;    &lt;td&gt;$100&lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;February&lt;/td&gt;    &lt;td&gt;$80&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>width    ：%、pixels  规定表格的宽度。<br><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/76.png" alt="enter descriptionhere"><br><strong>代码</strong>  </p><pre><code>&lt;html&gt;&lt;body&gt;&lt;table border=&quot;1&quot; width=&quot;400&quot;&gt;  &lt;tr&gt;    &lt;th&gt;Month&lt;/th&gt;    &lt;th&gt;Savings&lt;/th&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;January&lt;/td&gt;    &lt;td&gt;$100&lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td&gt;February&lt;/td&gt;    &lt;td&gt;$80&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat</title>
      <link href="/2018/09/26/2018-9-26-Tomcat/"/>
      <url>/2018/09/26/2018-9-26-Tomcat/</url>
      
        <content type="html"><![CDATA[<p>浏览器发出<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 给DNS服务器—-服务器根据浏览器所在地区返回该地区的代理接收浏览器接下来的请求—代理先看自己的缓存有没有对应的资源，没有才请求真正的服务器去数据库里找<br><img src="https://viabcde.github.io/images/2018-09-27/2018092721.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092722.png" alt="enter description here"></p><h3 id="测试某个端口如8080端口是否正在监听"><a href="#测试某个端口如8080端口是否正在监听" class="headerlink" title="测试某个端口如8080端口是否正在监听"></a><strong>测试某个端口如8080端口是否正在监听</strong></h3><p>Telnet localhost 8080 </p><h3 id="查询每个端口号对应的应用程序"><a href="#查询每个端口号对应的应用程序" class="headerlink" title="查询每个端口号对应的应用程序"></a><strong>查询每个端口号对应的应用程序</strong></h3><p>需要下载fport工具</p><h3 id="配置startup-bat"><a href="#配置startup-bat" class="headerlink" title="配置startup.bat"></a><strong>配置startup.bat</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-27/2018092723.png" alt="enter description here"><br>shutdown.bat也一样配置</p><h3 id="在bat文件中如果想要不显示命令-只显示结果"><a href="#在bat文件中如果想要不显示命令-只显示结果" class="headerlink" title="在bat文件中如果想要不显示命令 只显示结果"></a><strong>在bat文件中如果想要不显示命令 只显示结果</strong></h3><p>可以 在每个命令前加@<br>或者在文本最前面加echo off<br><img src="https://viabcde.github.io/images/2018-09-27/2018092724.png" alt="enter description here"></p><h3 id="http-localhost-8080"><a href="#http-localhost-8080" class="headerlink" title="http://localhost:8080/"></a><strong><a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></strong></h3><p>最后的/表示tomcat程序文件目录 中 文件夹ROOT</p><h3 id="配置web的虚拟目录-在server-xmi中"><a href="#配置web的虚拟目录-在server-xmi中" class="headerlink" title="配置web的虚拟目录  在server.xmi中"></a><strong>配置web的虚拟目录  在server.xmi中</strong></h3><p><strong>第一种：</strong><br> 即此时 / 优先指向 F:\javaweb\lession2<br>如果没有 再指向 tomcat程序文件目录 中 文件夹ROOT<br><img src="https://viabcde.github.io/images/2018-09-27/2018092725.png" alt="enter description here"><br>如果 path不为空 则需要在 / 后面加上 相应的 path 的内容 但是访问到的依然是F:\javaweb\lession2下的资源文件  </p><h3 id="打包成war文件"><a href="#打包成war文件" class="headerlink" title="打包成war文件"></a><strong>打包成war文件</strong></h3><p>jar –cvf 自定义名称.war 需要打包的文件路径  </p><h3 id="基于不同的主机名来区分不同站点"><a href="#基于不同的主机名来区分不同站点" class="headerlink" title="基于不同的主机名来区分不同站点"></a><strong>基于不同的主机名来区分不同站点</strong></h3><p>配置虚拟主机 在server.xml<br>如果在各个Host中找不到匹配的主机名 则选择默认的主机名为localhost<br><img src="https://viabcde.github.io/images/2018-09-27/2018092727.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092728.png" alt="enter description here"><br>在输入localhost 表示ip 127.0.0.1  也可以 自定义配置输入 skfla 表127.0.0.1<br>此时使用 skfla也可以访问主机<br><img src="https://viabcde.github.io/images/2018-09-27/2018092729.png" alt="enter description here"></p><h3 id="server-xml中修改端口号"><a href="#server-xml中修改端口号" class="headerlink" title="server.xml中修改端口号"></a><strong>server.xml中修改端口号</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-27/2018092730.png" alt="enter description here"></p><h3 id="基于不同的端口来区分不同站点"><a href="#基于不同的端口来区分不同站点" class="headerlink" title="基于不同的端口来区分不同站点"></a><strong>基于不同的端口来区分不同站点</strong></h3><p>也可以配置另外一个Service元素 改成不同的端口号 来区分不同 </p><h3 id="修改Tomcat端口号"><a href="#修改Tomcat端口号" class="headerlink" title="修改Tomcat端口号"></a><strong>修改Tomcat端口号</strong></h3><p>第一步<br>在tomcat的conf文件夹下找到server.xml文件，<br>第二步<br>打开文件后修改  </p><p>&lt;Connector port = “8080” protocol = “HTTP/1.1”<br>ConnectionTineout = “20000” redirectPort = “8443” /&gt;<br><em>备注</em>：如果修改为默认端口号80则localhost后面可不写端口号。  </p><h3 id="tomcat-有哪几种Connector-运行模式-优化-？"><a href="#tomcat-有哪几种Connector-运行模式-优化-？" class="headerlink" title="tomcat 有哪几种Connector 运行模式(优化)？"></a><strong>tomcat 有哪几种Connector 运行模式(优化)？</strong></h3><p>1.bio(blocking I/O)<br>2.nio(non-blocking I/O)<br>3.apr(Apache Portable Runtime/Apache可移植运行库)<br>相关解释:<br>•bio: 传统的Java I/O操作，同步且阻塞IO。<br>•nio: JDK1.4开始支持，同步阻塞或同步非阻塞IO<br>•aio(nio.2): JDK7开始支持，异步非阻塞IO<br>•apr: Tomcat将以JNI的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地 提高Tomcat对静态文件的处理性能<br>下面是配置Tomcat运行模式改成是NIO模式，并配置连接池相关参数来进行优化:</p><pre><code>    &lt;!--    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;               connectionTimeout=&quot;20000&quot;               redirectPort=&quot;8443&quot; /&gt;    --&gt;    &lt;!-- protocol 启用 nio模式，(tomcat8默认使用的是nio)(apr模式利用系统级异步io) --&gt;    &lt;!-- minProcessors最小空闲连接线程数--&gt;    &lt;!-- maxProcessors最大连接线程数--&gt;    &lt;!-- acceptCount允许的最大连接数，应大于等于maxProcessors--&gt;    &lt;!-- enableLookups 如果为true,requst.getRemoteHost会执行DNS查找，反向解析ip对应域名或主机名--&gt;    &lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;         connectionTimeout=&quot;20000&quot;        redirectPort=&quot;8443        maxThreads=“500”         minSpareThreads=“100”         maxSpareThreads=“200”        acceptCount=&quot;200&quot;        enableLookups=&quot;false&quot;           /&gt;</code></pre><h3 id="Tomcat有几种部署方式"><a href="#Tomcat有几种部署方式" class="headerlink" title="Tomcat有几种部署方式"></a><strong>Tomcat有几种部署方式</strong></h3><p>1.直接把Web项目放在webapps下，Tomcat会自动将其部署<br>2.在server.xml文件上配置<context>节点，设置相关的属性即可<br>3.通过Catalina来进行配置:进入到conf\Catalina\localhost文件下，创建一个xml文件，该文件的名字就是站点的名字。编写XML的方式来进行设置。<br>部署方式第二点：<br>•在其他盘符下创建一个web站点目录，并创建WEB-INF目录和一个html文件。    </context></p><p><img src="https://viabcde.github.io/images/2018-10-10/2018101003.png" alt="enter descriptionhere"><br>•找到Tomcat目录下/conf/server.xml文件<br><img src="https://viabcde.github.io/images/2018-10-10/2018101004.png" alt="enter descriptionhere"><br>•在server.xml中的  </p><pre><code>  &lt;Context path=&quot;/web1&quot; docBase=&quot;D:\web1&quot;/&gt;</code></pre><p><img src="https://viabcde.github.io/images/2018-10-10/2018101005.png" alt="enter descriptionhere"><br>•访问配置好的web站点<br><img src="https://viabcde.github.io/images/2018-10-10/2018101006.png" alt="enter descriptionhere"><br><strong>部署方式第三点：</strong><br>•进入到conf\Catalina\localhost文件下，创建一个xml文件，该文件的名字就是站点的名字。<br>•xml文件的代码如下，docBase是你web站点的绝对路径  </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;Context     docBase=&quot;D:\web1&quot;     reloadable=&quot;true&quot;&gt; &lt;/Context&gt; </code></pre><p>•访问web站点下的html资源  </p><h3 id="tomcat容器是如何创建servlet类实例？用到了什么原理"><a href="#tomcat容器是如何创建servlet类实例？用到了什么原理" class="headerlink" title="tomcat容器是如何创建servlet类实例？用到了什么原理"></a><strong>tomcat容器是如何创建servlet类实例？用到了什么原理</strong></h3><p>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对 xml文件进行解析，并读取servlet注册信息。然后，将每个应用中注册的servlet类都进行加载，并通过 反射的方式实例化。（有时候也是在第一次请求时实例化）<br>在servlet注册时加上<load-on-startup>1</load-on-startup>如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Div</title>
      <link href="/2018/09/26/2018-12-06-div/"/>
      <url>/2018/09/26/2018-12-06-div/</url>
      
        <content type="html"><![CDATA[<p><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/52.png" alt="enter descriptionhere"><br><strong>代码</strong></p><pre><code>&lt;html&gt;&lt;body&gt;&lt;h3&gt;This is a header&lt;/h3&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;div style=&quot;color:#00FF00&quot;&gt;  &lt;h3&gt;This is a header&lt;/h3&gt;  &lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="div的id和name的区别"><a href="#div的id和name的区别" class="headerlink" title="div的id和name的区别"></a><strong>div的id和name的区别</strong></h3><p>id是div的身份证号码，只有你一个人可以用，但是class别人也可以用<br>name和id不能等同，name除了标识之外，还具备其他功能<br>用途1: 作为可与服务器交互数据的HTML元素的服务器端的标示，比如input、select、textarea、和button等。我们可以在服务器端根据其Name通过Request.Params取得元素提交的值。<br>用途2: HTML元素Input type=’radio’分组，我们知道radio button控件在同一个分组类，check操作是mutex的，同一时间只能选中一个radio，这个分组就是根据相同的Name属性来实现的。<br>用途3: 建立页面中的锚点，我们知道<code>&lt;a href=&quot;URL&quot;&gt;link&lt;/a&gt;</code>是获得一个页面超级链接，如果不用href属性，而改用Name，如：<code>&lt;a name=&quot;PageBottom&quot;&gt;&lt;/a&gt;</code>，我们就获得了一个页面锚点。    </p><h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a><strong>常用标签</strong></h3><pre class=" language-stylus"><code class="language-stylus"><span class="token property-declaration"><span class="token property">color</span> <span class="token punctuation">:</span> <span class="token hexcode">#999999</span> 文字颜色</span><span class="token property-declaration"><span class="token property">font-family</span> <span class="token punctuation">:</span> 宋体 文字字型</span><span class="token property-declaration"><span class="token property">font-size</span> <span class="token punctuation">:</span> <span class="token number">10</span>pt 文字大小</span><span class="token property-declaration"><span class="token property">font-style</span><span class="token punctuation">:</span>itelic 文字斜体育</span><span class="token property-declaration"><span class="token property">font-variant</span><span class="token punctuation">:</span>small-caps 小字体</span><span class="token property-declaration"><span class="token property">letter-spacing</span> <span class="token punctuation">:</span> <span class="token number">1</span>pt 文字间距</span><span class="token property-declaration"><span class="token property">line-height</span> <span class="token punctuation">:</span> <span class="token number">200%</span> 设定行高</span><span class="token property-declaration"><span class="token property">font-weight</span><span class="token punctuation">:</span>bold 文字粗体</span><span class="token property-declaration"><span class="token property">vertical-align</span><span class="token punctuation">:</span>sub 下标字</span><span class="token property-declaration"><span class="token property">vertical-align</span><span class="token punctuation">:</span>super 上标字</span><span class="token property-declaration"><span class="token property">text-decoration</span><span class="token punctuation">:</span>line-through 加<span class="token operator">?</span>h除线</span><span class="token property-declaration"><span class="token property">text-decoration</span><span class="token punctuation">:</span>overline 加顶线</span><span class="token property-declaration"><span class="token property">text-decoration</span><span class="token punctuation">:</span>underline 加底线</span><span class="token property-declaration"><span class="token property">text-decoration</span><span class="token punctuation">:</span>none <span class="token operator">?</span>h除连接底线</span><span class="token property-declaration"><span class="token property">text-transform</span> <span class="token punctuation">:</span> capitalize 首字大写</span><span class="token property-declaration"><span class="token property">text-transform</span> <span class="token punctuation">:</span> uppercase 英文大写</span><span class="token property-declaration"><span class="token property">text-transform</span> <span class="token punctuation">:</span> lowercase 英文写</span><span class="token property-declaration"><span class="token property">text-align</span><span class="token punctuation">:</span>right 文字<span class="token operator">*</span>右对齐</span><span class="token property-declaration"><span class="token property">text-align</span><span class="token punctuation">:</span>left 文字<span class="token operator">*</span>左对齐</span><span class="token property-declaration"><span class="token property">text-align</span><span class="token punctuation">:</span>center 文字置中对齐</span>这些是一些简单的文字效果，可以应用到css的页面中。　</code></pre><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><pre class=" language-maxima"><code class="language-maxima">background-color:black 背景颜色background-image : url(image/bg.gif) 背景图片background-attachment : fixed 固定背景background-repeat : repeat 重复排列-网页预设background-repeat : no-repeat 不重复排列background-repeat : repeat-x 在x轴重复排列background-repeat : repeat-y 在y轴重复排列background-position : 90% 90% 背景图片x与y轴的位置 　</code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><strong>链接</strong></h2><pre class=" language-dns"><code class="language-dns">A 所有超连接A:link 超连接文字格式A:visited 浏览过的连接文字格式A:active 按下连接的格式A:hover 鼠标移至连接</code></pre><h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a><strong>边框</strong></h2><pre class=" language-mipsasm"><code class="language-mipsasm">border-top : 1px solid black 上框border-bottom : 1px solid #6699cc 下框border-left : 1px solid #6699cc 左框border-right : 1px solid #6699cc 右框border: 1px solid #6699cc 四边框</code></pre><h2 id="虚线"><a href="#虚线" class="headerlink" title="虚线"></a><strong>虚线</strong></h2><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TEXTAREA</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">STYLE</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">border</span><span class="token punctuation">:</span><span class="token number">1</span>px dashed pink</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><h2 id="实线"><a href="#实线" class="headerlink" title="实线"></a><strong>实线</strong></h2><pre class=" language-erlang"><code class="language-erlang"><span class="token operator">&lt;</span><span class="token variable">TEXTAREA</span> <span class="token variable">STYLE</span><span class="token operator">=</span><span class="token string">"border:1px solid pink"</span><span class="token operator">></span>设置<span class="token operator">div</span>的高度与文字的行高一样就可以了<span class="token punctuation">,</span>即 <span class="token atom">line</span><span class="token operator">-</span><span class="token atom">height</span> 和 <span class="token atom">height</span> 的数值是一样的就可以了<span class="token punctuation">,</span>最后给<span class="token operator">div</span>一个 <span class="token atom">over</span><span class="token operator">-</span><span class="token atom">flow</span><span class="token punctuation">:</span> <span class="token atom">hidden</span> <span class="token punctuation">,</span>让超出的部分隐藏<span class="token punctuation">.</span></code></pre><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a><strong>常用属性</strong></h2><pre class=" language-groovy"><code class="language-groovy"><span class="token number">1</span>、Height<span class="token punctuation">:</span>设置DIV的高度；Width<span class="token punctuation">:</span>设置DIV的宽度。<span class="token number">2</span>、margin<span class="token punctuation">:</span>用于设置DIV的外延边距，也就是到父容器的距离。margin<span class="token punctuation">:</span>后面跟有四个距离分别为到父容器的上<span class="token operator">-</span>右<span class="token operator">-</span>下<span class="token operator">-</span>左边的距离；margin<span class="token punctuation">:</span> <span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">[</span>bottom<span class="token punctuation">]</span><span class="token punctuation">[</span>left<span class="token punctuation">]</span>可以分别设置：margin<span class="token operator">-</span>left<span class="token punctuation">:</span>到父容器左边框的距离；margin<span class="token operator">-</span>right<span class="token punctuation">:</span>到父容器右边框的距离；margin<span class="token operator">-</span>top<span class="token punctuation">:</span> 到父容器上边框的距离；margin<span class="token operator">-</span>bottom<span class="token punctuation">:</span>到父容器下边框的距离。<span class="token number">3</span>、padding<span class="token punctuation">:</span>用于设置DIV的内边距（内如子元素与DIV边界的距离）。padding<span class="token punctuation">:</span>后面跟有四个距离分别为到父容器的上<span class="token operator">-</span>右<span class="token operator">-</span>下<span class="token operator">-</span>左边的距离；margin<span class="token punctuation">:</span> <span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">[</span>bottom<span class="token punctuation">]</span><span class="token punctuation">[</span>left<span class="token punctuation">]</span>：需要注意的是padding设置的距离不包括在本身的width和height内<span class="token punctuation">(</span>在IE7和FF中<span class="token punctuation">)</span>，比如一个DIV的width设置了100px<span class="token punctuation">,</span>而padding<span class="token operator">-</span>left设置了50px<span class="token punctuation">,</span>那么这个DIV在页面上显示的将是150px宽。<span class="token number">4</span>、border<span class="token punctuation">:</span>设置DIV的边框样式；display<span class="token punctuation">:</span>设置显示属性。其值有block、none；<span class="token keyword">float</span><span class="token punctuation">:</span>设置DIV在页面上的流向，其值有<span class="token function">left</span><span class="token punctuation">(</span>靠左显示<span class="token punctuation">)</span>、<span class="token function">right</span><span class="token punctuation">(</span>靠右显示<span class="token punctuation">)</span>、none；background<span class="token punctuation">:</span>设置DIV的背景样式；background后可直接跟背景的颜色、背景图片、平铺方式等样式。也可以用以下属性分别设置。background<span class="token operator">-</span>color<span class="token punctuation">:</span>设置背景颜色；background<span class="token operator">-</span>attachment<span class="token punctuation">:</span>背景图像的附加方式，其值有scroll、fixed<span class="token punctuation">;</span> background<span class="token operator">-</span>image<span class="token punctuation">:</span>指定使有的背景图片<span class="token punctuation">;</span>background<span class="token operator">-</span>repeat<span class="token punctuation">:</span>背景图象的平铺方式。其值有no<span class="token operator">-</span><span class="token function">repeat</span><span class="token punctuation">(</span>不平铺<span class="token punctuation">)</span>、<span class="token function">repeat</span><span class="token punctuation">(</span>两个方向平铺<span class="token punctuation">)</span>、repeat<span class="token operator">-</span><span class="token function">x</span><span class="token punctuation">(</span>水平方向平铺<span class="token punctuation">)</span>、repeat<span class="token operator">-</span><span class="token function">y</span><span class="token punctuation">(</span>垂直方向平铺<span class="token punctuation">)</span><span class="token punctuation">;</span> background<span class="token operator">-</span>position<span class="token punctuation">:</span>在DIV中定位背景位置。其值有top bottom left right的不同组合。也可以以用坐标指定具体的位置。<span class="token number">5</span>、position<span class="token punctuation">:</span>设置DIV的定位方式。position的属性中有<span class="token keyword">static</span>、fixed、relative、absolute四个属性。常用relative和absolute。若指定为<span class="token keyword">static</span>时，DIV遵循HTML规则；若指定为relative时，可以用top、left、right、bottom来设置DIV在页面中的偏移（相对于自身的偏移），但是此时不可使用层；若指定为absolute时，可以用top、left、right、bottom对DIV进行绝对定位（对自己最近的父级元素）；若指定为fixed时，在IE7与FF中DIV的位置相对于屏屏固定不变，IE6中没有效果（不知为什么）。<span class="token number">6</span>、font<span class="token punctuation">:</span>指定DIV中文本的样式，其后可跟文本的多个样式。font<span class="token operator">-</span>family<span class="token punctuation">:</span>设置要用的字体名称；font<span class="token operator">-</span>weight<span class="token punctuation">:</span>指定文本的粗细<span class="token punctuation">,</span>其值有bold bolder lighter等；font<span class="token operator">-</span>size<span class="token punctuation">:</span>指定文本的大小；font<span class="token operator">-</span>style<span class="token punctuation">:</span>指定文本样式，其值有italic normal oblique等；color<span class="token punctuation">:</span>指定文本颜色；text<span class="token operator">-</span>align<span class="token punctuation">:</span>指定文本水平对齐方式，其值有<span class="token function">center</span><span class="token punctuation">(</span>居中<span class="token punctuation">)</span> left right justify；text<span class="token operator">-</span>decorator<span class="token punctuation">:</span>用于文本的修饰；其值有none underline overline line<span class="token operator">-</span>through和blink的组合；text<span class="token operator">-</span>indent<span class="token punctuation">:</span>设置文本的缩进；text<span class="token operator">-</span>transform<span class="token punctuation">:</span>设置文本的字母大小写。其值有lowercase uppercase <span class="token function">capitalize</span><span class="token punctuation">(</span>首字母大写<span class="token punctuation">)</span> none；direction<span class="token punctuation">:</span>内容的流向。其值有<span class="token function">ltr</span><span class="token punctuation">(</span>从左至右<span class="token punctuation">)</span>、<span class="token function">rtl</span><span class="token punctuation">(</span>从右至左<span class="token punctuation">)</span>；line<span class="token operator">-</span>height<span class="token punctuation">:</span>指定文本的行高；Word<span class="token operator">-</span>spacing<span class="token punctuation">:</span>字间距。<span class="token number">7</span>、overflow<span class="token punctuation">:</span>内容溢出控制，其值有<span class="token function">scroll</span><span class="token punctuation">(</span>始终显示滚动条<span class="token punctuation">)</span>、<span class="token function">visible</span><span class="token punctuation">(</span>不显示滚动条，但超出部分可见<span class="token punctuation">)</span>、<span class="token function">auto</span><span class="token punctuation">(</span>内容超出时显示滚动条<span class="token punctuation">)</span>、<span class="token function">hidden</span><span class="token punctuation">(</span>超出时隐藏内容<span class="token punctuation">)</span>。</code></pre><h2 id="一些特殊效果："><a href="#一些特殊效果：" class="headerlink" title="一些特殊效果："></a><strong>一些特殊效果：</strong></h2><pre class=" language-scss"><code class="language-scss"><span class="token number">1</span>、<span class="token property">z-index</span><span class="token punctuation">:</span>设置DIV的层叠顺序。用z-index属性时，position必需要指定为absolute才行。<span class="token number">2</span>、<span class="token property">cursor</span><span class="token punctuation">:</span>设置DIV上光标的样式。<span class="token number">3</span>、<span class="token property">clip</span><span class="token punctuation">:</span>设置剪辑矩形。<span class="token property">clip</span><span class="token punctuation">:</span><span class="token function">rect</span><span class="token punctuation">(</span>top right bottom left<span class="token punctuation">)</span><span class="token punctuation">;</span>设置上下左右的距离,但此时要把position指定为absolute。<span class="token number">4</span>、opacity 透明度 <span class="token property">filter</span><span class="token punctuation">:</span><span class="token function">alpha</span><span class="token punctuation">(</span>opacity=value<span class="token punctuation">)</span> eg：<span class="token property">filter</span><span class="token punctuation">:</span><span class="token function">alpha</span><span class="token punctuation">(</span>opacity=<span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token property">opacity</span><span class="token punctuation">:</span><span class="token number">0.5</span><span class="token punctuation">;</span></code></pre><h2 id="定位和控制"><a href="#定位和控制" class="headerlink" title="定位和控制"></a><strong>定位和控制</strong></h2><p><strong>绝对定位和相对定位 （position）</strong>  </p><h2 id="绝对定位："><a href="#绝对定位：" class="headerlink" title="绝对定位："></a><strong>绝对定位：</strong></h2><pre class=" language-css"><code class="language-css"><span class="token selector">定位属性将是网虫们打开幸福之门的钥匙：H4 </span><span class="token punctuation">{</span> <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span> <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span> <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">43</span>px <span class="token punctuation">}</span>这项CSS规则让浏览器将&lt;H<span class="token number">4</span>>的起始位置精确地定在距离浏览器左边<span class="token number">100</span>象素，距离其顶部<span class="token number">43</span>象素的位置。注意这里唯一设置了的是左边和顶部，也就说，文字将从左到右，从上到下载入浏览窗口。左边和顶部属性很直观，左边（left）设定要素距浏览器窗口左边的距离，顶部（top）设定距离浏览器窗口顶部的距离。设定这些距离时，你可以使用所学过的各种度单位或比例值。使用比例值时，比例值的是相对于母体要素的尺寸。你可以定位什么呢？任何东西！段落、单词、GIF和JPEG图象、QUICKTIME电影等等。</code></pre><h2 id="相对定位："><a href="#相对定位：" class="headerlink" title="相对定位："></a><strong>相对定位：</strong></h2><pre class=" language-css"><code class="language-css"><span class="token selector">绝对定位使你能精确地定位要素在页面的独立位置，而不考虑页面其它要素的定位设置。相对定位指你所定位的要素的位置相对于在文件中所分配的位置。例：I </span><span class="token punctuation">{</span> <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span> <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">40</span>px<span class="token punctuation">;</span> <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">10</span>px <span class="token punctuation">}</span>相对定位的关键在于定位了的要素的位置是相对于它通常应在的位置进行定位。相对定位单元出现在普通的静态定位单元的行间，定位时没有把自己和静态定位单元完全分开。如果你停止使用相对定位，则文字的显示位置将恢复正常。使用相对定位时要小心，否则容易将页面弄得非常乱。除了相对定位和绝对定位，你还可以使用static（静止）参数值。Static 是 position 特性的缺省值。它的使用方法同普通HTML中的定位方法，不能附加特殊的定位设置。也就是说，除了边距特性，或通过使用 float 特性来浮动单元可影响单元的定位外，其它均不可以。</code></pre><h2 id="定位单元的控制-（width、height、visiblility）"><a href="#定位单元的控制-（width、height、visiblility）" class="headerlink" title="定位单元的控制 （width、height、visiblility）"></a><strong>定位单元的控制 （width、height、visiblility）</strong></h2><pre class=" language-scss"><code class="language-scss"><span class="token selector">除了控制定位单元的左上角位置，你还可以控制单元的宽度和高度，及单元在页面的可视性。宽度：定位了的要素在页面上显示时仍然会从左到右一直显示。利用宽度属性就可以设定字符向右流动的限制，即设定要素的宽度。DIV </span><span class="token punctuation">{</span> <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span> <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span> <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">40</span>px<span class="token punctuation">;</span> <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">150</span>px <span class="token punctuation">}</span><span class="token selector">浏览器接到这项规则时，它将文字按照规则规定的效果显示，还将段落的最大水平尺寸限制在150象素。宽度属性只适用于绝对定位的要素。你可以使用我们学过的任何一种长度单位，或使用比例值设定宽度，比例值指相对于母体要素的比例。IE 4中，这项属性还可用于图象。你可以通过宽度设置人为地拉宽或压缩图象。高度：理论上讲，高度应该和宽度的设置类似，只不过是在垂直方向上：DIV </span><span class="token punctuation">{</span> <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span> <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span> <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">40</span>px<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">150</span>px <span class="token punctuation">}</span><span class="token selector">这里我用了“理论上讲”，因为有些浏览器不支持高度属性。可视性：利用CSS，你可以隐藏要素，使其在页面上看不见。这条属性对于定位了的和未定位的要素都适用。H4 </span><span class="token punctuation">{</span> <span class="token property">visibility</span><span class="token punctuation">:</span> hidden <span class="token punctuation">}</span>选项：visible 使要素可以被看见hidden 使要素被隐藏inherit 指它将继承母体要素的可视性设置。值 inherit 为缺省值。这使单元继承父单元的可见性。所以，如果某一段是隐藏的，则它包含的任何行间单元也都被隐藏。这一继承性可被明确指定的可见性取代。例如，段内的 EM 单元被指定为可见，这时如果该段被隐藏，则段内的所有其它内容都将消失，而唯有 EM 单元中的文本是可见的。当一个要素被隐藏后，它仍然要占据浏览器窗口中的原有空间。所以，如果你将文字包围在一幅被隐藏的图象周围，那么，其显示效果将是文字包围着一块空白区域。此新闻这条属性在编写语言和使用动态HTML时很有用，比如你可以使某段落或图象只在鼠标滑过时才显示。单元层次 （z-index）特性 z-index 用于堆叠屏幕上的单元。缺省情况下，单元堆叠的顺序为它们出现在HTML标记的顺序——也就是说，后出现单元堆叠在早出现单元的上面。Z-index 特性实际上定义同属（sibling）单元的堆叠顺序以及单元相对父单元的堆叠。按照规范草案，具有正 z-index 值的单元群都堆叠在父单元之上，它们自己的堆叠顺序则按其取值的大小来决定（值大的单元在上层）。同样，具有负 z-index 值的单元群都堆叠在父单元之下，它们自己的堆叠顺序也按取值的大小来定（值大的单元在上层，例如值为 -<span class="token number">1</span> 的单元在值为 -<span class="token number">2</span> 的单元的上面）。该参数值使用纯整数。z-index用于绝对定位或相对定位了的要素。你也可以给图象设定z-index。（对于Communicator，最好将 &lt;IMG>标签包在&lt;SPAN>或 &lt;DIV>标签内，然后将z-index应用到&lt;SPAN>或 &lt;DIV>。）剪辑绝对定位单元 （clip）绝对定位单元可以被剪辑——也即剪辑显示给用户的区域，只显示单元的一部分而把其余部分作透明处理。对于传统的基于文本和图像的网络页面，这并不是一个很有用的特征。但若要求多媒体页面，这是很有用的。如 Netscape Communivator <span class="token number">4</span> 和 Internet Explorer <span class="token number">4</span> 都支持多媒体页面，它们通过文档的脚本接口动态地调整单元周围的剪辑区，从而实线文本“划入”和图像渐显等显示特征。在CSS中，剪辑通过 clip 特性来控制，这一特性只能用于绝对定位单元，其缺省值为 auto，按单元的外边缘来剪辑单元（实际上等于没有剪辑）。另外，可通过如下表达式设置剪辑框：<span class="token property">clip</span> <span class="token punctuation">:</span> <span class="token function">rect</span><span class="token punctuation">(</span>top,right<span class="token number">.</span>bottom,left<span class="token punctuation">)</span> <span class="token punctuation">;</span>其中 top、right、bottom 和 left 分别是矩形剪辑框的上边、右边、下边和左边相对于被剪辑单元左上角的位置。Top、right、bottom 和 left 的值可以为任意绝对或相对长度值（但不能为百分比值），或者是关键字 auto。取值为 auto 意味着剪辑区域的各边放好以后，被剪辑单元中的任何内容都不会超出这个区域。控制单元溢出 （overflow）固定绝对或相对定位单元的 width 和 height，很可能会因为指定的区域不能满足单元实际内容的需要，而造成单元内容溢出。这时可使用 overflow 来指定浏览器如何处理溢出：值 none（缺省值）允许浏览器显示溢出的内容，因此单元可溢出指定的区域。而值 clip 要求浏览器在单元底部和右边剪辑单元内容，这样，超出指定区域的单元内容将不显示。值 scroll 也同样要求浏览器在单元底部和右边剪辑单元内容（同 clip），不过，浏览器应该（如果可能的话）为单元提供滚动条以使用户能通过滚动来浏览被剪辑的内容</code></pre><h3 id="style"><a href="#style" class="headerlink" title="style"></a><strong>style</strong></h3><p><strong>效果</strong><br><img src="https://viabcde.github.io/images/201812/53.png" alt="enter descriptionhere"><br><strong>代码</strong></p><pre><code>&lt;div style=&quot;width:200px;height:200px;background-color:Black;&quot;&gt; &lt;/div&gt; </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webservice</title>
      <link href="/2018/09/23/2018-9-23-WebService/"/>
      <url>/2018/09/23/2018-9-23-WebService/</url>
      
        <content type="html"><![CDATA[<h3 id="基于jax的WebService"><a href="#基于jax的WebService" class="headerlink" title="基于jax的WebService"></a><strong>基于jax的WebService</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-23/2018092301.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/2018-09-23/2018092302.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/2018-09-23/2018092303.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/2018-09-23/2018092304.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/2018-09-23/2018092305.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/2018-09-23/2018092306.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/2018-09-23/2018092307.png" alt="enter descriptionhere"><br><strong>然后一路点确定</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.test&lt;/groupId&gt;  &lt;artifactId&gt;01_jaxes_server&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;name&gt;01_jaxws_server&lt;/name&gt;    &lt;dependencies&gt;      &lt;!--进行jaxws服务开发--&gt;      &lt;dependency&gt;        &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;        &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt;        &lt;version&gt;3.0.1&lt;/version&gt;      &lt;/dependency&gt;      &lt;!--内置jetty web服务器--&gt;      &lt;dependency&gt;        &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;        &lt;artifactId&gt;cxf-rt-transports-http-jetty&lt;/artifactId&gt;        &lt;version&gt;3.0.1&lt;/version&gt;      &lt;/dependency&gt;      &lt;!--日志实现--&gt;      &lt;dependency&gt;        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;        &lt;version&gt;1.7.12&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.10&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;      &lt;/dependency&gt;    &lt;/dependencies&gt;  &lt;build&gt;    &lt;pluginManagement&gt;      &lt;plugins&gt;        &lt;plugin&gt;          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;          &lt;version&gt;3.2&lt;/version&gt;          &lt;configuration&gt;            &lt;source&gt;1.8&lt;/source&gt;            &lt;target&gt;1.8&lt;/target&gt;            &lt;encoding&gt;UTF-8&lt;/encoding&gt;            &lt;showWarnings&gt;true&lt;/showWarnings&gt;          &lt;/configuration&gt;        &lt;/plugin&gt;      &lt;/plugins&gt;    &lt;/pluginManagement&gt;  &lt;/build&gt;&lt;/project&gt;</code></pre><p><strong>删除com.test下自动生成的文件</strong><br><strong>然后在com.test下新建service包</strong><br><img src="https://viabcde.github.io/images/2018-09-23/2018092308.png" alt="enter descriptionhere"><br><strong>再新建一个接口HelloService.java</strong><br><img src="https://viabcde.github.io/images/2018-09-23/2018092309.png" alt="enter descriptionhere"> </p><pre><code>package com.test.service;/** * 对外发布服务的接口 */import javax.jws.WebService;@WebServicepublic interface HelloService {    /**     * 对外发布服务的接口的方法     */    public String sayHello(String name);}</code></pre><p><strong>创建接口的实现类</strong></p><p><img src="https://viabcde.github.io/images/2018-09-23/2018092310.png" alt="enter descriptionhere">  </p><pre><code>package com.test.service.impl;import com.test.service.HelloService;public class HelloServiceImpl implements HelloService{    public String sayHello(String name) {        return name + &quot;,welcome!&quot;;    }}</code></pre><p><strong>发布服务</strong><br><img src="https://viabcde.github.io/images/2018-09-23/2018092311.png" alt="enter descriptionhere"><br>psvm：快捷敲出main方法<br>sout: 快捷敲出system.out.println</p><pre><code>package com.test;import com.test.service.impl.HelloServiceImpl;import org.apache.cxf.jaxws.JaxWsServerFactoryBean;public class Server {    public static void main(String[] args) {        //发布服务的工厂        JaxWsServerFactoryBean factory = new JaxWsServerFactoryBean();        //设置服务地址        factory.setAddress(&quot;http://localhost:8000/ws/hello&quot;);        //设置服务类        factory.setServiceBean(new HelloServiceImpl());        //发布服务        factory.create();        System.out.println(&quot;发布服务成功，端口8000....&quot;);    }}</code></pre><p><strong>运行</strong><br><img src="https://viabcde.github.io/images/2018-09-23/2018092312.png" alt="enter descriptionhere"><br><strong>测试</strong><br><img src="https://viabcde.github.io/images/2018-09-23/2018092313.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/2018-09-23/2018092314.png" alt="enter descriptionhere"><br><strong>客户端</strong><br>新建一个moudle<br><img src="https://viabcde.github.io/images/2018-09-23/2018092315.png" alt="enter descriptionhere"><br>绑定本地仓库<br><img src="https://viabcde.github.io/images/2018-09-23/2018092316.png" alt="enter descriptionhere"><br>把服务端的pom.xml文件的依赖复制到客户端的pom.xml中</p><p><strong>再把服务端的接口复制到客户端HelloService</strong></p><p><img src="https://viabcde.github.io/images/2018-09-23/2018092317.png" alt="enter descriptionhere"><br><strong>客户端测试</strong></p><pre><code>package com.test;import com.test.service.HelloService;import org.apache.cxf.jaxws.JaxWsProxyFactoryBean;public class Client {    public static void main(String[] args) {        //服务接口访问地址：http://localhost:8000/ws/hello        //创建cxf代理工厂        JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();        //设置远程访问服务端的地址        factory.setAddress(&quot;http://localhost:8000/ws/hello&quot;);        //设置接口类型        factory.setServiceClass(HelloService.class);        //对接口生成代理对象        HelloService helloService = factory.create(HelloService.class);        //代理对象类型 class com.sun.proxy.$Proxy34        System.out.println(helloService.getClass());        //远程访问服务端方法        String Content = helloService.sayHello(&quot;jet&quot;);        System.out.println(Content);    }}</code></pre><p><img src="https://viabcde.github.io/images/2018-09-23/2018092318.png" alt="enter descriptionhere"><br>alt+enter 自动导包<br><strong>配置日志拦截器</strong><br><img src="https://viabcde.github.io/images/2018-09-23/2018092320.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/2018-09-23/2018092319.png" alt="enter descriptionhere"><br>在服务端添加拦截器<br><img src="https://viabcde.github.io/images/2018-09-23/2018092321.png" alt="enter descriptionhere"> </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>服务端编写接口及其实现类，再通过工厂设置好服务地址及服务类并发布服务<br>客户端编写接口，再通过代理工厂设置要访问的服务端地址及服务接口，由工厂生成可直接使用的代理对象</p><h3 id="WebService整合Spring"><a href="#WebService整合Spring" class="headerlink" title="WebService整合Spring"></a><strong>WebService整合Spring</strong></h3><p><strong>新建module</strong><br><img src="https://viabcde.github.io/images/2018-09-23/2018092322.png" alt="enter descriptionhere"><br>ctrl + n 搜索类文件<br><strong>配置pom.xml文件</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.test&lt;/groupId&gt;  &lt;artifactId&gt;03_jaxws_spring_server&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;name&gt;03_jaxws_spring_server Maven Webapp&lt;/name&gt; &lt;dependencies&gt;   &lt;!--进行jaxws服务开发--&gt;   &lt;dependency&gt;     &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;     &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt;     &lt;version&gt;3.0.1&lt;/version&gt;   &lt;/dependency&gt;   &lt;dependency&gt;     &lt;groupId&gt;junit&lt;/groupId&gt;     &lt;artifactId&gt;junit&lt;/artifactId&gt;     &lt;version&gt;4.10&lt;/version&gt;     &lt;scope&gt;test&lt;/scope&gt;   &lt;/dependency&gt;   &lt;dependency&gt;     &lt;groupId&gt;org.springframework&lt;/groupId&gt;     &lt;artifactId&gt;spring-context&lt;/artifactId&gt;     &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;   &lt;/dependency&gt;   &lt;dependency&gt;     &lt;groupId&gt;org.springframework&lt;/groupId&gt;     &lt;artifactId&gt;spring-web&lt;/artifactId&gt;     &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;   &lt;/dependency&gt;   &lt;dependency&gt;     &lt;groupId&gt;org.springframework&lt;/groupId&gt;     &lt;artifactId&gt;spring-test&lt;/artifactId&gt;     &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;   &lt;/dependency&gt; &lt;/dependencies&gt;  &lt;build&gt;    &lt;plugins&gt;      &lt;plugin&gt;        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;        &lt;version&gt;3.2&lt;/version&gt;        &lt;configuration&gt;          &lt;source&gt;1.8 &lt;/source&gt;          &lt;target&gt;1.8&lt;/target&gt;          &lt;encoding&gt;utf-8&lt;/encoding&gt;          &lt;showWarnings&gt;true&lt;/showWarnings&gt;        &lt;/configuration&gt;      &lt;/plugin&gt;      &lt;!--运行tomcat7的方法：tomcat7:run--&gt;      &lt;plugin&gt;        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;        &lt;version&gt;2.2&lt;/version&gt;        &lt;configuration&gt;          &lt;!--指定端口--&gt;          &lt;port&gt;8080&lt;/port&gt;          &lt;!--请求路径--&gt;          &lt;path&gt;/&lt;/path&gt;        &lt;/configuration&gt;      &lt;/plugin&gt;    &lt;/plugins&gt;  &lt;/build&gt;&lt;/project&gt;</code></pre><p><strong>配置web.xml</strong></p><pre><code>&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;    &lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;!--cxfservlet配置--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;cxfservlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;cxfservlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/ws/*&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;  &lt;!--Spring容器的配置--&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;&lt;/web-app&gt;</code></pre><p><strong>还是之前的接口和实现类</strong><br><img src="https://viabcde.github.io/images/2018-09-23/2018092323.png" alt="enter descriptionhere"><br><strong>配置applicationContext.xml</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:cxf=&quot;http://cxf.apache.org/core&quot;       xmlns:jaxws=&quot;http://cxf.apache.org/jaxws&quot;       xmlns:jaxrs=&quot;http://cxf.apache.org/jaxrs&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://cxf.apache.org/core        http://cxf.apache.org/schemas/core.xsd        http://cxf.apache.org/jaxws        http://cxf.apache.org/schemas/jaxws.xsd        http://cxf.apache.org/jaxrs        http://cxf.apache.org/schemas/jaxrs.xsd&quot;&gt;    &lt;!--Spring整合cxf发布服务：关键点：        1.服务地址        2.服务类        服务的完整访问地址：http://localhost:8080/ws/hello        --&gt;    &lt;jaxws:server address=&quot;/hello&quot;&gt;        &lt;jaxws:serviceBean&gt;            &lt;bean class=&quot;com.test.service.impl.HelloServiceImpl&quot;&gt;&lt;/bean&gt;        &lt;/jaxws:serviceBean&gt;    &lt;/jaxws:server&gt;&lt;/beans&gt;</code></pre><p>在地址栏输入：<a href="http://localhost:8080/ws/hello?wsdl" target="_blank" rel="noopener">http://localhost:8080/ws/hello?wsdl</a> 测试<br>注意问号是英文的问号</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><strong>服务端</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-23/2018092324.png" alt="enter descriptionhere"><br><strong>接口还是用原来的代码不变</strong><br><strong>applicationContext.xml</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:cxf=&quot;http://cxf.apache.org/core&quot;       xmlns:jaxws=&quot;http://cxf.apache.org/jaxws&quot;       xmlns:jaxrs=&quot;http://cxf.apache.org/jaxrs&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://cxf.apache.org/core        http://cxf.apache.org/schemas/core.xsd        http://cxf.apache.org/jaxws        http://cxf.apache.org/schemas/jaxws.xsd        http://cxf.apache.org/jaxrs        http://cxf.apache.org/schemas/jaxrs.xsd&quot;&gt;    &lt;!--Spring整合cxf客户端配置：        1.服务地址 http://localhost:8080/ws/hello        2.服务的接口类型        --&gt;    &lt;jaxws:client            id=&quot;helloService&quot;            serviceClass=&quot;com.test.service.HelloService&quot;            address=&quot;http://localhost:8080/ws/hello&quot;&gt;    &lt;/jaxws:client&gt;&lt;/beans&gt;</code></pre><p><strong>测试</strong></p><pre><code>package com.test;import com.test.service.HelloService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class Client {    //注入对象    @Resource    private HelloService helloService;    /*public void setHelloService(HelloService helloService) {        this.helloService = helloService;    }*/    @Test    public void remote(){        //查看接口的代理对象类型        System.out.println(helloService.getClass());        //远程访问服务端方法        System.out.println(helloService.sayHello(&quot;jerry&quot;));    }}</code></pre><h3 id="restful风格的webservice"><a href="#restful风格的webservice" class="headerlink" title="restful风格的webservice"></a><strong>restful风格的webservice</strong></h3><p>同一个URL地址可以通过指定不同的请求方式(eg. post,get,delete,put…)来对应<br>Control中的不同的方法<br>get    对应  查询操作<br>post   对应  新建操作<br>put    对应  更新操作<br>delete 对应  删除操作<br><img src="https://viabcde.github.io/images/2018-09-23/2018092325.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/2018-09-23/2018092326.png" alt="enter descriptionhere"><br><strong>配置pom.xml依赖包</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.test&lt;/groupId&gt;  &lt;artifactId&gt;05_jaxrs_server&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;name&gt;05_jaxrs_server&lt;/name&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;      &lt;artifactId&gt;cxf-rt-frontend-jaxrs&lt;/artifactId&gt;      &lt;version&gt;3.0.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;      &lt;artifactId&gt;cxf-rt-transports-http-jetty&lt;/artifactId&gt;      &lt;version&gt;3.0.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;      &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;      &lt;version&gt;1.7.12&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;      &lt;artifactId&gt;cxf-rt-rs-client&lt;/artifactId&gt;      &lt;version&gt;3.0.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;      &lt;artifactId&gt;cxf-rt-rs-extension-providers&lt;/artifactId&gt;      &lt;version&gt;3.0.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.codehaus.jettison&lt;/groupId&gt;      &lt;artifactId&gt;jettison&lt;/artifactId&gt;      &lt;version&gt;1.3.7&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.10&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;build&gt;    &lt;plugins&gt;      &lt;plugin&gt;        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;        &lt;version&gt;3.2&lt;/version&gt;        &lt;configuration&gt;          &lt;source&gt;1.8 &lt;/source&gt;          &lt;target&gt;1.8&lt;/target&gt;          &lt;encoding&gt;utf-8&lt;/encoding&gt;          &lt;showWarnings&gt;true&lt;/showWarnings&gt;        &lt;/configuration&gt;      &lt;/plugin&gt;    &lt;/plugins&gt;  &lt;/build&gt;&lt;/project&gt;</code></pre><p><strong>实体类</strong></p><pre><code>package com.test.entity;import javax.xml.bind.annotation.XmlRootElement;@XmlRootElement(name=&quot;Car&quot;)public class Car {    private Integer id;    private String carName;    private Double price;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getCarName() {        return carName;    }    public void setCarName(String carName) {        this.carName = carName;    }    public Double getPrice() {        return price;    }    public void setPrice(Double price) {        this.price = price;    }    @Override    public String toString() {        return &quot;Car{&quot; +                &quot;id=&quot; + id +                &quot;, carName=&#39;&quot; + carName + &#39;\&#39;&#39; +                &quot;, price=&quot; + price +                &#39;}&#39;;    }}</code></pre><pre><code>package com.test.entity;import javax.xml.bind.annotation.XmlRootElement;import java.util.ArrayList;import java.util.List;@XmlRootElement(name=&quot;User&quot;)public class User {    private Integer id;    private String name;    private String city;    private List&lt;Car&gt; cars = new ArrayList&lt;Car&gt;();    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getCity() {        return city;    }    public void setCity(String city) {        this.city = city;    }    public List&lt;Car&gt; getCars() {        return cars;    }    public void setCars(List&lt;Car&gt; cars) {        this.cars = cars;    }    @Override    public String toString() {        return &quot;User{&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, city=&#39;&quot; + city + &#39;\&#39;&#39; +                &quot;, cars=&quot; + cars +                &#39;}&#39;;    }}</code></pre><p><strong>接口及实现类</strong></p><pre><code>package com.test.service;import com.test.entity.User;import javax.ws.rs.*;import java.util.List;/** * path访问本服务的路径、produces /* 表示支持任意处理请求完毕后返回给客户端的类型 */@Path(&quot;/userService&quot;)@Produces(&quot;/*&quot;)public interface IUserService {    /**     *path 连上本服务后 访问服务的方法的路径     * Consumes 表示支持的请求格式     */    @POST    @Path(&quot;/user&quot;)    @Consumes({&quot;application/xml&quot;,&quot;application/json&quot;})    public void saveUser(User user);    @PUT    @Path(&quot;/user&quot;)    @Consumes({&quot;application/xml&quot;,&quot;application/json&quot;})    public void updateUser(User user);    @GET    @Path(&quot;/user&quot;)    @Produces({&quot;application/xml&quot;,&quot;application/json&quot;})    public List&lt;User&gt; findAllUser();    @GET    @Path(&quot;/user&quot;)    @Consumes({&quot;application/xml&quot;})    @Produces({&quot;application/xml&quot;,&quot;application/json&quot;})    public User findUserById(@PathParam(&quot;id&quot;)Integer id);    @DELETE    @Path(&quot;/user&quot;)    @Consumes({&quot;application/xml&quot;,&quot;application/json&quot;})    public void deleteUser(@PathParam(&quot;id&quot;) Integer id);}</code></pre><pre><code>package com.test.service;import com.test.entity.Car;import com.test.entity.User;import java.util.ArrayList;import java.util.List;public class UserServiceImpl implements IUserService{    public void saveUser(User user) {        System.out.println(&quot;save user&quot;+user);    }    public void updateUser(User user) {        System.out.println(&quot;update user&quot;+user);    }    public List&lt;User&gt; findAllUser() {        List&lt;User&gt; users = new ArrayList&lt;User&gt;();        User user1 = new User();        user1.setId(1);        user1.setName(&quot;小明&quot;);        user1.setCity(&quot;北京&quot;);        List&lt;Car&gt; carList1 = new ArrayList&lt;Car&gt;();        Car car1 = new Car();        car1.setId(101);        car1.setCarName(&quot;保时捷1&quot;);        car1.setPrice(10000000d);        carList1.add(car1);        Car car2 = new Car();        car2.setId(102);        car2.setCarName(&quot;保时捷2&quot;);        car2.setPrice(10000000d);        carList1.add(car2);        user1.setCars(carList1);        users.add(user1);        User user2 = new User();        user2.setId(2);        user2.setName(&quot;小小&quot;);        user2.setCity(&quot;北京&quot;);        users.add(user2);        return users;    }    public User findUserById(Integer id) {        if(id==1){            User user1 = new User();            user1.setId(1);            user1.setName(&quot;小明&quot;);            user1.setCity(&quot;北京&quot;);            return user1;        }        return null;    }    public void deleteUser(Integer id) {        System.out.println(&quot;delete user id:&quot;+id);    }}</code></pre><p><strong>测试启动服务</strong></p><pre><code>package com.test;import com.test.service.UserServiceImpl;import org.apache.cxf.interceptor.LoggingInInterceptor;import org.apache.cxf.interceptor.LoggingOutInterceptor;import org.apache.cxf.jaxrs.JAXRSServerFactoryBean;public class Server {    public static void main(String[] args) {        //创建发布服务的工厂        JAXRSServerFactoryBean factory = new JAXRSServerFactoryBean();        //设置服务地址        factory.setAddress(&quot;http://localhost:8001/ws&quot;);        //设置服务类        factory.setServiceBean(new UserServiceImpl());        //添加日志输入输出拦截器        factory.getInInterceptors().add(new LoggingInInterceptor());        factory.getOutInterceptors().add(new LoggingOutInterceptor());        //发布服务        factory.create();        System.out.println(&quot;发布服务成功，端口8001&quot;);    }}</code></pre><p><strong>客户端</strong><br><strong>配置依赖</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.test&lt;/groupId&gt;    &lt;artifactId&gt;06_jaxrs_client&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;name&gt;06_jaxrs_client&lt;/name&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;            &lt;artifactId&gt;cxf-rt-frontend-jaxrs&lt;/artifactId&gt;            &lt;version&gt;3.0.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;            &lt;artifactId&gt;cxf-rt-transports-http-jetty&lt;/artifactId&gt;            &lt;version&gt;3.0.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;            &lt;version&gt;1.7.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;            &lt;artifactId&gt;cxf-rt-rs-client&lt;/artifactId&gt;            &lt;version&gt;3.0.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;            &lt;artifactId&gt;cxf-rt-rs-extension-providers&lt;/artifactId&gt;            &lt;version&gt;3.0.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.codehaus.jettison&lt;/groupId&gt;            &lt;artifactId&gt;jettison&lt;/artifactId&gt;            &lt;version&gt;1.3.7&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.10&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                    &lt;encoding&gt;utf-8&lt;/encoding&gt;                    &lt;showWarnings&gt;true&lt;/showWarnings&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p><strong>实体类</strong></p><pre><code>package com.test.entity;import javax.xml.bind.annotation.XmlRootElement;@XmlRootElement(name=&quot;Car&quot;)public class Car {    private Integer id;    private String carName;    private Double price;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getCarName() {        return carName;    }    public void setCarName(String carName) {        this.carName = carName;    }    public Double getPrice() {        return price;    }    public void setPrice(Double price) {        this.price = price;    }    @Override    public String toString() {        return &quot;Car{&quot; +                &quot;id=&quot; + id +                &quot;, carName=&#39;&quot; + carName + &#39;\&#39;&#39; +                &quot;, price=&quot; + price +                &#39;}&#39;;    }}</code></pre><p>==</p><pre><code>package com.test.entity;import javax.xml.bind.annotation.XmlRootElement;import java.util.ArrayList;import java.util.List;@XmlRootElement(name=&quot;User&quot;)public class User {    private Integer id;    private String name;    private String city;    private List&lt;Car&gt; cars = new ArrayList&lt;Car&gt;();    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getCity() {        return city;    }    public void setCity(String city) {        this.city = city;    }    public List&lt;Car&gt; getCars() {        return cars;    }    public void setCars(List&lt;Car&gt; cars) {        this.cars = cars;    }    @Override    public String toString() {        return &quot;User{&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, city=&#39;&quot; + city + &#39;\&#39;&#39; +                &quot;, cars=&quot; + cars +                &#39;}&#39;;    }}</code></pre><p><strong>客户端测试</strong></p><pre><code>package com.test;import com.test.entity.User;import org.apache.cxf.jaxrs.client.WebClient;import org.junit.Test;public class Client {    @Test    public void testSave(){        //通过WebClient对象远程调用服务端        WebClient.create(&quot;http://localhost:8001/ws/userService/user&quot;).post(new User());    }}</code></pre><h3 id="resful风格的webservice整合Spring"><a href="#resful风格的webservice整合Spring" class="headerlink" title="resful风格的webservice整合Spring"></a><strong>resful风格的webservice整合Spring</strong></h3><p><strong>配置依赖</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.test&lt;/groupId&gt;  &lt;artifactId&gt;07_jaxrs_spring_server&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;name&gt;07_jaxrs_spring_server&lt;/name&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;      &lt;artifactId&gt;cxf-rt-frontend-jaxrs&lt;/artifactId&gt;      &lt;version&gt;3.0.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;      &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;      &lt;version&gt;1.7.12&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;      &lt;artifactId&gt;cxf-rt-rs-client&lt;/artifactId&gt;      &lt;version&gt;3.0.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;      &lt;artifactId&gt;cxf-rt-rs-extension-providers&lt;/artifactId&gt;      &lt;version&gt;3.0.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.codehaus.jettison&lt;/groupId&gt;      &lt;artifactId&gt;jettison&lt;/artifactId&gt;      &lt;version&gt;1.3.7&lt;/version&gt;    &lt;/dependency&gt;&lt;!--    &lt;dependency&gt;      &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;      &lt;artifactId&gt;cxf-rt-transports-http-jetty&lt;/artifactId&gt;      &lt;version&gt;3.0.1&lt;/version&gt;    &lt;/dependency&gt;--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;      &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;      &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.12&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;build&gt;    &lt;plugins&gt;      &lt;plugin&gt;        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;        &lt;version&gt;3.2&lt;/version&gt;        &lt;configuration&gt;          &lt;source&gt;1.8&lt;/source&gt;          &lt;target&gt;1.8&lt;/target&gt;          &lt;encoding&gt;utf-8&lt;/encoding&gt;          &lt;showWarnings&gt;true&lt;/showWarnings&gt;        &lt;/configuration&gt;      &lt;/plugin&gt;      &lt;!--运行tomcat7的方法：tomcat7:run--&gt;      &lt;plugin&gt;        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;        &lt;version&gt;2.2&lt;/version&gt;        &lt;configuration&gt;          &lt;!--指定端口--&gt;          &lt;port&gt;8080&lt;/port&gt;          &lt;!--请求路径--&gt;          &lt;path&gt;/&lt;/path&gt;        &lt;/configuration&gt;      &lt;/plugin&gt;    &lt;/plugins&gt;  &lt;/build&gt;&lt;/project&gt;</code></pre><p><strong>实体类和服务类和未整合的一样</strong><br><strong>applicationContext.xml</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:cxf=&quot;http://cxf.apache.org/core&quot;       xmlns:jaxws=&quot;http://cxf.apache.org/jaxws&quot;       xmlns:jaxrs=&quot;http://cxf.apache.org/jaxrs&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://cxf.apache.org/core        http://cxf.apache.org/schemas/core.xsd        http://cxf.apache.org/jaxws        http://cxf.apache.org/schemas/jaxws.xsd        http://cxf.apache.org/jaxrs        http://cxf.apache.org/schemas/jaxrs.xsd&quot;&gt;    &lt;!--Spring整合cxf发布基于restful风格的服务：关键点：        1.服务地址        2.服务类        服务的完整访问地址：http://localhost:8080/ws/hello        --&gt;    &lt;jaxrs:server address=&quot;/userService&quot;&gt;        &lt;jaxrs:serviceBeans&gt;            &lt;bean class=&quot;com.test.service.UserServiceImpl&quot;&gt;&lt;/bean&gt;        &lt;/jaxrs:serviceBeans&gt;    &lt;/jaxrs:server&gt;&lt;/beans&gt;</code></pre><p><strong>客户端</strong><br><strong>依赖</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.test&lt;/groupId&gt;  &lt;artifactId&gt;08_jaxrs_spring_client&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;name&gt;08_jaxrs_spring_client&lt;/name&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;      &lt;artifactId&gt;cxf-rt-frontend-jaxrs&lt;/artifactId&gt;      &lt;version&gt;3.0.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;      &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;      &lt;version&gt;1.7.12&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;      &lt;artifactId&gt;cxf-rt-rs-client&lt;/artifactId&gt;      &lt;version&gt;3.0.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;      &lt;artifactId&gt;cxf-rt-rs-extension-providers&lt;/artifactId&gt;      &lt;version&gt;3.0.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.codehaus.jettison&lt;/groupId&gt;      &lt;artifactId&gt;jettison&lt;/artifactId&gt;      &lt;version&gt;1.3.7&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--    &lt;dependency&gt;          &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;          &lt;artifactId&gt;cxf-rt-transports-http-jetty&lt;/artifactId&gt;          &lt;version&gt;3.0.1&lt;/version&gt;        &lt;/dependency&gt;--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;      &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;      &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.12&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;build&gt;    &lt;plugins&gt;      &lt;plugin&gt;        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;        &lt;version&gt;3.2&lt;/version&gt;        &lt;configuration&gt;          &lt;source&gt;1.8&lt;/source&gt;          &lt;target&gt;1.8&lt;/target&gt;          &lt;encoding&gt;utf-8&lt;/encoding&gt;          &lt;showWarnings&gt;true&lt;/showWarnings&gt;        &lt;/configuration&gt;      &lt;/plugin&gt;      &lt;!--运行tomcat7的方法：tomcat7:run--&gt;      &lt;plugin&gt;        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;        &lt;version&gt;2.2&lt;/version&gt;        &lt;configuration&gt;          &lt;!--指定端口--&gt;          &lt;port&gt;8080&lt;/port&gt;          &lt;!--请求路径--&gt;          &lt;path&gt;/&lt;/path&gt;        &lt;/configuration&gt;      &lt;/plugin&gt;    &lt;/plugins&gt;  &lt;/build&gt;&lt;/project&gt;</code></pre><p><strong>客户端测试</strong></p><pre><code>package com.test;import com.test.entity.User;import org.apache.cxf.jaxrs.client.WebClient;import org.junit.Test;public class Client {    @Test    public void testSave(){        //通过WebClient对象远程调用服务端        //第一个/userService是在spring的配置文件中配置的        //第二个/userService是在impl类中定义的        WebClient.create(&quot;http://localhost:8080/ws/userService/userService/user&quot;).post(new User());    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> webservice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP_链路层</title>
      <link href="/2018/09/22/2018-9-22-TCPIP_2%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2018/09/22/2018-9-22-TCPIP_2%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>TCP/IP支持不同的链路层协议（取决于使用的硬件），如：<br>以太网、令牌网、FDDI等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win的dos命令</title>
      <link href="/2018/09/22/2018-9-22-dos%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/09/22/2018-9-22-dos%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a><strong>ping</strong></h2><p><strong>原理：</strong>网络上的机器的唯一IP，给目标IP地址发送数据包，对方就要返回一个同样大小的数据包，根据返回的数据包我们可以确定目标主机的存在，可以初步判断目标主机的操作系统等<br>从<strong>TTL的返回值</strong>可以初步判断被ping主机的操作系统，之所以说“初步判断”是因为这个值是可以修改的。这里TTL=32表示操作系统可能是win98(小知识:如果TTL=128，则表示目标主机可能是Win2000;如果TTL=250，则目标主机可能是Unix)  </p><h3 id="t"><a href="#t" class="headerlink" title="-t"></a><strong>-t</strong></h3><p>表示不间断向目标IP发送数据包，直到我们强迫其停止。<br>试想，使用100M的宽带接入，而目标IP是56K的小猫，要不了多久，目标IP就因承受不了这么多的数据而掉线，<strong>一次简单攻击的实现</strong>    </p><h3 id="l"><a href="#l" class="headerlink" title="-l"></a><strong>-l</strong></h3><p>定义发送数据包的大小，默认为32字节，我们利用它可以最大定义到65500字节。结合上面介绍的-t参数一起使用，效果更好    </p><h3 id="n"><a href="#n" class="headerlink" title="-n"></a><strong>-n</strong></h3><p>向目标IP发送数据包的次数，默认为3次。如果网络速度比较慢，3次对我们来说也浪费了不少时间，因为现在我们的目的仅仅是判断目标IP是否存在，那么就定义为一次吧。<br>说明一下，如果-t 参数和-n参数一起使用，ping命令就以放在后面的参数为标准，比如“ping IP -t -n 3”，虽然使用了-t参数，但并不是一直ping下去，而是只ping 3次。  </p><h2 id="nbtstat"><a href="#nbtstat" class="headerlink" title="nbtstat"></a><strong>nbtstat</strong></h2><p>　　该命令使用TCP/IP上的NetBIOS显示协议统计和当前TCP/IP连接，这个命令可得到远程主机的NETBIOS信息，比如用户名、所属的工作组、网卡的MAC地址等  </p><h3 id="a"><a href="#a" class="headerlink" title="-a"></a><strong>-a</strong></h3><p>只要知道远程主机的机器名称，就可以得到它的NETBIOS信息(下同)。 // nbtstat -a fei(计算机名)  </p><h3 id="A"><a href="#A" class="headerlink" title="-A"></a><strong>-A</strong></h3><p>可得到远程主机的NETBIOS信息，但需要知道它的IP。<br>//nbtstat -a 192.168.1.100  </p><h3 id="n-1"><a href="#n-1" class="headerlink" title="-n"></a><strong>-n</strong></h3><p>列出本地机器的NETBIOS信息。<br>当得到了对方的IP或者机器名后，可用nbtstat命令来进一步得到对方的信息了，这又增加了我们入侵的保险系数。  </p><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a><strong>netstat</strong></h2><p>用来查看网络状态的命令。  </p><h3 id="a-1"><a href="#a-1" class="headerlink" title="-a"></a><strong>-a</strong></h3><p>查看本地机器的所有开放端口，可以知道机器所开的服务等信息，有效发现和预防木马。用法:netstat -a IP。  </p><h3 id="r"><a href="#r" class="headerlink" title="-r"></a><strong>-r</strong></h3><p> 列出当前的路由信息，获取本地机器的网关、子网掩码等信息。用法:netstat -r IP。  </p><h2 id="tracert"><a href="#tracert" class="headerlink" title="tracert"></a><strong>tracert</strong></h2><p>跟踪路由信息，此命令可查出数据从本地机器传输到目标主机所经过的途径，了解网络布局和结构。<br>这里说明数据从本地机器传输到192.168.0.1的机器上，中间没有经过任何中转，说明这两台机器是在同一段局域网内。用法:tracert IP。  </p><h2 id="net"><a href="#net" class="headerlink" title="net"></a><strong>net</strong></h2><h3 id="net-view"><a href="#net-view" class="headerlink" title="net view"></a><strong>net view</strong></h3><p>此命令查看远程主机的所以共享资源。命令格式为net view IP。  </p><h3 id="net-start"><a href="#net-start" class="headerlink" title="net start"></a><strong>net start</strong></h3><p>用来启动远程主机上的服务。<br>用法:net start servername</p><h3 id="net-stop"><a href="#net-stop" class="headerlink" title="net stop"></a><strong>net stop</strong></h3><p>用来关闭远程主机上的服务。<br>用法和net start同。  </p><h3 id="net-user"><a href="#net-user" class="headerlink" title="net user"></a><strong>net user</strong></h3><p><strong>查看和帐户有关的情况，包括新建帐户、删除帐户、查看特定帐户、激活帐户、帐户禁用等</strong><br>这对我们入侵是很有利的，最重要的，它为我们克隆帐户提供了前提。键入不带参数的net user，可以查看所有用户，包括已经禁用的。下面分别讲解。<br>1，net user abcd1234/add，新建一个用户名为abcd，密码为1234的帐户，默认为user组成员。<br>2，net user abcd /del，将用户名为abcd的用户删除。<br>3，net user abcd /active:no，将用户名为abcd的用户禁用。<br>4，net user abcd /active:yes，激活用户名为abcd的用户。<br>5，net user abcd，查看用户名为abcd的用户的情况   </p><h3 id="net-localgroup"><a href="#net-localgroup" class="headerlink" title="net localgroup"></a><strong>net localgroup</strong></h3><p>查看所有和用户组有关的信息和进行相关操作。键入不带参数的netlocalgroup即列出当前所有的用户组。<br>用法:net localgroup groupname username /add。    </p><h2 id="at"><a href="#at" class="headerlink" title="at"></a><strong>at</strong></h2><p>这个命令的作用是安排在特定日期或时间执行某个特定的命令和程序(知道net time的重要了吧?)。当我们知道了远程主机的当前时间，就可以利用此命令让其在以后的某个时间(比如2分钟后)执行某个程序和命令。<br>用法:at time 命令\computer。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试</title>
      <link href="/2018/09/22/2018-9-22-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/09/22/2018-9-22-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a><strong>瀑布模型</strong></h3><p>适合于比较成熟，稳定的项目，即已经有类似，已经做烂到倒背如流的项目<br>思路清晰 ，容易把控   但要求前期需求分析明确稳定，一旦需求变更，牵一发而动全身，会影响大部分流程<br><strong>改良</strong>：每个阶段的小迭代开发：每个阶段如需求分析阶段，设计阶段…等等都有相关的人员对原型进行多次开会讨论确定至迭代出该阶段的最终产品  </p><h3 id="快速模型"><a href="#快速模型" class="headerlink" title="快速模型"></a><strong>快速模型</strong></h3><p>先实现基本功能，再开会讨论增加新的功能，进行下一次的开发<br>适合小型，需求不明确系统</p><h3 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a><strong>V模型</strong></h3><p><strong>需求分析</strong>（需求分析人员，需求文档）<br><strong>概要设计</strong> 详细设计（UI工程师 psd设计稿）<br><strong>编码</strong><br><strong>单元测试</strong>（单独模块）<br><strong>集成测试</strong>（模块之间）<br><strong>系统测试</strong>（前期测试是否满足需求 后期测试性能及在硬件中的兼容性）<br><strong>验收测试</strong> α测试 内测 β测试 公测 γ测试 基本无需求 性能上的bug<br>优缺点：和瀑布模型类似，都是线性流程的问题</p><h3 id="W模型"><a href="#W模型" class="headerlink" title="W模型"></a><strong>W模型</strong></h3><p>在软件开发的每一个阶段都生成文档进行测试<br><strong>按是否关心代码细节</strong></p><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a><strong>白盒测试</strong></h3><p>有源码，关心程序结构</p><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a><strong>黑盒测试</strong></h3><p>不关心源码，只关心输入和结果<br><img src="https://viabcde.github.io/images/2018-09-22/2018092205.png" alt="enter description here"><br><strong>按是否运行代码</strong></p><h3 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a><strong>静态测试</strong></h3><p>不运行程序 高层开会讨论文档，界面等的不合理之处</p><h3 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a><strong>动态测试</strong></h3><p>实际运行程序<br><strong>其他</strong></p><h3 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a><strong>回归测试</strong></h3><p>发现bug修改后再次测试,包括测试与其相关的其他模块的代码</p><h3 id="随机测试"><a href="#随机测试" class="headerlink" title="随机测试"></a><strong>随机测试</strong></h3><p>对软件关键之处或容易出现bug的地方进行测试</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a><strong>测试用例</strong></h3><p>测什么模块 怎么测</p><h3 id="有效等价划分"><a href="#有效等价划分" class="headerlink" title="有效等价划分"></a><strong>有效等价划分</strong></h3><p>针对不能穷举的数据进行划分<br><img src="https://viabcde.github.io/images/2018-09-22/2018092206.png" alt="enter description here"></p><h4 id="等价类考虑的细节"><a href="#等价类考虑的细节" class="headerlink" title="等价类考虑的细节"></a><strong>等价类考虑的细节</strong></h4><p><img src="https://viabcde.github.io/images/2018-09-22/2018092207.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/2018-09-22/2018092208.png" alt="enter descriptionhere"><br>测试的时候边界值包括边界值左右的误差值也要测一下</p><h3 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a><strong>软件缺陷</strong></h3><p>软件没有满足用户的一些需求<br>软件做了用户需求之外关联度不大的功能<br>逻辑不合常理<br>性能不达标<br>系统崩溃  </p><h3 id="导致软件缺陷的原因"><a href="#导致软件缺陷的原因" class="headerlink" title="导致软件缺陷的原因"></a><strong>导致软件缺陷的原因</strong></h3><p>用户需求定义出错<br>设计阶段出错<br>编码错误<br>硬件环境不兼容的错误  </p><h3 id="版本管理工具的使用原因"><a href="#版本管理工具的使用原因" class="headerlink" title="版本管理工具的使用原因"></a><strong>版本管理工具的使用原因</strong></h3><p>方便备份文件<br>可以知道目前拿到的版本是否是最新的<br>可以很容易获得之前某一个版本的文件<br>不需要手动分享文件，任何需要文件资料的人可以通过版本工具去下载<br>在提交修改时不会覆盖之前的版本，而是在管理者确认合并后才能合并</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP_1</title>
      <link href="/2018/09/22/2018-9-22-TCPIP_1/"/>
      <url>/2018/09/22/2018-9-22-TCPIP_1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://viabcde.github.io/images/2018-09-22/tcpip.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-22/2018092201.png" alt="enter description here"><br>在上图中，也有一些应用程序直接访问ip层（一些较老的选路协议就是以这种方式来实现的。当然新的运输层协议也有可能使用这种方式）  </p><h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a><strong>ICMP</strong></h3><p>是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息.  不仅仅是IP使用了ICMP 流行的诊断工具如Ping和Traceroute，它们也使用了ICMP。  </p><h3 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a><strong>IGMP</strong></h3><p>是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。<br>ARP（地址解析协议）和RARP逆地址解析协议）是某些网络接口（如以太网和令牌环<br>网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。  </p><h3 id="1-TCP-IP"><a href="#1-TCP-IP" class="headerlink" title="1.TCP/IP"></a><strong>1.TCP/IP</strong></h3><p>是最常应用的组网（组建网络）形式，是全球互联网和因特网的基础  </p><h3 id="2-链路层"><a href="#2-链路层" class="headerlink" title="2.链路层"></a><strong>2.链路层</strong></h3><p>设备驱动程序+网卡（网络接口卡）—-组合处理连接如电缆等物理接口细节   </p><h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a><strong>3.网络层</strong></h3><p>处理分组在网络中路径的选择等。网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议）。  </p><h3 id="4-运输层"><a href="#4-运输层" class="headerlink" title="4.运输层"></a><strong>4.运输层</strong></h3><p>运输层主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。  </p><h3 id="TCP报文段"><a href="#TCP报文段" class="headerlink" title="TCP报文段"></a><strong>TCP报文段</strong></h3><p>为两台主机提供高可靠性的数据通信。它必须确认接收到的分组，且设置了发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。  </p><h3 id="UDP数据报"><a href="#UDP数据报" class="headerlink" title="UDP数据报"></a><strong>UDP数据报</strong></h3><p>则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。任何必需的可靠性必须由应用层来提供。  </p><h3 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a><strong>IP数据报</strong></h3><h3 id="5-应用层"><a href="#5-应用层" class="headerlink" title="5.应用层"></a><strong>5.应用层</strong></h3><p>应用层负责处理特定的应用程序细节。几乎各种不同的TCP/IP实现程序都会提供下面这些通用的应用程序的实现方法：<br><strong>• Telnet</strong> 远程登录。<br><strong>• FTP</strong> 文件传输协议。<br><strong>• SMTP</strong> 简单邮件传送协议。<br><strong>• SNMP</strong> 简单网络管理协议。<br>FTP是一种应用层协议<br>TCP是一种运输层协议<br>IP是一种网络层协议<br>以太网协议则应用于链路层上    </p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器:"></a><strong>路由器:</strong></h3><p>构造互连网最简单的方法是把两个或多个网络通过路由器进行连接。它是一种特殊的用于网络互连的硬件盒。这些盒子称作网关（gateway）  </p><h3 id="路由器的好处"><a href="#路由器的好处" class="headerlink" title="路由器的好处:"></a><strong>路由器的好处:</strong></h3><p>是为不同类型的物理网络提供连接：以太网、令牌环网、点对点的链接和FDDI（光纤分布式数据接口）等等。<br>IP提供的只是尽可能快地把分组从源结点送到目的结点<br>TCP采用了超时重传、发送和接收端到端的确认分组等机制，为ip增加了可靠性<br><img src="https://viabcde.github.io/images/2018-09-22/2018092202.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-22/2018092203.png" alt="enter description here"><br>区分各类地址的最简单方法是看它的第一个十进制整数。<br>Internet注册服务(IP地址和DNS域名)过去由NIC来负责，其网络地址是nic.ddn.mil。<br>1993年4月1日，InterNIC成立。现在，NIC只负责处理国防数据网的注册请求，所有其他的Internet用户注册请求均由InterNIC负责处理，其网址是：rs.internic.net。<br>事实上InterNIC由三部分组成：注册服务（rs.internic.net），目录和数据库服务（ds.internic.net），以及信息服务（is.internic.net）。<br>域名系统（DNS）是一个分布的数据库，由它来提供IP地址和主机名之间的映射信息<br>帧：链路层在以太网传输的比特流  </p><h3 id="IP首部空出8位的长度的原因"><a href="#IP首部空出8位的长度的原因" class="headerlink" title="IP首部空出8位的长度的原因"></a><strong>IP首部空出8位的长度的原因</strong></h3><p>由于TCP、UDP、ICMP和IGMP都要向IP传送数据，因此IP必须在生成的IP首部中加入某种标识，以表明数据属于哪一层。为此，IP在首部中存入一个长度为8bit的数值，称作协议域。 1表示为ICMP协议，2表示为IGMP协议，6表示为TCP协议，17表示为UDP协议。<br>类似地，许多应用程序都可以使用 TCP或UDP来传送数据。运输层协议在生成报文首部<br>时要存入一个应用程序的标识符。TCP和UDP都用一个16bit的端口号来表示不同的应用程序。<br>TCP和UDP把源端口号和目的端口号分别存入报文首部中。<br>网络接口分别要发送和接收IP、ARP和RARP数据，因此也必须在以太网的帧首部中加入<br>某种形式的标识，以指明生成数据的网络层协议。为此，以太网的帧首部也有一个16bit的帧类型域。<br>服务器一般都是通过知名端口号来识别的。例如，对于每个TCP/IP实现来说，FTP服务器的TCP端口号都是21，每个Telnet服务器的TCP端口号都是23，每个TFTP(简单文件传送协议)服务器的UDP端口号都是69。任何TCP/IP实现所提供的服务都用知名的1～1023之间的端口号。  </p><p>知名端口号介于1～255之间。256～1023之间的端口号通常都是由Unix系统占用，以提供一些特定的Unix服务—也就是说，提供一些只有Unix系统才有的、而其他操作系统可能不提供的服务。现在IANA管理1～1023之间所有的端口号。  </p><p>客户端口号又称作临时端口号（即存在时间很短暂）。这是因为它通常只是在用户运行该客户程序时才存在，而服务器则只要主机开着的，其服务就运行。<br><img src="https://viabcde.github.io/images/2018-09-22/2018092204.png" alt="enter description here"><br>intenet 动词 使主机连在一起 Intenet 名词 是所有主机的集合  </p><h3 id="分用和复用"><a href="#分用和复用" class="headerlink" title="分用和复用"></a><strong>分用和复用</strong></h3><p>分用：将以太网的帧一层层分离直至交给对应的app<br>复用：将app的数据一层层复合上标志上传到以太网中</p><h3 id="子网掩码的作用"><a href="#子网掩码的作用" class="headerlink" title="子网掩码的作用"></a><strong>子网掩码的作用</strong></h3><p>为了计算两个IP地址是否属于同一个网络中<br>因为1与1得1 1与0的0<br>IP与运算子网掩码255.255.255.0可以得到网络号<br>例如：<br>202.99.160.50 换算成二进制为 11001010·01100011·10100000·00110010<br>255.255.255.0 换算成二进制为 11111111·11111111·11111111·00000000<br>将二者进行与运算   </p><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a><strong>网关</strong></h3><p>每个网络之间连接的桥梁<br>因为每个网络中的主机只能与该网络的其他主机通信，不能和其他网络的主机通信<br>只有通过网关即路由器作为代理，其他网关作为另一个主机的代理，这两个主机才能通信  </p><h3 id="http持久连接"><a href="#http持久连接" class="headerlink" title="http持久连接"></a><strong>http持久连接</strong></h3><p>http在的一次会话需要先建立tcp连接（大部分是tcp，但是其他安全协议也是可以的），然后才能通信，如果每次连接都只进行一次http会话，那这个连接过程占的比例太大了！</p><p>　　于是出现了持久连接：在http/1.0+中是connection首部中添加keep-alive值，在http/1.1中是在connection首部中添加persistent值，当然两者不仅仅是命名上的差别，http/1.1中，持久连接是默认的，除非显示在connection中添加close，否则持久连接不会关闭，而http/1.0+中则恰好相反，除非显示在connection首部中添加keep-alive，否则在接收数据包后连接就断开了。</p><p>　　出现了持久连接还不够，在http/1.1中，还有一种称为管道通信的方式进行速度优化：把需要发送到服务器上的所有请求放到输出队列中，在第一个请求发送出去后，不等到收到服务器的应答，第二个请求紧接着就发送出去，但是这样的方式有一个问题：不安全</p><pre><code>public class Main_1 {    public static void main(String[] args) {        Integer a = 1;        Integer b = 2;        Integer c = 3;        Integer d = 3;        Integer e = 321;        Integer f = 321;        Long g = 3L;        System.out.println(c == d);        System.out.println(e == f);        System.out.println(c == (a + b));//true        System.out.println(c.equals(a + b));        System.out.println(g == (a + b));//true        System.out.println(g.equals(a + b));        System.out.println(g.equals(a + h));    }}</code></pre><h3 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a><strong>网络传输</strong></h3><p>在控制台输入 hello<br>经过应用层 ap hello<br>经过传输层 tcp ap hello<br>经过网络层 ip tcp ap hello<br>经过链路层 帧头 帧尾 ip tcp ap hello<br>经过路由器转发<br>经过链路层  ip tcp ap hello<br>经过网络层  tcp ap hello<br>经过传输层  ap hello<br>经过应用层  hello<br>在控制台输出 hello  </p><h3 id="各类ip地址"><a href="#各类ip地址" class="headerlink" title="各类ip地址"></a><strong>各类ip地址</strong></h3><p>a类 0+7位网络号 +3个字节主机号<br>b类 10+14位网络号+2个字节主机号<br>c类 110+21位网络号+1个字节主机号  </p><h3 id="路由器寻址"><a href="#路由器寻址" class="headerlink" title="路由器寻址"></a><strong>路由器寻址</strong></h3><p>每个路由器都会管理一些ip地址 构成自己的子网<br>当某一台主机发出寻址要求时   路由器先查看自己的子网是否有对应的ip没有则转发给其他路由器 一直转发至找到ip</p><h3 id="单工-、半双工、全双工"><a href="#单工-、半双工、全双工" class="headerlink" title="单工 、半双工、全双工"></a><strong>单工 、半双工、全双工</strong></h3><p>单工 只能发送不能回复 bb机<br>半双工 一方说话时另一方不能说 对讲机<br>全双工 双方可以同时说话</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置文件模板</title>
      <link href="/2018/09/19/2018-9-19-%E6%A8%A1%E6%9D%BF/"/>
      <url>/2018/09/19/2018-9-19-%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="struts2-xml模板"><a href="#struts2-xml模板" class="headerlink" title="struts2.xml模板"></a><strong>struts2.xml模板</strong></h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE struts PUBLIC    &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;    &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt;&lt;struts&gt;&lt;!--从这到30行可以完全不写--&gt;    &lt;!-- 指定spring负责action对象的创建--&gt;    &lt;constant name=&quot;struts.objectFactory&quot; value=&quot;spring&quot; /&gt;    &lt;!-- 所有匹配*.action的请求都由struts2处理--&gt;    &lt;constant name=&quot;struts.action.extension&quot; value=&quot;action&quot; /&gt;    &lt;!--是否使用开发模式(错误反馈内容更多但耗性能)--&gt;    &lt;constant name=&quot;struts.devMode&quot; value=&quot;false&quot; /&gt;    &lt;!--struts配置文件改动后，是否重新加载--&gt;    &lt;constant name=&quot;struts.configuration.xml.reload&quot; value=&quot;true&quot; /&gt;    &lt;!--设置浏览器是否缓存静态内容--&gt;    &lt;constant name=&quot;struts.serve.static.browserCache&quot; value=&quot;false&quot; /&gt;    &lt;!--请求参数的编码方式--&gt;    &lt;constant name=&quot;struts.i18n.encoding&quot; value=&quot;utf-8&quot; /&gt;    &lt;!--每次HTTP请求系统都重新加载资源文件，有助于开发--&gt;    &lt;constant name=&quot;struts.i18n.reload&quot; value=&quot;true&quot; /&gt;    &lt;!--文件最大上传值--&gt;    &lt;constant name=&quot;struts.multipart.maxSize&quot; value=&quot;104857600&quot; /&gt;    &lt;!--让struts2支持动态方法调用--&gt;    &lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;true&quot; /&gt;    &lt;!--Action名称中是否可用斜线--&gt;    &lt;constant name=&quot;struts.enable.SlashesInActionNames&quot; value=&quot;false&quot; /&gt;    &lt;!--允许标签中使用表达式语法--&gt;    &lt;constant name=&quot;struts.tag.altSyntax&quot; value=&quot;true&quot; /&gt;    &lt;!--对于Weblogic，Orion,OC4J此属性应该设置为true--&gt;    &lt;constant name=&quot;struts.dispatcher.parametersWorkaround&quot; value=&quot;false&quot; /&gt;    &lt;package name=&quot;shop&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt;        &lt;!-- 配置自定义拦截器 --&gt;        &lt;interceptors&gt;            &lt;interceptor name=&quot;privilegeInterceptor&quot; class=&quot;cn.itcast.shop.interceptor.PrivilegeInterceptor&quot;/&gt;        &lt;/interceptors&gt;        &lt;global-results&gt;            &lt;result name=&quot;msg&quot;&gt;/WEB-INF/jsp/msg.jsp&lt;/result&gt;            &lt;result name=&quot;login&quot;&gt;/admin/index.jsp&lt;/result&gt;        &lt;/global-results&gt;        &lt;!--以下action可以在类里面用注解来配置            @ParentPackage(&quot;shop&quot;)  上方31行 package的name            @Namespace(&quot;/&quot;)    如果action的命名为/demo/*.action 则此处为/demp            @Action(value=&quot;与类名相同&quot;) 如：userAction 开启了动态方法调用只需要配置一次（用userAction!test.action访问test方法），不在类名前配置则需要在类中的每个方法名前配置action        --&gt;        &lt;!-- 配置首页访问的Action --&gt;        &lt;action name=&quot;index&quot; class=&quot;indexAction&quot;&gt;            &lt;result name=&quot;index&quot;&gt;/WEB-INF/jsp/index.jsp&lt;/result&gt;        &lt;/action&gt;        &lt;!-- 配置用户模块的Action --&gt;        &lt;action name=&quot;user_*&quot; class=&quot;userAction&quot; method=&quot;{1}&quot;&gt;            &lt;result name=&quot;registPage&quot;&gt;/WEB-INF/jsp/regist.jsp&lt;/result&gt;            &lt;result name=&quot;input&quot;&gt;/WEB-INF/jsp/regist.jsp&lt;/result&gt;            &lt;result name=&quot;loginPage&quot;&gt;/WEB-INF/jsp/login.jsp&lt;/result&gt;            &lt;result name=&quot;login&quot;&gt;/WEB-INF/jsp/login.jsp&lt;/result&gt;            &lt;result name=&quot;loginSuccess&quot; type=&quot;redirectAction&quot;&gt;index&lt;/result&gt;            &lt;result name=&quot;quit&quot; type=&quot;redirectAction&quot;&gt;index&lt;/result&gt;            &lt;result name=&quot;checkcodeFail&quot;&gt;/WEB-INF/jsp/regist.jsp&lt;/result&gt;        &lt;/action&gt;        &lt;!-- 验证码Action --&gt;        &lt;action name=&quot;checkImg&quot; class=&quot;checkImgAction&quot;&gt;&lt;/action&gt;        &lt;!-- 商品模块的Action --&gt;        &lt;action name=&quot;product_*&quot; class=&quot;productAction&quot; method=&quot;{1}&quot;&gt;            &lt;result name=&quot;findByPid&quot;&gt;/WEB-INF/jsp/product.jsp&lt;/result&gt;            &lt;result name=&quot;findByCid&quot;&gt;/WEB-INF/jsp/productList.jsp&lt;/result&gt;            &lt;result name=&quot;findByCsid&quot;&gt;/WEB-INF/jsp/productList.jsp&lt;/result&gt;        &lt;/action&gt;        &lt;!-- 购物车的Action --&gt;        &lt;action name=&quot;cart_*&quot; class=&quot;cartAction&quot; method=&quot;{1}&quot;&gt;            &lt;result name=&quot;addCart&quot;&gt;/WEB-INF/jsp/cart.jsp&lt;/result&gt;            &lt;result name=&quot;clearCart&quot;&gt;/WEB-INF/jsp/cart.jsp&lt;/result&gt;            &lt;result name=&quot;removeCart&quot;&gt;/WEB-INF/jsp/cart.jsp&lt;/result&gt;            &lt;result name=&quot;myCart&quot;&gt;/WEB-INF/jsp/cart.jsp&lt;/result&gt;        &lt;/action&gt;        &lt;!-- 订单的Action --&gt;        &lt;action name=&quot;order_*&quot; class=&quot;orderAction&quot; method=&quot;{1}&quot;&gt;            &lt;result name=&quot;saveOrder&quot;&gt;/WEB-INF/jsp/order.jsp&lt;/result&gt;            &lt;result name=&quot;findByUid&quot;&gt;/WEB-INF/jsp/orderList.jsp&lt;/result&gt;            &lt;result name=&quot;findByOid&quot;&gt;/WEB-INF/jsp/order.jsp&lt;/result&gt;            &lt;result name=&quot;updateStateSuccess&quot; type=&quot;redirectAction&quot;&gt;order_findByUid.action?page=1&lt;/result&gt;        &lt;/action&gt;        &lt;!-- 后台登录Action --&gt;        &lt;!-- 1代表name中的第一个*,2代表第一个* --&gt;        &lt;action name=&quot;adminUser_*&quot; class=&quot;adminUserAction&quot; method=&quot;{1}&quot;&gt;            &lt;!-- 不同的name对应的结果视图 --&gt;            &lt;result name=&quot;loginFail&quot;&gt;/admin/index.jsp&lt;/result&gt;            &lt;result name=&quot;loginSuccess&quot; type=&quot;redirect&quot;&gt;/admin/home.jsp&lt;/result&gt;            &lt;!-- 拦截器 --&gt;            &lt;interceptor-ref name=&quot;privilegeInterceptor&quot;&gt;            &lt;!-- 不拦截（放行login方法）：excludeMethods                拦截：&lt;param name=&quot;includeMethods&quot;&gt;method1,method2&lt;/param&gt; --&gt;                &lt;!-- method-name：adminUser_login --&gt;                &lt;param name=&quot;excludeMethods&quot;&gt;login&lt;/param&gt;            &lt;/interceptor-ref&gt;            &lt;!-- 拦截器缺省堆栈 --&gt;            &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt;        &lt;/action&gt;        &lt;!-- 后台一级分类管理Action --&gt;        &lt;action name=&quot;adminCategory_*&quot; class=&quot;adminCategoryAction&quot; method=&quot;{1}&quot;&gt;            &lt;result name=&quot;findAll&quot;&gt;/admin/category/list.jsp&lt;/result&gt;            &lt;result name=&quot;saveSuccess&quot; type=&quot;redirectAction&quot;&gt;adminCategory_findAll&lt;/result&gt;            &lt;result name=&quot;deleteSuccess&quot; type=&quot;redirectAction&quot;&gt;adminCategory_findAll&lt;/result&gt;            &lt;result name=&quot;editSuccess&quot;&gt;/admin/category/edit.jsp&lt;/result&gt;            &lt;result name=&quot;updateSuccess&quot; type=&quot;redirectAction&quot;&gt;adminCategory_findAll&lt;/result&gt;            &lt;interceptor-ref name=&quot;privilegeInterceptor&quot;/&gt;            &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt;        &lt;/action&gt;        &lt;!-- 后台二级分类管理Action --&gt;        &lt;action name=&quot;adminCategorySecond_*&quot; class=&quot;adminCategorySecondAction&quot; method=&quot;{1}&quot;&gt;            &lt;result name=&quot;findAll&quot;&gt;/admin/categorysecond/list.jsp&lt;/result&gt;            &lt;result name=&quot;addPage&quot;&gt;/admin/categorysecond/add.jsp&lt;/result&gt;            &lt;result name=&quot;saveSuccess&quot; type=&quot;redirectAction&quot;&gt;adminCategorySecond_findAll?page=1&lt;/result&gt;            &lt;result name=&quot;deleteSuccess&quot; type=&quot;redirectAction&quot;&gt;adminCategorySecond_findAll?page=1&lt;/result&gt;            &lt;result name=&quot;editSuccess&quot;&gt;/admin/categorysecond/edit.jsp&lt;/result&gt;            &lt;result name=&quot;updateSuccess&quot; type=&quot;redirectAction&quot;&gt;adminCategorySecond_findAll?page=1&lt;/result&gt;            &lt;interceptor-ref name=&quot;privilegeInterceptor&quot;/&gt;            &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt;        &lt;/action&gt;        &lt;!-- 后台商品管理的Action --&gt;        &lt;action name=&quot;adminProduct_*&quot; class=&quot;adminProductAction&quot; method=&quot;{1}&quot;&gt;            &lt;result name=&quot;findAll&quot;&gt;/admin/product/list.jsp&lt;/result&gt;            &lt;result name=&quot;addPageSuccess&quot;&gt;/admin/product/add.jsp&lt;/result&gt;            &lt;result name=&quot;saveSuccess&quot; type=&quot;redirectAction&quot;&gt;adminProduct_findAll.action?page=1&lt;/result&gt;            &lt;result name=&quot;deleteSuccess&quot; type=&quot;redirectAction&quot;&gt;adminProduct_findAll.action?page=1&lt;/result&gt;            &lt;result name=&quot;editSuccess&quot;&gt;/admin/product/edit.jsp&lt;/result&gt;            &lt;result name=&quot;updateSuccess&quot; type=&quot;redirectAction&quot;&gt;adminProduct_findAll.action?page=1&lt;/result&gt;            &lt;interceptor-ref name=&quot;privilegeInterceptor&quot;/&gt;            &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt;        &lt;/action&gt;        &lt;!-- 后台订单管理Action --&gt;        &lt;action name=&quot;adminOrder_*&quot; class=&quot;adminOrderAction&quot; method=&quot;{1}&quot;&gt;            &lt;result name=&quot;findAll&quot;&gt;/admin/order/list.jsp&lt;/result&gt;            &lt;result name=&quot;updateStateSuccess&quot; type=&quot;redirectAction&quot;&gt;adminOrder_findAll.action?page=1&lt;/result&gt;            &lt;result name=&quot;findOrderItem&quot; &gt;/admin/order/orderItem.jsp&lt;/result&gt;            &lt;interceptor-ref name=&quot;privilegeInterceptor&quot;/&gt;            &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt;        &lt;/action&gt;        &lt;!-- 后台用户管理Action --&gt;        &lt;action name=&quot;userAdmin_*&quot; class=&quot;userAdminAction&quot; method=&quot;{1}&quot;&gt;            &lt;result name=&quot;findAll&quot;&gt;/admin/user/list.jsp&lt;/result&gt;            &lt;result name=&quot;deleteSuccess&quot; type=&quot;redirectAction&quot;&gt;userAdmin_findAll.action?page=1&lt;/result&gt;            &lt;result name=&quot;editSuccess&quot;&gt;/admin/user/edit.jsp&lt;/result&gt;            &lt;result name=&quot;updateSuccess&quot; type=&quot;redirectAction&quot;&gt;userAdmin_findAll.action?page=1&lt;/result&gt;            &lt;interceptor-ref name=&quot;privilegeInterceptor&quot;/&gt;            &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;</code></pre><h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a><strong>web.xml</strong></h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;     xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee     http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;     id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt;    &lt;!-- 配置spring核心监听器，默认会以 /WEB-INF/applicationContext.xml作为配置文件 --&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;!-- contextConfigLocation参数用来指定Spring的配置文件加载项是哪个 --&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;/WEB-INF/applicationContext*.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;!--另一种写法:更改applicationContext*.xml名称时应该放在classpath下，    不能放在web-INF下，具体原因不知道        &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt;    &lt;/context-param&gt;    --&gt;    &lt;!-- 定义Spring MVC的前端控制器 --&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;servlet-class&gt;        org.springframework.web.servlet.DispatcherServlet    &lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;/WEB-INF/springmvc-config.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;!-- 让Spring MVC的前端控制器拦截所有请求 --&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;  &lt;!-- 编码过滤器 --&gt;  &lt;filter&gt;        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt; &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    &lt;!-- jsp的配置 --&gt;  &lt;jsp-config&gt;    &lt;jsp-property-group&gt;         &lt;!-- 配置拦截所有的jsp页面  --&gt;      &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;       &lt;!-- 可以使用el表达式  --&gt;      &lt;el-ignored&gt;false&lt;/el-ignored&gt;      &lt;!-- 不能在页面使用java脚本 --&gt;      &lt;scripting-invalid&gt;true&lt;/scripting-invalid&gt;      &lt;!-- 给所有的jsp页面导入要依赖的库，tablib.jsp就是一个全局的标签库文件  --&gt;      &lt;include-prelude&gt;/WEB-INF/jsp/taglib.jsp&lt;/include-prelude&gt;    &lt;/jsp-property-group&gt;  &lt;/jsp-config&gt;  &lt;error-page&gt;    &lt;error-code&gt;404&lt;/error-code&gt;    &lt;location&gt;/404.html&lt;/location&gt;  &lt;/error-page&gt;  &lt;welcome-file-list&gt;    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;  &lt;/welcome-file-list&gt;&lt;/web-app&gt;</code></pre><h3 id="Servlet模板"><a href="#Servlet模板" class="headerlink" title="Servlet模板"></a><strong>Servlet模板</strong></h3><pre><code>import java.io.*;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyServlet extends HttpServlet{        public void doPost(HttpServletRequest request,HttpServletResponse response)throws ServletException,IOException{        }        public void doGet(HttpServletRequest request,HttpServletResponse response)throws ServletException,IOException{            PrintWriter out = response.getWriter();            out.println(&quot;some html formate string&quot;);        }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL语句示例及调优</title>
      <link href="/2018/09/19/2018-9-19-SQL/"/>
      <url>/2018/09/19/2018-9-19-SQL/</url>
      
        <content type="html"><![CDATA[<h3 id="1-去除重复记录"><a href="#1-去除重复记录" class="headerlink" title="1.去除重复记录"></a><strong>1.去除重复记录</strong></h3><pre><code>Select Distinct mgr From offices  </code></pre><h3 id="2-不等于"><a href="#2-不等于" class="headerlink" title="2.不等于"></a><strong>2.不等于</strong></h3><pre><code>Select city,mgr from offices      Where mgr&lt;&gt;108</code></pre><h3 id="3-IN"><a href="#3-IN" class="headerlink" title="3. IN"></a><strong>3. IN</strong></h3><p>列出1990-01的每个星期三的订单  </p><pre><code>Select Order_Num,Order_Date,Amount      From Orders      Where Order_Date In(&#39;04-Jan-90&#39;,&#39;11-Jan-90&#39;,    &#39;18-Jan-90&#39;,&#39;25-Jan-90&#39;)</code></pre><h3 id="4-NOT"><a href="#4-NOT" class="headerlink" title="4.NOT"></a><strong>4.NOT</strong></h3><pre><code>Select * From Student    Where Not id &gt; 009</code></pre><h3 id="5-Order-By"><a href="#5-Order-By" class="headerlink" title="5.Order By"></a><strong>5.Order By</strong></h3><p>先按地区首字母升序/降序排列，再在有相同地区的按城市首字母排列</p><pre><code>Select City,Region,Sales    From OffidesOrder By Region,City Asc/Desc</code></pre><p>如果查询的结果字段是组合字段 可以用序号代替  </p><pre><code>Select City,Region,(Sales-Targer)    From Offices  Order By 3 Desc</code></pre><p>这里用3代替(Sales-Targer)</p><h3 id="6-union"><a href="#6-union" class="headerlink" title="6.union"></a><strong>6.union</strong></h3><p>在2个查询中间 加 union 表示默认去除重复<br>union all 表示不去除重复<br>union 后排序 在第二个查询结果中指定排序规则</p><pre><code>Select Mfr_Id,Product_Id    From ProductsWhere Price&gt;2000Union allSelect Distinct Mfr,Product    From OrdersWhere Amount&gt;3000Order By 1,2</code></pre><p>多表联合(如果查询结果不去重则无执行顺序，需要去重则必须先执行括号内的)</p><pre><code>Select * From AUnion(    Select * From B    Union        Select * From C)</code></pre><h3 id="7-等连接（根据字段相等连接后可获取2个表的任意内容）"><a href="#7-等连接（根据字段相等连接后可获取2个表的任意内容）" class="headerlink" title="7.等连接（根据字段相等连接后可获取2个表的任意内容）"></a><strong>7.等连接（根据字段相等连接后可获取2个表的任意内容）</strong></h3><pre><code>Select Order_Num,Amount,Company,Credit_Limot    From Orders,CustomersWhere Cust=Cust_Num</code></pre><h3 id="8-汇总查询"><a href="#8-汇总查询" class="headerlink" title="8.汇总查询"></a><strong>8.汇总查询</strong></h3><pre><code>Select AVG(Sales) From SalesrepsSum(..) Min(..) Max(..) Count(..) Count(*)</code></pre><h3 id="9-group-by-指定字段"><a href="#9-group-by-指定字段" class="headerlink" title="9.group by 指定字段"></a><strong>9.group by 指定字段</strong></h3><p>按指定字段分组 通常和Having搭配使用</p><pre><code>Select SnoFrom SCGroup by SnoHaving Count(*)&gt;3</code></pre><h3 id="10-Join"><a href="#10-Join" class="headerlink" title="10.Join"></a><strong>10.Join</strong></h3><pre><code>SELECT 课程名称,AVG(考试成绩)平均分,MAX(考试成绩)最高分,MIN(考试成绩)最低分FROM 选课 JOIN 课程 ON 选课.课程编号=课程.课程编号GROUP BY 课程名称</code></pre><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a><strong>建表</strong></h3><p>示例1创建院系表<br>在建立表的同时，必须定义表名，列，以及列的数据类型和大小    ，还有列的完整性约束NOT NULL等，表的完整性约束   </p><pre><code>create table 院系(编号 INT,名称 CHAR(10)CONSTRAINT 名称 NOT NULL UNIQUE,负责人 CHAR(8),办公地点 CHAR(50),CONSTRAINT 编号 PRIMARY KEY (编号))</code></pre><p>笔记：CONSTRAINT表示对字段的约束<br>Constraint+约束名称+约束条件</p><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a><strong>修改表</strong></h3><p>–添加一个字段<br>sql&gt;alter table student add (classid number(2));<br>–修改一个字段的长度<br>sql&gt;alter table student modify (xm varchar2(30));<br>–修改字段的类型或是名字（不能有数据） 不建议做<br>sql&gt;alter table student modify (xm char(30));<br>–删除一个字段 不建议做(删了之后，顺序就变了。加就没问题，应该是加在后面)<br>sql&gt;alter table student drop column sal;<br>–修改表的名字 很少有这种需求<br>sql&gt;rename student to stu;   </p><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a><strong>删除表</strong></h3><p>sql&gt;drop table student;<br>示例2创建学生表  </p><pre><code>create table 学生(学号 CHAR(9)CONSTRAINT 学号 PRIMARY KEY,院系  AS CONVERT(INT,SUBSTRING(学号,3,2))PERSISTED CONSTRAINT 院系 NOT NULL,CONSTRAINT 院系key FOREIGN KEY (院系) REFERENCES 院系(编号),姓名 CHAR(8)CONSTRAINT 姓名 NOT NULL,性别 CHAR(2)CONSTRAINT 性别 CHECK(性别 IN(&#39;男&#39;,&#39;女&#39;)),生源 CHAR(50),状态 CHAR(4)CONSTRAINT 状态 CHECK(状态 IN(&#39;正常&#39;,&#39;留学&#39;,&#39;休学&#39;,&#39;退学&#39;)))</code></pre><p>笔记：  这里写成别名院系key 而不直接写字段名 防止名称和其他表名混淆<br>FOREIGN KEY (院系) REFERENCES 院系(编号)<br>第一个院系是外码，第二个院系是被参照表，编号是被参照列<br>自身表中的属性来自于其他表的主码，该属性就是外码，自身是参照关系，其他关系是被参照关系。</p><p>院系 AS CONVERT(INT,SUBSTRING(学号,3,2))PERSISTED<br>(院系为计算列（AS CONVERT()PERSISTED）,INT 输出数据类型，SUBSTRING(),取学号的从第3个字符始的2个字符)</p><p>CHECK(性别 IN(‘男’,’女’))  取值必须为男或者女</p><p>示例2创建选课表</p><pre><code>create table 选课(学号 CHAR(9),CONSTRAINT 学号key FOREIGN KEY(学号)REFERENCES 学生(学号),课程编号 CHAR(6),CONSTRAINT 课程编号key FOREIGN KEY(课程编号)REFERENCES 课程(课程编号),考试成绩 INT CONSTRAINT 考试成绩 CHECK(考试成绩 BETWEEN 0 AND 100)DEFAULT NULLCONSTRAINT sno_cno PRIMARY KEY(学号,课程编号))</code></pre><p>笔记：DEFAULT NULL  默认空值</p><h3 id="修改表-1"><a href="#修改表-1" class="headerlink" title="修改表"></a><strong>修改表</strong></h3><p>示例1规定学生表的性别字段不允许为空值</p><pre><code>ALTER TABLE 学生 ALTER COLUMN 性别 CHAR(2)NOT NULL</code></pre><p>示例2删除课程表中的责任教师列</p><pre><code>ALTER TABLE 课程 DROP CONSTRAINT 责任教师key ALTER TABLE 课程 DROP COLUMN 责任教师</code></pre><p>问题：直接删除不了列？<br>解决方法：删除时，因为默认是RESTRICT 如果被其他约束引用，要先删除约束，如果选择CASCADE，则不需要。<br>示例3为课程表增加责任教师列，列描述如下：<br>字符类型，长度为6；<br>允许空值；</p><pre><code>alter table 课程 add 责任教师 char(6)constraint 责任教师 null</code></pre><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h3><p>示例1插入院系表的第1个元组(记录)</p><pre><code>INSERT INTO  院系(编号,名称,负责人,办公地点)VALUES(&#39;1&#39;,&#39;信息管理学院&#39;,&#39;李嘉&#39;,&#39;教一楼3层&#39;)</code></pre><p>或者</p><pre><code>INSERT INTO 院系VALUES(&#39;2&#39;,&#39;经济管理学院&#39;,&#39;吴鸿忠&#39;,&#39;教三楼4层&#39;)问题：怎么添加多条记录？解决方法示例：insert into tableName(字段1, 字段2, 字段3)select val1,val2,val3union allselect val1,val2,val3union all。。。</code></pre><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a><strong>删除数据</strong></h3><p>示例1删除考试成绩为NULL的记录。</p><pre><code>DELETE FROM 选课WHERE 考试成绩=NULL</code></pre><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a><strong>更新数据</strong></h3><p>示例1将04014122号学生的B00101课程的考试成绩修改为78分</p><pre><code>UPDATE 选课SET 考试成绩=78WHERE 学号=&#39;04014122&#39;AND 课程编号=&#39;B00101&#39;</code></pre><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a><strong>查询</strong></h3><p>示例1查询学生的全部信息</p><pre><code>SELECT *FROM 学生示例2查询所有课程名称和学时信息。SELECT 课程名称,学时FROM 课程</code></pre><p>示例3查询学时大于等于40的课程编号和课程名称。</p><pre><code>SELECT 课程编号,课程名称FROM 课程WHERE 学时&gt;=40</code></pre><p>示例4查询课时在50到60（含）之间的课程信息。</p><pre><code>SELECT *FROM 课程WHERE 学时 &gt;50 AND 学时&lt;=60或者SELECT *FROM 课程WHERE 学时 BETWEEN 50 AND  60</code></pre><p>示例5查询具有教授和副教授职称的教师信息。</p><pre><code>SELECT *FROM 教师WHERE 职称=&#39;教授&#39;OR 职称=&#39;副教授&#39;示例6查询责任教师字段为空值的记录。SELECT *FROM 课程WHERE 责任教师 IS NULL</code></pre><p>示例7查询“专业基础”课程的信息，并将结果存储到Student模式下、表名为“专业基础”。</p><pre><code>SELECT * INTO student.专业基础 FROM 课程 WHERE 课程性质=&#39;专业基础&#39;</code></pre><p>示例8按教师编号升序列出所有教师信息。</p><pre><code>SELECT *FROM 教师ORDER BY 教师编号 ASC</code></pre><p>示例9查询所有学生信息，先按生源升序排序、再按学号升序排序。 </p><pre><code>SELECT *FROM 学生ORDER BY 生源 ASC,学号 ASC </code></pre><p>示例10从选课表中查询考试成绩最高的3条选课信息。</p><pre><code>SELECT TOP 3* FROM 选课ORDER BY 考试成绩 DESC</code></pre><p>示例11从选课表中查询考试成绩在前15%的选课记录信息，如果随后有成绩并列的记录也一起列出。 </p><pre><code>SELECT TOP 15PERCENT*FROM 选课ORDER BY 考试成绩 DESC</code></pre><p>示例12查询考试成绩在90分以上（含）的学生的学号、姓名、相应的课程名称和考试成绩(使用CROSS JOIN连接完成查询)。</p><pre><code>SELECT 学生.学号,姓名,课程名称,考试成绩 from 学生 left join 选课 on (学生.学号=选课.学号) left join 课程 on (选课.课程编号=课程.课程编号) where 考试成绩&gt;= 90</code></pre><p>示例13查询目前有多少责任教师。 </p><pre><code>SELECT COUNT(责任教师)FROM 课程</code></pre><p>示例14查询数据库课程的平均成绩。</p><pre><code>SELECT AVG(考试成绩)FROM 选课WHERE 课程编号 IN(SELECT 课程编号FROM 课程WHERE 课程名称=&#39;数据库&#39;)</code></pre><p>示例15查询各院系教师的人数（显示院系名称和教师人数）。</p><pre><code>SELECT 名称,COUNT(教师编号)教师人数FROM 院系  JOIN 教师 ON 院系.编号=教师.院系GROUP BY 名称</code></pre><p>示例16查询各门课程考试成绩的平均分、最高分和最低分。 </p><pre><code>SELECT 课程名称,AVG(考试成绩)平均分,MAX(考试成绩)最高分,MIN(考试成绩)最低分FROM 选课 JOIN 课程 ON 选课.课程编号=课程.课程编号GROUP BY 课程名称</code></pre><p>示例17查询专业基础课平均分大于等于60分的各门课程考试成绩的平均分、最高分和最低分。</p><pre><code>SELECT 课程名称,AVG(考试成绩)平均分,MAX(考试成绩)最高分,MIN(考试成绩)最低分FROM 选课 JOIN 课程 ON 选课.课程编号=课程.课程编号 WHERE 课程性质=&#39;专业基础&#39;GROUP BY 课程名称HAVING AVG(考试成绩)&gt;=60</code></pre><p>示例18查询所有专业基础课的信息，并计算其总学时。</p><pre><code>CREATE VIEW 课程_总学时(总学时)ASSELECT SUM(学时)总学时FROM 课程</code></pre><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a><strong>1NF</strong></h3><p>属性具有原子性</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a><strong>2NF</strong></h3><p>能根据主键得到表中的其他属性<br>如果是联合主键则必须是根据联合主键得到表的其他属性 而不能只是联合主键其中的一个属性得到表中的其他属性</p><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a><strong>3NF</strong></h3><p>除主键外 表中的非主键属性不能根据非主键属性得到</p><h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a><strong>BCNF</strong></h3><p>非主键属性不能根据非主键属性得到 主键属性也不能根据非主键属性得到<br>性能不行时 第一反应是再试一次<br>第二反应是优化一下SQL<br>第三反应是调大buffer pool<br>实在不行就面向搜索引擎编程了  </p><p><article><br>        <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"><br>                                            <div class="markdown_views"><br>                <h2 id="避免在-where-子句中使用或"><a name="t0"></a>避免在 where 子句中使用!=或&lt;&gt;</h2></div></div></article></p><p>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p><h2 id="优先考虑在-where-及-order-by"><a name="t1"></a>优先考虑在 where 及 order by</h2><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><h2 id="避免在-where-子句中对字段进行-null-值判断"><a name="t2"></a>避免在 where 子句中对字段进行 null 值判断</h2><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。如： <br><br>select id from t where num is null <br><br>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： <br><br>select id from t where num=0</p><h2 id="尽量避免在-where-子句中使用-or-来连接条件"><a name="t3"></a>尽量避免在 where 子句中使用 or 来连接条件，</h2><p>否则将导致引擎放弃使用索引而进行全表扫描，如： <br><br>select id from t where num=10 or num=20 <br><br>可以这样查询： <br><br>select id from t where num=10 <br><br>union all <br><br>select id from t where num=20</p><h2 id="下面的查询也将导致全表扫描不能前置百分号"><a name="t4"></a>下面的查询也将导致全表扫描：(不能前置百分号)</h2><p>select id from t where name like ‘%c%’ <br><br>下面走索引 <br><br>select id from t where name like ‘c%’ <br><br>若要提高效率，可以考虑全文检索。</p><h2 id="in-和-not-in-也要慎用"><a name="t5"></a>in 和 not in 也要慎用</h2><p>否则会导致全表扫描，如： <br><br>select id from t where num in(1,2,3) <br><br>对于连续的数值，能用 between 就不要用 in 了： <br><br>select id from t where num between 1 and 3</p><h2 id="如果在-where-子句中使用参数也会导致全表扫描"><a name="t6"></a>如果在 where 子句中使用参数，也会导致全表扫描。</h2><p>因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： <br><br>select id from t where num=@num <br><br>可以改为强制查询使用索引： <br><br>select id from t with(index(索引名)) where num=@num</p><h2 id="应尽量避免在-where-子句中对字段进行表达式操作"><a name="t7"></a>应尽量避免在 where 子句中对字段进行表达式操作</h2><p>这将导致引擎放弃使用索引而进行全表扫描。如： <br><br>select id from t where num/2=100 <br><br>应改为: <br><br>select id from t where num=100*2</p><h2 id="应尽量避免在where子句中对字段进行函数操作"><a name="t8"></a>应尽量避免在where子句中对字段进行函数操作</h2><p>这将导致引擎放弃使用索引而进行全表扫描。如： <br><br>select id from t where substring(name,1,3)=’abc’–name以abc开头的id <br><br>select id from t where datediff(day,createdate,’2005-11-30′)=0–’2005-11-30′生成的id <br><br>应改为: <br><br>select id from t where name like ‘abc%’ <br><br>select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’2005-12-1′</p><h2 id="不要在-where-子句中的左边进行函数算术运算或其他表达式运算"><a name="t9"></a>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算</h2><p>否则系统将可能无法正确使用索引。</p><h2 id="索引"><a name="t10"></a>索引</h2><p>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使 用，并且应尽可能的让字段顺序与索引顺序相一致。</p><h2 id="不要写一些没有意义的查询"><a name="t11"></a>不要写一些没有意义的查询</h2><p>如需要生成一个空表结构： <br><br>select col1,col2 into #t from t where 1=0 <br><br>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： <br><br>create table #t(…)</p><h2 id="很多时候用-exists-代替-in-是一个好的选择"><a name="t12"></a>很多时候用 exists 代替 in 是一个好的选择：</h2><p>select num from a where num in(select num from b) <br><br>用下面的语句替换： <br><br>select num from a where exists(select 1 from b where num=a.num)</p><h2 id="并不是所有索引对查询都有效"><a name="t13"></a>并不是所有索引对查询都有效</h2><p>SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p><h2 id="索引并不是越多越好"><a name="t14"></a>索引并不是越多越好</h2><p>索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</p><h2 id="应尽可能的避免更新-clustered-索引数据列"><a name="t15"></a>应尽可能的避免更新 clustered 索引数据列</h2><p>因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p><h2 id="尽量使用数字型字段"><a name="t16"></a>尽量使用数字型字段</h2><p>若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><h2 id="尽可能的使用-varcharnvarchar-代替-charnchar"><a name="t17"></a>尽可能的使用 varchar/nvarchar 代替 char/nchar</h2><p>因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><h2 id="任何地方都不要使用-select-from-t"><a name="t18"></a>任何地方都不要使用 select * from t</h2><p>用具体的字段列表代替“*”，不要返回用不到的任何字段。</p><h2 id="尽量使用表变量来代替临时表"><a name="t19"></a>尽量使用表变量来代替临时表</h2><p>如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p><h2 id="避免频繁创建和删除临时表以减少系统表资源的消耗"><a name="t20"></a>避免频繁创建和删除临时表，以减少系统表资源的消耗。</h2><h2 id="临时表并不是不可使用适当地使用它们可以使某些例程更有效"><a name="t21"></a>临时表并不是不可使用，适当地使用它们可以使某些例程更有效</h2><p>例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使 用导出表。</p><h2 id="在新建临时表时如果一次性插入数据量很大"><a name="t22"></a>在新建临时表时，如果一次性插入数据量很大</h2><p>那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p><h2 id="如果使用到了临时表"><a name="t23"></a>如果使用到了临时表</h2><p>在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p><h2 id="尽量避免使用游标"><a name="t24"></a>尽量避免使用游标</h2><p>因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p><h2 id="使用基于游标的方法或临时表方法之前应先寻找基于集的解决方案来解决问题基于集的方法通常更有效"><a name="t25"></a>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</h2><h2 id="与临时表一样游标并不是不可使用"><a name="t26"></a>与临时表一样，游标并不是不可使用。</h2><p>对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p><h2 id="存储过程和触发器"><a name="t27"></a>存储过程和触发器</h2><p>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p><h2 id="尽量避免向客户端返回大数据量若数据量过大应该考虑相应需求是否合理"><a name="t28"></a>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</h2><p></p><h2 id="尽量避免大事务操作提高系统并发能力"><a name="t29"></a>尽量避免大事务操作，提高系统并发能力。</h2>            <br>            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"><br>                <br>            <p></p><pre><code>创建表create table Employee(    id int primary key,    name varchar(20),    age int);import java.sql;public class test{    public static void main(String[] args)throws Exception{        String user = &quot;user1&quot;;        String password = &quot;pwd1&quot;;        String url = &quot;jdbc:mysql://localhost:3306/Test&quot;;        String driver = &quot;com.mysql.jdbc.Driver&quot;;        Connection con = null;        Statement stmt = null;        ResultSet rs = null;        try{            Class.forName(driver);            con = DriverManager.getConnection(url,user,password);            stmt = con.createStatement();            stmt.execute(&quot;insert into Employee values(1,&#39;James1&#39;,25)&quot;);            stmt.execute(&quot;insert into Employee values(2,&#39;James2&#39;,26)&quot;);            rs = stmt.executeQuery(&quot;select * from Employee&quot;);            while(rs.next()){                System.out.println(rs.getInt(1)+&quot; &quot;+rs.getString(s)+&quot; &quot;+rs.getInt(3));            }        }        catch(SQLException e1){            e1.printStack();        }finally{            try{                if(rs != null) rs.close();                if(stmt != null) stmt.close();                if(con != null) con.close();            }catch(SQLException e){                System.out.println(e.getMessage());            }        }    }}</code></pre><h3 id="关系表R"><a href="#关系表R" class="headerlink" title="关系表R"></a><strong>关系表R</strong></h3><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>5</td></tr><tr><td>a1</td><td>b2</td><td>6</td></tr><tr><td>a2</td><td>b3</td><td>8</td></tr><tr><td>a2</td><td>b4</td><td>12</td></tr></tbody></table><h3 id="关系表S"><a href="#关系表S" class="headerlink" title="关系表S"></a>关系表S</h3><table><thead><tr><th>B</th><th>E</th></tr></thead><tbody><tr><td>b1</td><td>3</td></tr><tr><td>b2</td><td>7</td></tr><tr><td>b3</td><td>10</td></tr><tr><td>b3</td><td>2</td></tr><tr><td>b5</td><td>2</td></tr></tbody></table><h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><table><thead><tr><th>A</th><th>B</th><th>C</th><th>E</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>5</td><td>3</td></tr><tr><td>a1</td><td>b2</td><td>6</td><td>7</td></tr><tr><td>a2</td><td>b2</td><td>8</td><td>10</td></tr><tr><td>a1</td><td>b3</td><td>8</td><td>2</td></tr></tbody></table><p>自然连接是指2个关系表R、S中相同列中有相同元素所在行的连接<br>左外连接 保留左表完整<br>右外连接 保留右表完整<br>外连接 保留左、右表完整</p><h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a><strong>操作数据库</strong></h3><p>show databases:显示所有的数据库<br>show create databases db_name:查看当前数据库的创建信息<br>drop dattabase db_name:删除某个数据库  </p><h3 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a><strong>操作表</strong></h3><p>show table table_name:查看某个表的内容<br>show tables like ‘exam_%’:查看前缀带有exam的所有表，%是通配符。<br>show create table table_name:查看某个表的创建信息<br>desc table_name:查看表结构<br>use table_name:用某个表<br>drop table table_name : 删除表<br>rename table A_table to B_table:修改表名称<br>rename table A to B , C to D..:可批量修改  </p><h3 id="操作数据"><a href="#操作数据" class="headerlink" title="操作数据"></a><strong>操作数据</strong></h3><p>insert into 表名 (字段) values (值)：为字段增加值<br>insert into 表名 values   (值……)：为所有的字段插入值，可以不写字段名，但是值得顺序要和表中字段的顺序一致<br>select  字段列表 from 表名 查询条件：查询数据<br>select name,age from student where stu_num=0001;查询学号为0001的学生的姓名和年龄<br>字段列表可用<code>*</code>代替，表示所有字段<br>select * from student where stu_num=111;查询出学号为111的学生的所有信息<br>delete from 表名  条件：删除数据<br>update 表名 set 条件：修改数据<br>update student set score=100 where score=70;   把student表中所有分数为70的改为分数100     </p><h2 id="如果让你设计一个数据库连接池，你可能会考虑到哪些方面的问题？"><a href="#如果让你设计一个数据库连接池，你可能会考虑到哪些方面的问题？" class="headerlink" title="如果让你设计一个数据库连接池，你可能会考虑到哪些方面的问题？"></a><strong>如果让你设计一个数据库连接池，你可能会考虑到哪些方面的问题？</strong></h2><p>需要统一实现javax.sql.DataSource接口，以适应于不同的场合。<br>连接被动关闭问题。为了保证连接的复用性，将连接一直保存在池中。有些数据库服务器会将已经连接很久的客户端连接主动踢掉，如果碰到这种情况，在池中的这个连接池就会变为不可用状态，如果客户端使用的话将会抛出连接被关闭的SQLException。<br>及时地将不需要使用的连接关闭还给数据库服务器，保留一些基本连接数。<br>网络中断能自动重连</p><h3 id="minus"><a href="#minus" class="headerlink" title="minus"></a><strong>minus</strong></h3><p>使用该操作符用于取得两个结果集的差集，他只会显示存在第一个集合中，而不存在第二个集合中的数据。<br>SELECT ename, sal, job FROM emp WHERE sal &gt;2500<br>MINUS<br>SELECT ename, sal, job FROM emp WHERE job = ‘MANAGER’;<br>（MINUS就是减法的意思）   </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux与Shell脚本编程</title>
      <link href="/2018/09/18/2018-9-18-Shell%E8%84%9A%E6%9C%AC/"/>
      <url>/2018/09/18/2018-9-18-Shell%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux内核的功能"><a href="#Linux内核的功能" class="headerlink" title="Linux内核的功能"></a><strong>Linux内核的功能</strong></h2><pre><code>①系统内存管理  ②软件程序管理  ③硬件设备管理  ④文件系统管理  </code></pre><p>GNU coreutils软件包由三部分构成：用以处理文件、操作文本、管理进程的工具<br>GNU/Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在Linux系统上的进程的途径。  </p><h2 id="进入文本命令行的快捷键"><a href="#进入文本命令行的快捷键" class="headerlink" title="进入文本命令行的快捷键"></a><strong>进入文本命令行的快捷键</strong></h2><p>Linux发行版通常使用Ctrl+Alt组合键配合F1或F7来进入图形界面。Ubuntu使用了F7，而RHEL则使用F1.最好还是测试一下自己所使用的发行版是如何进入图形界面的。</p><h2 id="etc-passwd文件的字段包含与用户有关的信息"><a href="#etc-passwd文件的字段包含与用户有关的信息" class="headerlink" title="/etc/passwd文件的字段包含与用户有关的信息"></a><strong>/etc/passwd文件的字段包含与用户有关的信息</strong></h2><pre><code>登录用户名  用户密码（/etc/passwd文件中的密码字段都被设置成了x，即隐藏了密码，      密码单独保存在etc/shadow文件中）  用户账户的UID（数字形式）  用户账户的组ID（GID）（数字形式）  用户账户的文本描述（称为备注字段）  用户HOME目录的位置  用户的默认shell  </code></pre><h2 id="etc-shadow文件是对Linux系统密码管理"><a href="#etc-shadow文件是对Linux系统密码管理" class="headerlink" title="/etc/shadow文件是对Linux系统密码管理"></a><strong>/etc/shadow文件是对Linux系统密码管理</strong></h2><pre><code>与/etc/passwd文件中的登录名字段对应的登录名加密后的密码自上次修改密码后过去的天数密码（自1970年1月1日开始计算）多少天后才能更改密码多少天后必须更改密码密码过期前提前多少天提醒用户更改密码密码过期后多少天禁用用户账户用户账户被禁用的日期（用自1970年1月1日到当天的天数表示）预留字段给将来使用</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URL</title>
      <link href="/2018/09/18/2018-9-18-URL/"/>
      <url>/2018/09/18/2018-9-18-URL/</url>
      
        <content type="html"><![CDATA[<h3 id="三种连接方法"><a href="#三种连接方法" class="headerlink" title="三种连接方法"></a><strong>三种连接方法</strong></h3><pre><code>// 方法一            URL url = new URL(&quot;http://www.sina.com.cn&quot;);           URLConnection urlcon = url.openConnection();           InputStream is = urlcon.getInputStream();            // 方法二           URL url = new URL(&quot;http://www.yhfund.com.cn&quot;);           HttpURLConnection urlcon = (HttpURLConnection)url.openConnection();           InputStream is = urlcon.getInputStream();           //方法三           URL url = new URL(&quot;http://www.yhfund.com.cn&quot;);           InputStream is = url.openStream();</code></pre><h3 id="具体测试例子"><a href="#具体测试例子" class="headerlink" title="具体测试例子"></a><strong>具体测试例子</strong></h3><pre><code>import java.io.*;import java.net.*;public class url {    public static void main(String[] args) {    try{    long begintime = System.currentTimeMillis();        URL url = new URL(&quot;http://www.yhfund.com.cn&quot;);        HttpURLConnection urlcon = (HttpURLConnection)url.openConnection();        urlcon.connect();         //获取连接        InputStream is =  urlcon.getInputStream();        BufferedReader buffer = new BufferedReader(new InputStreamReader(is));        StringBuffer bs = new StringBuffer();        String l = null;        while((l=buffer.readLine())!=null){            bs.append(l).append(&quot;/n&quot;);        }        System.out.println(bs.toString());        System.out.println(&quot; content-encode：&quot;+urlcon.getContentEncoding());        System.out.println(&quot; content-length：&quot;+urlcon.getContentLength());        System.out.println(&quot; content-type：&quot;+urlcon.getContentType());        System.out.println(&quot; date：&quot;+urlcon.getDate());        System.out.println(&quot;总共执行时间为：&quot;+(System.currentTimeMillis()-begintime)+&quot;毫秒&quot;);     }catch(IOException e){        System.out.println(e);    }    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Annotation</title>
      <link href="/2018/09/18/2018-9-18-annotation/"/>
      <url>/2018/09/18/2018-9-18-annotation/</url>
      
        <content type="html"><![CDATA[<p>三个基本的Annotation如下：<br>@Override         限定必须重写父类的方法<br>@Deprecated     标示已过时<br>@SuppressWarnings     抑制编译器警告  </p><h3 id="自定义anotation"><a href="#自定义anotation" class="headerlink" title="自定义anotation"></a><strong>自定义anotation</strong></h3><p>1.标记Annotation： 一个没有成员定义的Annotation类型被称为标记。这种Annotation仅使用自身的存在与否来为我们提供信息。如前面介绍的@Override。</p><pre><code>/** * 定义一个Annotation */public @interface Login {}class LoginTest{    /**     * 使用Annotation     */    @Login　　 public void login(){    }}</code></pre><p>2.元数据Annotation：那些包含成员变量的Annotation，因为它们可接受更多元数据，所以也被称为元数据Annotation。</p><pre><code>/** * 定义一个注解 */public @interface Login {    //定义两个成员变量    //以default为两个成员变量指定初始值    String username() default &quot;zhangsan&quot;;    String password() default &quot;123456&quot;;}class LoginTest{    /**     * 使用注解　　　* 因为它的成员变量有默认值，所以可以无须为成员变量指定值，而直接使用默认值     */    @Login    public void login(){    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket</title>
      <link href="/2018/09/18/2018-9-18-Socket/"/>
      <url>/2018/09/18/2018-9-18-Socket/</url>
      
        <content type="html"><![CDATA[<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a><strong>Socket</strong></h2><h4 id="服务端线程"><a href="#服务端线程" class="headerlink" title="服务端线程"></a><strong>服务端线程</strong></h4><pre><code>import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.PrintWriter;import java.net.Socket;/** * Socket多线程处理类 用来处理服务端接收到的客户端请求（处理Socket对象） */public class SocketThread extends Thread {    private Socket socket;    public SocketThread(Socket socket) {        this.socket = socket;    }    public void run() {        // 根据输入输出流和客户端连接        try {            InputStream inputStream = socket.getInputStream();            // 得到一个输入流，接收客户端传递的信息            InputStreamReader inputStreamReader = new InputStreamReader(                    inputStream);// 提高效率，将自己字节流转为字符流            BufferedReader bufferedReader = new BufferedReader(                    inputStreamReader);// 加入缓冲区            String temp = null;            String info = &quot;&quot;;            while ((temp = bufferedReader.readLine()) != null) {                info += temp;                System.out.println(&quot;已接收到客户端连接&quot;);                System.out.println(&quot;服务端接收到客户端信息：&quot; + info + &quot;,当前客户端ip为：&quot;                        + socket.getInetAddress().getHostAddress());            }            OutputStream outputStream = socket.getOutputStream();// 获取一个输出流，向服务端发送信息            PrintWriter printWriter = new PrintWriter(outputStream);// 将输出流包装成打印流            printWriter.print(&quot;你好，服务端已接收到您的信息&quot;);            printWriter.flush();            socket.shutdownOutput();// 关闭输出流            // 关闭相对应的资源            bufferedReader.close();            inputStream.close();            printWriter.close();            outputStream.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><strong>服务端</strong></h4><pre><code>import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;public class Server {    /**     * Socket服务端     */    public static void main(String[] args) {        try {            ServerSocket serverSocket = new ServerSocket(8888);            System.out.println(&quot;服务端已启动，等待客户端连接..&quot;);            while (true) {                Socket socket = serverSocket.accept();// 侦听并接受到此套接字的连接,返回一个Socket对象                SocketThread socketThread = new SocketThread(socket);                socketThread.start();            }        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><strong>客户端</strong></h4><pre><code>import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.PrintWriter;import java.net.Socket;import java.net.UnknownHostException;public class Client {    /**     * Socket客户端     */    public static void main(String[] args) {        try {            //创建Socket对象            Socket socket=new Socket(&quot;localhost&quot;,8888);                        //根据输入输出流和服务端连接            OutputStream outputStream=socket.getOutputStream();//获取一个输出流，向服务端发送信息            PrintWriter printWriter=new PrintWriter(outputStream);//将输出流包装成打印流            printWriter.print(&quot;服务端你好，我是客户1&quot;);            printWriter.flush();            socket.shutdownOutput();//关闭输出流                        InputStream inputStream=socket.getInputStream();//获取一个输入流，接收服务端的信息            InputStreamReader inputStreamReader=new InputStreamReader(inputStream);//包装成字符流，提高效率            BufferedReader bufferedReader=new BufferedReader(inputStreamReader);//缓冲区            String info=&quot;&quot;;            String temp=null;//临时变量            while((temp=bufferedReader.readLine())!=null){                info+=temp;                System.out.println(&quot;客户端接收服务端发送信息：&quot;+info);            }                        //关闭相对应的资源            bufferedReader.close();            inputStream.close();            printWriter.close();            outputStream.close();            socket.close();        } catch (UnknownHostException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><h3 id="Socket服务端"><a href="#Socket服务端" class="headerlink" title="Socket服务端"></a><strong>Socket服务端</strong></h3><pre><code>import java.io.*;import java.net.*;import java.applet.Applet;public class talkserver{    public static void main(String args[])    {        try        {            ServerSocket server = null;            try            {                server = new ServerSocket(4700);            }catch(Exception e)            {                System.out.println(&quot;can not listen to:&quot; + e);            }            Socket socket = null;            try            {                socket = server.accept();            }catch(Exception e)            {                System.out.println(&quot;Error:&quot; + e);            }            String line;            BufferedReader is = new BufferedReader(new InputStreamReader(                socket.getInputStream()));            PrintWriter os = new PrintWriter(socket.getOutputStream());            BufferedReader sin = new BufferedReader(new InputStreamReader(System.in));            System.out.println(&quot;Client:&quot; + is.readLine());            line = sin.readLine();            while (!line.equals(&quot;bye&quot;))                {                os.println(line);                os.flush();                System.out.println(&quot;Server:&quot; + line);                System.out.println(&quot;Client:&quot; + is.readLine());                line = sin.readLine();            }            is.close();            os.close();            socket.close();            server.close();        }catch(Exception e)        {            System.out.println(&quot;Error&quot; + e);        }    }}</code></pre><h3 id="Socket客户端"><a href="#Socket客户端" class="headerlink" title="Socket客户端"></a><strong>Socket客户端</strong></h3><pre><code>import java.io.*;import java.net.*;public class talkclient{    public static void main(String args[])    {        try        {            Socket socket = new Socket(&quot;127.0.0.1&quot;,4700);            BufferedReader sin = new BufferedReader(new InputStreamReader(System.in));            PrintWriter os = new PrintWriter(socket.getOutputStream());            BufferedReader is = new BufferedReader(new InputStreamReader(                socket.getInputStream()));            String readline;            readline = sin.readLine();            while (!readline.equals(&quot;bye&quot;))                {                os.println(readline);                os.flush();                System.out.println(&quot;Client:&quot; + readline);                System.out.println(&quot;Server:&quot; + is.readLine());                readline = sin.readLine();            }            os.close();            is.close();            socket.close();        }catch(Exception e)        {            System.out.println(&quot;Error&quot; + e);        }    }}</code></pre><h3 id="TCP服务端"><a href="#TCP服务端" class="headerlink" title="TCP服务端"></a><strong>TCP服务端</strong></h3><pre><code>import java.net.*;import java.io.*;public class TCPServer {    public static void main(String[] args) throws Exception {        ServerSocket ss = new ServerSocket(6666);        while(true) {            Socket s = ss.accept();System.out.println(&quot;a client connect!&quot;);            DataInputStream dis = new DataInputStream(s.getInputStream());            System.out.println(dis.readUTF());            dis.close();            s.close();        }    }}</code></pre><h3 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a><strong>TCP客户端</strong></h3><pre><code>import java.net.*;import java.io.*;public class TCPClient {    public static void main(String[] args) throws Exception {        Socket s = new Socket(&quot;127.0.0.1&quot;, 6666);        OutputStream os = s.getOutputStream();        DataOutputStream dos = new DataOutputStream(os);        Thread.sleep(30000);        dos.writeUTF(&quot;hello server!&quot;);        dos.flush();        dos.close();        s.close();    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型与可变参数</title>
      <link href="/2018/09/18/2018-9-18-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"/>
      <url>/2018/09/18/2018-9-18-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="协变与逆变"><a href="#协变与逆变" class="headerlink" title="协变与逆变"></a><strong>协变与逆变</strong></h3><p>协变：子类当作父类使用，安全，因为父类的功能子类都有，所以子类可以当作父类使用<br>逆变：父类当作子类使用，不安全，因为子类的部分功能父类没有</p><h3 id="定义泛型方法，只需将泛型参数列表置于返回值之前"><a href="#定义泛型方法，只需将泛型参数列表置于返回值之前" class="headerlink" title="定义泛型方法，只需将泛型参数列表置于返回值之前"></a><strong>定义泛型方法，只需将泛型参数列表置于返回值之前</strong></h3><pre><code>public class GenericMethods {//当方法操作的引用数据类型不确定的时候，可以将泛型定义在方法上    public &lt;T&gt; void f(T x){        System.out.println(x.getClass().getName());    }    public static void main(String[] args) {        GenericMethods gm = new GenericMethods();        gm.f(99);        gm.f(&quot;你好&quot;);        gm.f(new Integer(99));        gm.f(18.88);        gm.f(&#39;a&#39;);        gm.f(gm);    }}/* 输出结果：java.lang.Integerjava.lang.Stringjava.lang.Integerjava.lang.Doublejava.lang.CharacterGenerics.GenericMethods */</code></pre><h3 id="可变参数与泛型方法"><a href="#可变参数与泛型方法" class="headerlink" title="可变参数与泛型方法"></a><strong>可变参数与泛型方法</strong></h3><pre><code>import java.util.ArrayList;import java.util.List;public class GenericVarargs {    public static &lt;T&gt; List&lt;T&gt; makeList(T... args){        List&lt;T&gt; result = new ArrayList&lt;T&gt;();        for(T item:args)            result.add(item);        return result;             }    public static void main(String[] args) {        List ls = makeList(&quot;A&quot;);        System.out.println(ls);        ls = makeList(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;);        System.out.println(ls);        ls = makeList(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.split(&quot;&quot;));        System.out.println(ls);    }}/*[A][A, B, C][A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z]*/</code></pre><h3 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a><strong>泛型的好处</strong></h3><p>泛型的一个重要好处是能够简单而安全地创建复杂的模型。如List元组。</p><pre><code>package Generics;import java.util.ArrayList;class ThreeTuple2&lt;A,B,C&gt;{    public final A first;    public final B second;    private final C three;    public ThreeTuple2(A a,B b,C c){        first = a;        second = b;        three = c;    }    public String toString(){        return &quot;(&quot; + first + &quot;,&quot; + second + &quot;,&quot; + three + &quot;)&quot;;    }}public class TupleList&lt;A,B,C&gt; extends ArrayList&lt;ThreeTuple2&lt;A,B,C&gt;&gt; {    static ThreeTuple2&lt;Integer,String,Character&gt; h(){        return new ThreeTuple2&lt;Integer,String,Character&gt;(99,&quot;掌上洪城&quot;,&#39;a&#39;);    }    public static void main(String[] args) {        TupleList&lt;Integer,String,Character&gt; ts = new TupleList&lt;Integer,String,Character&gt;();        ts.add(h());        ts.add(h());        for(ThreeTuple2&lt;Integer,String,Character&gt; ttp:ts)        System.out.println(ttp);            }}/* 输出结果为：(99,掌上洪城,a)(99,掌上洪城,a) */</code></pre><h3 id="泛型限定（上限和下限）的表达式是怎样的？"><a href="#泛型限定（上限和下限）的表达式是怎样的？" class="headerlink" title="泛型限定（上限和下限）的表达式是怎样的？"></a><strong>泛型限定（上限和下限）的表达式是怎样的？</strong></h3><p>上限：？extends E：可以接收E类型或者E的子类型对象。<br>下限：？super E：可以接收E类型或者E的父类型对象。<br>上限什么时候用：往集合中添加元素时，既可以添加E类型对象，又可以添加E的子类型对象。为什么？因为取的时候，E类型既可以接收E类对象，又可以接收E的子类型对象。<br>下限什么时候用：当从集合中获取元素进行操作的时候，可以用当前元素的类型接收，也可以用当前元素的父类型接收。  </p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a><strong>可变参数</strong></h3><p>可变参数的特点：<br>（1）、只能出现在参数列表的最后；<br>（2）、…位于变量类型和变量名之间，前后有无空格都可以；<br>（3）、调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中一数组的形式访问可变参数。  </p><pre><code>public class Varable { public static void main(String [] args){  System.out.println(add(2,3));  System.out.println(add(2,3,5)); } public static int add(int x,int ...args){  int sum=x;  for(int i=0;i&lt;args.length;i++){   sum+=args[i];  }  return sum; }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux上安装软件</title>
      <link href="/2018/09/18/2018-9-18-Linux%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/"/>
      <url>/2018/09/18/2018-9-18-Linux%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="PMS"><a href="#PMS" class="headerlink" title="PMS"></a>PMS</h3><pre><code>PMS利用一个数据库来记录各种相关内容  Linux系统上已经安装了什么软件包  每个包安装了什么文件  每个已安装软件包的版本  </code></pre><p>软件包存储在服务器上，可以利用本地Linux系统上的PMS工具通过互联网访问。这些服务器称为仓库（repository）。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux，Git，vi</title>
      <link href="/2018/09/18/2018-9-18-Linux/"/>
      <url>/2018/09/18/2018-9-18-Linux/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a><strong>Linux</strong></h2><p>肯汤姆孙 里奇 <strong>unix</strong><br>大学教授 塔能鲍勃 <strong>mini-unix</strong><br>linus <strong>linux</strong><br><strong>安卓</strong> =linux + java + 其他<br><strong>linux中除了home文件夹其他的最好不改动</strong>  在用户的家目录中用户可以随意修改<br><strong>打开终端（ctrl+alt+T）时默认的最顶层</strong>是用户的家目录<br>linux没有分盘 只有一个home 下分多个用户  </p><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a><strong>touch</strong></h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a><strong>创建文件</strong></h3><p>touch 加文件名</p><h3 id="创建隐藏文件"><a href="#创建隐藏文件" class="headerlink" title="创建隐藏文件"></a><strong>创建隐藏文件</strong></h3><p>touch .a.txt  </p><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a><strong>ls</strong></h2><h3 id="以列表显示详细信息"><a href="#以列表显示详细信息" class="headerlink" title="以列表显示详细信息"></a><strong>以列表显示详细信息</strong></h3><p>ls -l </p><h3 id="以带单位的格式显示信息"><a href="#以带单位的格式显示信息" class="headerlink" title="以带单位的格式显示信息"></a><strong>以带单位的格式显示信息</strong></h3><p>ls -h </p><h3 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a><strong>帮助文档</strong></h3><p>ls –help </p><h3 id="帮助文档-1"><a href="#帮助文档-1" class="headerlink" title="帮助文档"></a><strong>帮助文档</strong></h3><p>man ls<br>用q <strong>退出帮助文档</strong><br>b <strong>上一页</strong><br>f <strong>下一页</strong><br>共有8个man 帮助文档 用 man 2 ls 这样的格式来查看不同版本的文档</p><h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a><strong>查看文件</strong></h3><p>cat 文件名 (派一只猫去看看文件内容)  </p><h3 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a><strong>历史命令</strong></h3><p>history<br>使用 !+命令编号（history显示出来的编号） 可以执行该编号对应的命令  </p><h3 id="显示以2开头的文件"><a href="#显示以2开头的文件" class="headerlink" title="显示以2开头的文件"></a><strong>显示以2开头的文件</strong></h3><p>ls 2*</p><h3 id="显示开头结尾1-5中间是2、3、4的文件"><a href="#显示开头结尾1-5中间是2、3、4的文件" class="headerlink" title="显示开头结尾1 5中间是2、3、4的文件"></a><strong>显示开头结尾1 5中间是2、3、4的文件</strong></h3><p>ls 1[234]5 </p><h3 id="重定向-："><a href="#重定向-：" class="headerlink" title="重定向 ："></a><strong>重定向 ：</strong></h3><p>ls &gt; xxx.txt  会覆盖原来的内容</p><h3 id="把ls所显示的内容存入到xxx文件中"><a href="#把ls所显示的内容存入到xxx文件中" class="headerlink" title="把ls所显示的内容存入到xxx文件中"></a><strong>把ls所显示的内容存入到xxx文件中</strong></h3><p>ls &gt;&gt; xxx.txt  追加</p><h3 id="more可以分屏显示-按b-或-f-切换上下屏"><a href="#more可以分屏显示-按b-或-f-切换上下屏" class="headerlink" title="more可以分屏显示 按b 或 f 切换上下屏"></a><strong>more可以分屏显示 按b 或 f 切换上下屏</strong></h3><p>more xxx.txt<br>ls -lah | more 显示的内容分屏<br><strong>ls 显示的文件中白色的表明是个文件 蓝色的表明是个文件夹</strong></p><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a><strong>cd</strong></h2><h3 id="会显示该目录下的所有文件，用以帮助提示用户"><a href="#会显示该目录下的所有文件，用以帮助提示用户" class="headerlink" title="会显示该目录下的所有文件，用以帮助提示用户"></a><strong>会显示该目录下的所有文件，用以帮助提示用户</strong></h3><p><strong>cd / +敲2次tab</strong> </p><h3 id="切换到上一层目录"><a href="#切换到上一层目录" class="headerlink" title="切换到上一层目录"></a><strong>切换到上一层目录</strong></h3><p><strong>cd ..</strong> </p><h3 id="切换到上一层目录后再切换到上一层目录"><a href="#切换到上一层目录后再切换到上一层目录" class="headerlink" title="切换到上一层目录后再切换到上一层目录"></a><strong>切换到上一层目录后再切换到上一层目录</strong></h3><p><strong>cd ../..</strong> </p><h3 id="切换到上次所在的路径"><a href="#切换到上次所在的路径" class="headerlink" title="切换到上次所在的路径"></a><strong>切换到上次所在的路径</strong></h3><p><strong>cd -</strong> </p><h3 id="快速回到根目录"><a href="#快速回到根目录" class="headerlink" title="快速回到根目录"></a><strong>快速回到根目录</strong></h3><p><strong>cd ~</strong> </p><h3 id="以树形结构显示内容"><a href="#以树形结构显示内容" class="headerlink" title="以树形结构显示内容"></a><strong>以树形结构显示内容</strong></h3><p><strong>tree</strong> </p><h3 id="连续创建多个文件夹-："><a href="#连续创建多个文件夹-：" class="headerlink" title="连续创建多个文件夹 ："></a><strong>连续创建多个文件夹 ：</strong></h3><p>mkdir a/b/c/d -p</p><h3 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a><strong>删除文件夹</strong></h3><p>rm a -r</p><h3 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a><strong>重命名文件</strong></h3><p>mv 原文件名 新文件名</p><h3 id="创建快捷方式（软链接）"><a href="#创建快捷方式（软链接）" class="headerlink" title="创建快捷方式（软链接）"></a><strong>创建快捷方式（软链接）</strong></h3><p>ln -s 文件名 快捷方式名<br>该快捷方式的引用执行之前的文件而非数据域，如果之前的文件没有了 那么改快捷方式文件就没用了  </p><h3 id="硬链接文件"><a href="#硬链接文件" class="headerlink" title="硬链接文件"></a><strong>硬链接文件</strong></h3><p>ln 文件名 硬链接文件名<br>该快捷方式指向了之前文件的数据域<br>每个数据域都会有个属性记录硬链接数，当该数等于0时，数据才会被操作系统释放  </p><h3 id="把1-txt-和2-txt-复制到3-txt"><a href="#把1-txt-和2-txt-复制到3-txt" class="headerlink" title="把1.txt 和2.txt 复制到3.txt"></a><strong>把1.txt 和2.txt 复制到3.txt</strong></h3><p>cat 1.txt 2.txt &gt; 3.txt</p><h3 id="在q-txt中查找包含aaa字段的内容"><a href="#在q-txt中查找包含aaa字段的内容" class="headerlink" title="在q.txt中查找包含aaa字段的内容"></a><strong>在q.txt中查找包含aaa字段的内容</strong></h3><p>grep “aaa”  q.txt</p><h3 id="在q-txt中查找不包含aaa字段的内容"><a href="#在q-txt中查找不包含aaa字段的内容" class="headerlink" title="在q.txt中查找不包含aaa字段的内容"></a><strong>在q.txt中查找不包含aaa字段的内容</strong></h3><p>grep -v “aa”  q.txt</p><h3 id="在q-txt中查找包含aaa字段的内容-并显示行号"><a href="#在q-txt中查找包含aaa字段的内容-并显示行号" class="headerlink" title="在q.txt中查找包含aaa字段的内容 并显示行号"></a><strong>在q.txt中查找包含aaa字段的内容 并显示行号</strong></h3><p>grep -n “aa”  q.txt</p><h3 id="在q-txt中查找包含aaa字段开头的内容-表示以xxx结尾的内容"><a href="#在q-txt中查找包含aaa字段开头的内容-表示以xxx结尾的内容" class="headerlink" title="在q.txt中查找包含aaa字段开头的内容 $表示以xxx结尾的内容"></a><strong>在q.txt中查找包含aaa字段开头的内容 $表示以xxx结尾的内容</strong></h3><p>grep “^aa”  q.txt</p><h3 id="剪切文件并粘贴到其他目录"><a href="#剪切文件并粘贴到其他目录" class="headerlink" title="剪切文件并粘贴到其他目录"></a><strong>剪切文件并粘贴到其他目录</strong></h3><p>mv 文件名 目录名</p><h3 id="以管理员的身份-在根目录-根据名称查找内容"><a href="#以管理员的身份-在根目录-根据名称查找内容" class="headerlink" title="以管理员的身份 在根目录 根据名称查找内容"></a><strong>以管理员的身份 在根目录 根据名称查找内容</strong></h3><p>sudo fing / -name “name”<br>-size 1G 表示根据大小查找大小为1G的文件<br>-perm 777 表示权限为777的文件  </p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a><strong>打包</strong></h3><p>tar -cvf 包名.tar 被打包的文件路径</p><h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a><strong>解包</strong></h3><p>tar -xvf 包名.tar</p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a><strong>压缩</strong></h3><p>tar -zcvf 包名.tar.gz 被打包的文件路径</p><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a><strong>解压缩</strong></h3><p>tar -zxvf 包名.tar.gz</p><h3 id="解压到指定目录"><a href="#解压到指定目录" class="headerlink" title="解压到指定目录"></a><strong>解压到指定目录</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-18/linux.png" alt="enter description here"></p><h3 id="查看某个命令在哪个目录下"><a href="#查看某个命令在哪个目录下" class="headerlink" title="查看某个命令在哪个目录下"></a><strong>查看某个命令在哪个目录下</strong></h3><p>which ls</p><h3 id="查看日历"><a href="#查看日历" class="headerlink" title="查看日历"></a><strong>查看日历</strong></h3><p>cal</p><h3 id="查看某一年日历"><a href="#查看某一年日历" class="headerlink" title="查看某一年日历"></a><strong>查看某一年日历</strong></h3><p>cal -y 2008</p><h3 id="查看时间"><a href="#查看时间" class="headerlink" title="查看时间"></a><strong>查看时间</strong></h3><p>date</p><h3 id="查看当前终端下开的进程"><a href="#查看当前终端下开的进程" class="headerlink" title="查看当前终端下开的进程"></a><strong>查看当前终端下开的进程</strong></h3><p>ps</p><h3 id="查看所有进程"><a href="#查看所有进程" class="headerlink" title="查看所有进程"></a><strong>查看所有进程</strong></h3><p>ps -aux</p><h3 id="动态显示进程情况"><a href="#动态显示进程情况" class="headerlink" title="动态显示进程情况"></a><strong>动态显示进程情况</strong></h3><p>top</p><h3 id="比top更好地显示情况"><a href="#比top更好地显示情况" class="headerlink" title="比top更好地显示情况"></a><strong>比top更好地显示情况</strong></h3><p>htop</p><h3 id="退出当前用户"><a href="#退出当前用户" class="headerlink" title="退出当前用户"></a><strong>退出当前用户</strong></h3><p>exit</p><h3 id="进入其他用户"><a href="#进入其他用户" class="headerlink" title="进入其他用户"></a><strong>进入其他用户</strong></h3><p>su 用户名</p><h3 id="查看用户密码"><a href="#查看用户密码" class="headerlink" title="查看用户密码"></a><strong>查看用户密码</strong></h3><p>sudo password 用户名</p><h3 id="远程登陆用户"><a href="#远程登陆用户" class="headerlink" title="远程登陆用户"></a><strong>远程登陆用户</strong></h3><p>ssh 远程用户名@远程的ip</p><h2 id="vi"><a href="#vi" class="headerlink" title="vi "></a><strong>vi </strong></h2><h3 id="保存退出"><a href="#保存退出" class="headerlink" title="保存退出"></a><strong>保存退出</strong></h3><p>wq </p><h3 id="进入命令行模式"><a href="#进入命令行模式" class="headerlink" title="进入命令行模式"></a><strong>进入命令行模式</strong></h3><p>vim aa.py<br>再接着输入i <strong>进入编辑模式</strong><br>i <strong>在光标前面插入</strong><br>a <strong>在光标后面</strong><br>o<strong>表示换行后插入</strong><br>I <strong>在行首插入</strong><br>A <strong>在行尾插入</strong><br>O<strong>在上一行插入</strong><br>esc <strong>回到命令模式</strong><br>输入: <strong>进入末行模式</strong><br>yy <strong>复制</strong><br>p <strong>粘贴</strong><br>dd <strong>删除一行</strong><br>4yy <strong>复制包括光标所在行的4行内容</strong><br><strong>下一页 上一页</strong>ctrl f ctrl b<br>20G <strong>快速定位到第20行代码</strong><br>G<strong>最后一行代码</strong><br>w<strong>向后跳到下一个单词</strong><br>b<strong>向前跳</strong><br>u<strong>撤销</strong><br>ctrl r <strong>反撤销</strong><br>D<strong>至行尾删除</strong><br>d0<strong>至行首删除</strong><br>x<strong>删除后面</strong><br>X<strong>删除前面</strong>   </p><h3 id="开启图形界面命令"><a href="#开启图形界面命令" class="headerlink" title="开启图形界面命令"></a><strong>开启图形界面命令</strong></h3><p>startx</p><h3 id="用户注销"><a href="#用户注销" class="headerlink" title="用户注销"></a><strong>用户注销</strong></h3><p> logout</p><h3 id="进入Hello-java文件"><a href="#进入Hello-java文件" class="headerlink" title="进入Hello.java文件"></a><strong>进入Hello.java文件</strong></h3><p> VI Hello.java（编写文件名为Hello的java程序,没有则创建）</p><h3 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a><strong>进入插入模式</strong></h3><p>  输入 I  大写的 i</p><h3 id="进入-命令模式"><a href="#进入-命令模式" class="headerlink" title="进入 命令模式"></a><strong>进入 命令模式</strong></h3><p>输入esc</p><h3 id="保存并退出-wq-退出不保存-q"><a href="#保存并退出-wq-退出不保存-q" class="headerlink" title="保存并退出 wq  退出不保存 q!"></a><strong>保存并退出 wq  退出不保存 q!</strong></h3><p>输入 ：[wq] 或： [q!]</p><h3 id="在终端编译-c程序"><a href="#在终端编译-c程序" class="headerlink" title="在终端编译 c程序"></a><strong>在终端编译 c程序</strong></h3><p>第一种 输入 gcc Hello.c 即可  编译完的文件有系统自动命名 为 a.out<br><img src="https://viabcde.github.io/images/2018-09-28/2018092801.png" alt="enter description here"><br>第二种编译后自定义名字<br>输入 gcc -o my1 Hello.cpp 即可<br><img src="https://viabcde.github.io/images/2018-09-28/2018092802.png" alt="enter description here"></p><h3 id="运行c程序-a-out-即打开a-out"><a href="#运行c程序-a-out-即打开a-out" class="headerlink" title="运行c程序 ./a.out 即打开a.out"></a><strong>运行c程序 ./a.out 即打开a.out</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092803.png" alt="enter description here"></p><h3 id="Home目录下各个文件存放的内容"><a href="#Home目录下各个文件存放的内容" class="headerlink" title="Home目录下各个文件存放的内容"></a><strong>Home目录下各个文件存放的内容</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092804.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092805.png" alt="enter description here"></p><h3 id="只能root用户来设置-设置用户进入系统的运行级别"><a href="#只能root用户来设置-设置用户进入系统的运行级别" class="headerlink" title="只能root用户来设置 设置用户进入系统的运行级别"></a><strong>只能root用户来设置 设置用户进入系统的运行级别</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092806.png" alt="enter description here"></p><h3 id="运行级别怎么改回来"><a href="#运行级别怎么改回来" class="headerlink" title="运行级别怎么改回来"></a><strong>运行级别怎么改回来</strong></h3><p>在开机的时候 按 e<br>选择第二行 按 e<br><img src="https://viabcde.github.io/images/2018-09-28/2018092807.png" alt="enter description here"><br>输入空格+ 1<br>因为只有 1 单用户级别 系统才不会去读取 inittab文件 再进入后 再改 </p><h3 id="bug-单用户级别可以改用户的密码"><a href="#bug-单用户级别可以改用户的密码" class="headerlink" title="bug  单用户级别可以改用户的密码"></a><strong>bug  单用户级别可以改用户的密码</strong></h3><p>直接进行设置密码操作 但不用像其他用户一样要输入原来的密码才能更改密码<br><img src="https://viabcde.github.io/images/2018-09-28/2018092808.png" alt="enter description here"><br>回车 按 b 即可进入单用户模式<br><img src="https://viabcde.github.io/images/2018-09-28/2018092809.png" alt="enter description here"></p><h3 id="用户所属组的信息存放在etc-group文件夹下"><a href="#用户所属组的信息存放在etc-group文件夹下" class="headerlink" title="用户所属组的信息存放在etc/group文件夹下"></a><strong>用户所属组的信息存放在etc/group文件夹下</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092810.png" alt="enter description here"></p><h3 id="挂载iso文件"><a href="#挂载iso文件" class="headerlink" title="挂载iso文件"></a><strong>挂载iso文件</strong></h3><p>在虚拟机上传iso文件<br><img src="https://viabcde.github.io/images/2018-09-28/2018092811.png" alt="enter description here"></p><h3 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a><strong>安装jdk</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092812.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092813.png" alt="enter description here"></p><h3 id="安装eclipse"><a href="#安装eclipse" class="headerlink" title="安装eclipse"></a><strong>安装eclipse</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092814.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092815.png" alt="enter description here"></p><h3 id="安装myeclipse"><a href="#安装myeclipse" class="headerlink" title="安装myeclipse"></a><strong>安装myeclipse</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092816.png" alt="enter description here"></p><h3 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a><strong>安装Tomcat</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092817.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092818.png" alt="enter description here"></p><h3 id="制作镜像文件步骤"><a href="#制作镜像文件步骤" class="headerlink" title="制作镜像文件步骤"></a><strong>制作镜像文件步骤</strong></h3><p>安装WINISO<br>打开将需要做成镜像文件的文件拖进窗口<br><img src="https://viabcde.github.io/images/2018-09-28/2018092819.png" alt="enter description here"><br>保存即可</p><h3 id="查看磁盘及分区情况"><a href="#查看磁盘及分区情况" class="headerlink" title="查看磁盘及分区情况"></a><strong>查看磁盘及分区情况</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092820.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092821.png" alt="enter description here"></p><h3 id="将boot下的文件卸载-即boot与磁盘关联断开"><a href="#将boot下的文件卸载-即boot与磁盘关联断开" class="headerlink" title="将boot下的文件卸载 即boot与磁盘关联断开"></a><strong>将boot下的文件卸载 即boot与磁盘关联断开</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092822.png" alt="enter description here"></p><h3 id="将dev-sda1下的文件-挂载到-test下"><a href="#将dev-sda1下的文件-挂载到-test下" class="headerlink" title="将dev/sda1下的文件 挂载到 test下"></a><strong>将dev/sda1下的文件 挂载到 test下</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092823.png" alt="enter description here"></p><h3 id="三种Shell"><a href="#三种Shell" class="headerlink" title="三种Shell"></a><strong>三种Shell</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092824.png" alt="enter description here"></p><h3 id="history"><a href="#history" class="headerlink" title="history"></a><strong>history</strong></h3><p>！5 指的是 把历史编号为5的命令在执行一遍<br><img src="https://viabcde.github.io/images/2018-09-28/2018092825.png" alt="enter description here"></p><h3 id="向网络号为192-168的子网中的所有主机发送信息"><a href="#向网络号为192-168的子网中的所有主机发送信息" class="headerlink" title="向网络号为192.168的子网中的所有主机发送信息"></a><strong>向网络号为192.168的子网中的所有主机发送信息</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092826.png" alt="enter description here"></p><h3 id="测试本主机在局域网能否走通"><a href="#测试本主机在局域网能否走通" class="headerlink" title="测试本主机在局域网能否走通"></a><strong>测试本主机在局域网能否走通</strong></h3><p>Ping 127.0.0.1 测自己的网络 127 +后面 除了全0和全1 都可以测</p><h3 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a><strong>配置网络</strong></h3><p>第一种方法：<br><img src="https://viabcde.github.io/images/2018-09-28/2018092827.png" alt="enter description here"><br>第二种方法：<br><img src="https://viabcde.github.io/images/2018-09-28/2018092828.png" alt="enter description here"></p><h3 id="使用rpm包安装软件"><a href="#使用rpm包安装软件" class="headerlink" title="使用rpm包安装软件"></a><strong>使用rpm包安装软件</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092829.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092830.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092831.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092832.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092833.png" alt="enter description here"></p><h3 id="安装samba-实现Linux和Windows联网"><a href="#安装samba-实现Linux和Windows联网" class="headerlink" title="安装samba 实现Linux和Windows联网"></a><strong>安装samba 实现Linux和Windows联网</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092834.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092835.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092836.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092837.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092838.png" alt="enter description here"><br>配置好之后就可以在windows中输入Linux的IP地址访问了<br><img src="https://viabcde.github.io/images/2018-09-28/2018092839.png" alt="enter description here"><br>然后输入samba的用户名密码<br><img src="https://viabcde.github.io/images/2018-09-28/2018092840.png" alt="enter description here"><br>在windows中上传文件后在Linux中便可查看到<br><img src="https://viabcde.github.io/images/2018-09-28/2018092841.png" alt="enter description here"><br>而在Linux创建文件 在windows也能看到<br><img src="https://viabcde.github.io/images/2018-09-28/2018092842.png" alt="enter description here"></p><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a><strong>任务调度</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092843.png" alt="enter description here"><br>输入 crontab -e<br>然后输入</p><pre><code> 0 2 * * * date &gt;&gt;  /hime/mydata1 02***</code></pre><p>分别对应下面的表字段<br>意思是每天2点去&gt;&gt;  /hime/mydata1<br>保存退出：wq<br><img src="https://viabcde.github.io/images/2018-09-28/2018092844.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092845.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092846.png" alt="enter description here"><br>在mytask.sh 文本写入<br><img src="https://viabcde.github.io/images/2018-09-28/2018092847.png" alt="enter description here"><br>：wq<br>ls –l   发现mytask.sh 不可执行<br>修改<br><img src="https://viabcde.github.io/images/2018-09-28/2018092871.png" alt="enter description here"><br>输入 crontab -e<br>输入<br><img src="https://viabcde.github.io/images/2018-09-28/2018092848.png" alt="enter description here"><br>：wq<br><img src="https://viabcde.github.io/images/2018-09-28/2018092849.png" alt="enter description here"></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a><strong>进程</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092850.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092851.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092852.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092853.png" alt="enter description here"><br>显示进程号<br><img src="https://viabcde.github.io/images/2018-09-28/2018092854.png" alt="enter description here"></p><h3 id="设置系统时间"><a href="#设置系统时间" class="headerlink" title="设置系统时间"></a><strong>设置系统时间</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092855.png" alt="enter description here"></p><h3 id="查看网络状态"><a href="#查看网络状态" class="headerlink" title="查看网络状态"></a><strong>查看网络状态</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092856.png" alt="enter description here"></p><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a><strong>安装mysql</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092857.png" alt="enter description here"></p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a><strong>配置环境变量</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092858.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092859.png" alt="enter description here"><br>修改path<br><img src="https://viabcde.github.io/images/2018-09-28/2018092860.png" alt="enter description here"><br>重启 直接打开 不需要 到bin目录下 即可打开mysql<br><img src="https://viabcde.github.io/images/2018-09-28/2018092861.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092862.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092863.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092864.png" alt="enter description here"></p><h3 id="备份和恢复数据库"><a href="#备份和恢复数据库" class="headerlink" title="备份和恢复数据库"></a><strong>备份和恢复数据库</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092865.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092866.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-28/2018092867.png" alt="enter description here"></p><h3 id="在etc-bashrc-中添加开启启动项-tomcat"><a href="#在etc-bashrc-中添加开启启动项-tomcat" class="headerlink" title="在etc/bashrc 中添加开启启动项 tomcat"></a><strong>在etc/bashrc 中添加开启启动项 tomcat</strong></h3><p>进入到 /home/etc/bashrc<br>vi .bashrc<br><img src="https://viabcde.github.io/images/2018-09-28/2018092868.png" alt="enter description here"></p><h3 id="export临时配置环境变量"><a href="#export临时配置环境变量" class="headerlink" title="export临时配置环境变量"></a><strong>export临时配置环境变量</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092869.png" alt="enter description here"></p><h3 id="将-ls-–l-home-取别名-即输入-llh-等于-输入-ls-–l-home"><a href="#将-ls-–l-home-取别名-即输入-llh-等于-输入-ls-–l-home" class="headerlink" title="将 ls –l /home 取别名 即输入 llh 等于 输入 ls –l /home"></a><strong>将 ls –l /home 取别名 即输入 llh 等于 输入 ls –l /home</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-28/2018092870.png" alt="enter description here"></p><h2 id="git"><a href="#git" class="headerlink" title="git"></a><strong>git</strong></h2><h2 id="svn和git的区别"><a href="#svn和git的区别" class="headerlink" title="svn和git的区别"></a><strong>svn和git的区别</strong></h2><p>前者在版本之间有个差值表示版本的区别 不单独保存被修改的文件<br>通过一定得算法从原始版本+差值得到所需要的版本 需要花费时间<br>后者者是每个版本中被改过的文件都再次保存 没改过的还是引用之前的文件 需要花费空间<br><img src="https://viabcde.github.io/images/all/2018092903.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/2018-09-17/20180925.png" alt="enter descriptionhere">  </p><h3 id="先建好文件夹（可以自己手动在win环境下建，也可以通过命令行建）"><a href="#先建好文件夹（可以自己手动在win环境下建，也可以通过命令行建）" class="headerlink" title="先建好文件夹（可以自己手动在win环境下建，也可以通过命令行建）"></a><strong>先建好文件夹（可以自己手动在win环境下建，也可以通过命令行建）</strong></h3><p>命令行方式  </p><h3 id="cd-要建的目录（比如f盘）"><a href="#cd-要建的目录（比如f盘）" class="headerlink" title="cd 要建的目录（比如f盘）"></a><strong>cd 要建的目录（比如f盘）</strong></h3><p>cd  /f  </p><h3 id="建立文件夹myproject"><a href="#建立文件夹myproject" class="headerlink" title="建立文件夹myproject"></a><strong>建立文件夹myproject</strong></h3><p>mkdir myproject   </p><h3 id="建立仓库"><a href="#建立仓库" class="headerlink" title="建立仓库"></a><strong>建立仓库</strong></h3><p>git init</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h3><p>git config –global  user.name ‘yourname’<br>git config –global  user.email ‘<a href="mailto:youremail@xxx.com" target="_blank" rel="noopener">youremail@xxx.com</a>’<br><strong>或者配置单独某个仓库的</strong><br>git config   user.name ‘yourname’<br>git config   user.email ‘<a href="mailto:youremail@xxx.com" target="_blank" rel="noopener">youremail@xxx.com</a>’<br><strong>存放目录 可以在win下直接复制到myproject文件夹下<br>也可以在 cd myproject 用vi 建文件</strong><br>vi main.c<br><strong>编辑好文件内容后</strong> esc<br><strong>使用</strong>  :x <strong>保存退出</strong></p><h3 id="将main-c-加入仓库"><a href="#将main-c-加入仓库" class="headerlink" title="将main.c 加入仓库"></a><strong>将main.c 加入仓库</strong></h3><p>git add main.c   git add . 表示把当前目录的所有都加入仓库<br>git commit -m “first commit”  </p><h3 id="删除myproject下的main-c"><a href="#删除myproject下的main-c" class="headerlink" title="删除myproject下的main.c"></a><strong>删除myproject下的main.c</strong></h3><p>rm -f main.c</p><h3 id="从-git中把文件恢复到myproject"><a href="#从-git中把文件恢复到myproject" class="headerlink" title="从.git中把文件恢复到myproject"></a><strong>从.git中把文件恢复到myproject</strong></h3><p>git checkout -f HEAD</p><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a><strong>复制文件</strong></h3><p>cp 被复制文件的绝对路径 被复制到的目的地路径 。表示复制到当前目录下  </p><h3 id="查看文件-1"><a href="#查看文件-1" class="headerlink" title="查看文件"></a><strong>查看文件</strong></h3><p>cat 文件名</p><h3 id="获取一个文件的hashcode"><a href="#获取一个文件的hashcode" class="headerlink" title="获取一个文件的hashcode"></a><strong>获取一个文件的hashcode</strong></h3><p>git hash-object main.c  </p><h3 id="查看git-下的对象-比如-commit对象-tree对象-blod对象等"><a href="#查看git-下的对象-比如-commit对象-tree对象-blod对象等" class="headerlink" title="查看git 下的对象 比如 commit对象 tree对象 blod对象等"></a><strong>查看git 下的对象 比如 commit对象 tree对象 blod对象等</strong></h3><p>ls -l .git/objects<br>find .git/objects/ -type f  </p><h3 id="查询对象的类型"><a href="#查询对象的类型" class="headerlink" title="查询对象的类型"></a><strong>查询对象的类型</strong></h3><p>git cat-file -t hashcode<br>blod只保存文件的内容 而文件的名字由引用该文见的tree各自保存  </p><h3 id="查询某个commit-的详细信息"><a href="#查询某个commit-的详细信息" class="headerlink" title="查询某个commit 的详细信息"></a><strong>查询某个commit 的详细信息</strong></h3><p>$ git show -s –pretty=raw hashcode<br><img src="https://viabcde.github.io/iamges/java/2018-09-17-blog/git.png" alt=""><br>git commit -a  -m “my commit”<br>-a表示当前目录凡是被修改过的文件都commit  </p><h3 id="打上tag标签"><a href="#打上tag标签" class="headerlink" title="打上tag标签"></a><strong>打上tag标签</strong></h3><p>$ git tag v1.0  </p><h3 id="通过标签获取对应版本的资源-并打成tar包到当前目录下"><a href="#通过标签获取对应版本的资源-并打成tar包到当前目录下" class="headerlink" title="通过标签获取对应版本的资源 并打成tar包到当前目录下"></a><strong>通过标签获取对应版本的资源 并打成tar包到当前目录下</strong></h3><p>$ git archive –format=tar –prefix=ruby/ v1.0 | gzip &gt; ./ruby1.0.tar.gz<br>$ git archive –format=tar –prefix=ruby（压缩包中的文件夹的名字）/ v1.0 | gzip &gt; ./  ruby1.0.tar.gz（.表示打包到当前目录 /后面表示压缩包的名称）  </p><h3 id="查看某个目录有多少个文件"><a href="#查看某个目录有多少个文件" class="headerlink" title="查看某个目录有多少个文件"></a><strong>查看某个目录有多少个文件</strong></h3><p>$ find .git/objects/ -type f |wc -l  </p><h3 id="创建新的分支"><a href="#创建新的分支" class="headerlink" title="创建新的分支"></a><strong>创建新的分支</strong></h3><p>git branch testing   </p><h3 id="切换分支-此后commit-都是在现在活动分支之后"><a href="#切换分支-此后commit-都是在现在活动分支之后" class="headerlink" title="切换分支 此后commit 都是在现在活动分支之后"></a><strong>切换分支 此后commit 都是在现在活动分支之后</strong></h3><p>git checkout testing  </p><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a><strong>分支合并</strong></h3><p>git merge master 表示当前分支和master分支合并  </p><h3 id="删除不需要的分支"><a href="#删除不需要的分支" class="headerlink" title="删除不需要的分支"></a><strong>删除不需要的分支</strong></h3><p>git branch -D testing</p><h3 id="将该新建的工程提交至远程仓库，关键的git-指令如下："><a href="#将该新建的工程提交至远程仓库，关键的git-指令如下：" class="headerlink" title="将该新建的工程提交至远程仓库，关键的git 指令如下："></a><strong>将该新建的工程提交至远程仓库，关键的git 指令如下：</strong></h3><p>git init<br>git add README.md<br>git commit -m “首次提交代码”<br>git remote add origin <a href="https://github.com/wteam-xq/testGit.git" target="_blank" rel="noopener">https://github.com/wteam-xq/testGit.git</a><br>git push -u origin master<br>将本地仓库代码推送至远程仓库，实际开发中 该指令后需要输入github 账号以及密码。（首次提交注意别遗漏<code>-u</code>指定默认主机）<br>以上指令正常执行后， 本地仓库的代码就提交到远程仓库了<br><img src="https://viabcde.github.io/images/2018-10-10/2018101008.png" alt="enter descriptionhere">  </p><h3 id="将远程仓库代码更新到本地"><a href="#将远程仓库代码更新到本地" class="headerlink" title="将远程仓库代码更新到本地"></a><strong>将远程仓库代码更新到本地</strong></h3><p>首先我们新建一文件夹：copyTestGit，进入该文件夹后使用git 指令：<br>git clone <a href="https://github.com/wteam-xq/testGit" target="_blank" rel="noopener">https://github.com/wteam-xq/testGit</a><br><img src="https://viabcde.github.io/images/2018-10-10/2018101009.png" alt="enter descriptionhere">  </p><h3 id="更新到本地仓库时，-出现冲突，解决冲突"><a href="#更新到本地仓库时，-出现冲突，解决冲突" class="headerlink" title="更新到本地仓库时， 出现冲突，解决冲突"></a><strong>更新到本地仓库时， 出现冲突，解决冲突</strong></h3><p>出现冲突的原因，远程仓库被修改过<br>最直接的方法，右键删除工程，再次colne远程仓库<br>但是git是何许人也，如此强大，可以用原来本地仓库代码覆盖修改过本地工作区代码<br>git checkout head .<br>(注意： 别遗漏 “head” 后的 “ .” )<br>然后更新远程仓库的代码就不会出现冲突了:<br>git pull<br>总结：就是恢复修改前的代码，然后把远程仓库同步到工作间，在做自己想要的修改，再push即可<br><img src="https://viabcde.github.io/images/2018-10-10/2018101010.png" alt="enter descriptionhere"><br>高手的解决方法：利用缓存区<br>先把修改过的代码存到缓存区<br>在把本地代码与远程做同步<br>在把缓存区的代码提出来merge后push</p><h2 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h2><pre><code>1. 查看内存使用情况free -m2. 查看系统版本信息sudo lsb_release -a3. 查看磁盘使用情况df -l4. 查看当前所有进程ps -e5. 查看外网ipcurl ifconfig.me6. 查看网卡信息mii-toolmii-tool -v7.路由信息tracepath -n www.baidu.com8.查看dns去/etc/resolv.conf中查看9.ADSL拨号上网命令：pppoeconf         #开始设置pon dsl-provider  #启动ADSL连接poff              #断开连接plog              #日志10.ubuntu关闭图形界面方法改GRUB 的配置文件（不建议直接改 grub.conf) sudo vi /etc/default/grub 找到这一行： GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;改为： GRUB_CMDLINE_LINUX_DEFAULT=&quot;text &quot;保存后 sudo update-grub 重启即可。11.恢复模式(recovery mode)中root改成对文件系统的读写模式：mount -o remount,rw /12.vi删除所有文本d+G13.vi查找文本/sometext Enter (Enter表示按下回车键)n，继续朝同一方向搜索。N，反方向进行搜索。14.解压缩命令tar –xvf file.tar //解压 tar包tar -xzvf file.tar.gz //解压tar.gztar -zxvf /home/images.tar.gz -C /specificdir  //解压到指定的目录tar -xjvf file.tar.bz2   //解压 tar.bz2tar –xZvf file.tar.Z   //解压tar.Zunrar e file.rar //解压rarunzip file.zip //解压zip15.关闭/启动网卡sudo ifconfig eth0 upsudo ifconfig eth0 down16.添加用户到组：gpasswd -a 用户名 组名举例：gpasswd -a hello linux说明：表示将用户hello添加到linux组中。17 .在组中删除用户：gpasswd -d 用户名 组名举例：gpasswd -d hello linux说明：表示将用户hello从组linux中删除。18.指定组的管理员：gpasswd -A 用户名 组名举例：gpasswd -A hello linux说明：表示将用户hello设置为组linux的管理员。19. 查看linux的内核版本号uname -r20.以root权限执行上一条命令sudo !!21. 利用python搭建一个简单的web服务器，可通过http://$HOSTNAME:8000访问python -m SimpleHTTPServer   22 更改到上一次访问的目录cd -23) 宿主机往虚拟机上上传文件：$ sftp -i ~/.ssh/id_rsa ubuntu@10.0.0.2连通之后sftp&gt; put path/to/file24) 查看网卡的生产厂家和型号lspci | grep -i net25) 查看网卡速率cat /sys/class/net/eth0/speedorsudo mii-tool26) 查看CPU型号cat /proc/cpuinfo27) 宿主机与虚拟机互传文件scp path/to/file username@x.x.x.x:path/to/eg: scp 0-out-none.result ustack@192.168.1.2:~/devstack/files/precise/resultscp test.sh ubuntu@10.0.0.2:~/28) 查找某个目录下包含某个字符串的所有文件：grep -r somestring path/to/*29) 打包压缩/解压解包命令tar czvf file.tar.gz /path/to/   #打包压缩tar xzvf file.tar.gz -C /path/to/  #解包解压30）递归改变目录下所有文件的拥有者：chown -R suo:suo dirLinux之netstat1.查看哪些IP连接本机$ netstat -an2.查看TCP连接数1).统计80端口连接数$ netstat -nat|grep -i &quot;80&quot;|wc -l2).统计httpd协议连接数$ ps -ef|grep httpd|wc -l3).统计已连接上的，状态为“established”$ netstat -na|grep ESTABLISHED|wc -l4).查出哪个IP地址连接最多$ netstat -na|grep ESTABLISHED|awk {print $5}|awk -F: {print $1}|sort|uniq -c|sort -r +0n#将其查封$ netstat -na|grep SYN|awk {print $5}|awk -F: {print $1}|sort|uniq -c|sort -r +0n3.查看正在监听状态的端口 1).netstat -nupl# n表示用数字形式显示端口号，u，表示UDP协议类型，p是程序PID，l表示处于监听状态的；$ netstat -nupl2).netstat -ntp# n表示用数字形式显示端口号，t，表示TCP协议类型，p是程序PID，l表示处于监听状态的；$ netstat -ntpl3).netstat -nuplf | grep 3306# 这个表示查找处于监听状态的，端口号为3306的进程；$ netstat -nuplf | grep 3306 </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ActionContext</title>
      <link href="/2018/09/18/2018-9-26-ActionContext/"/>
      <url>/2018/09/18/2018-9-26-ActionContext/</url>
      
        <content type="html"><![CDATA[<p>是Sruts2内置对象，通过该对象可以获得之前Servlet中的对象，比如：requst对象，response对象<br>每次发送一次请求就会创建一个ActionContext<br>ActionContext是一个Map集合  内部记录了name = request value = 该对象的地址   </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> Struts2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举</title>
      <link href="/2018/09/18/2018-9-18-%E6%9E%9A%E4%B8%BE/"/>
      <url>/2018/09/18/2018-9-18-%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a><strong>枚举</strong></h3><p><strong>直观，不容易出错，提高代码可读性</strong></p><pre><code>package com.ljq.test;/** * 枚举用法详解 * @author jiqinlin */public class TestEnum {    /**     * 普通枚举     * @author jiqinlin     */    public enum ColorEnum {        red, green, yellow, blue;    }    /**     * 枚举像普通的类一样可以添加属性和方法，可以为它添加静态和非静态的属性或方法     * @author jiqinlin     */    public enum SeasonEnum {        //注：枚举写在最前面，否则编译出错        spring, summer, autumn, winter;        private final static String position = &quot;test&quot;;        public static SeasonEnum getSeason() {            if (&quot;test&quot;.equals(position))                return spring;            else                return winter;        }    }       /**     * 性别     * 实现带有构造器的枚举     * @author jiqinlin     */    public enum Gender{        //通过括号赋值,而且必须带有一个参构造器和一个属性跟方法，否则编译出错        //赋值必须都赋值或都不赋值，不能一部分赋值一部分不赋值；如果不赋值则不能写构造器，赋值编译也出错        MAN(&quot;MAN&quot;), WOMEN(&quot;WOMEN&quot;);                private final String value;        //构造器默认也只能是private, 从而保证构造函数只能在内部使用        Gender(String value) {            this.value = value;        }                public String getValue() {            return value;        }    }       /**    * 订单状态    * 实现带有抽象方法的枚举    * @author jiqinlin    */    public enum OrderState {        /** 已取消 */        CANCEL {public String getName(){return &quot;已取消&quot;;}},        /** 待审核 */        WAITCONFIRM {public String getName(){return &quot;待审核&quot;;}},        /** 等待付款 */        WAITPAYMENT {public String getName(){return &quot;等待付款&quot;;}},        /** 正在配货 */        ADMEASUREPRODUCT {public String getName(){return &quot;正在配货&quot;;}},        /** 等待发货 */        WAITDELIVER {public String getName(){return &quot;等待发货&quot;;}},        /** 已发货 */        DELIVERED {public String getName(){return &quot;已发货&quot;;}},        /** 已收货 */        RECEIVED {public String getName(){return &quot;已收货&quot;;}};              public abstract String getName();    }        public static void main(String[] args) {        //枚举是一种类型，用于定义变量，以限制变量的赋值；赋值时通过“枚举名.值”取得枚举中的值        ColorEnum colorEnum = ColorEnum.blue;        switch (colorEnum) {        case red:            System.out.println(&quot;color is red&quot;);            break;        case green:            System.out.println(&quot;color is green&quot;);            break;        case yellow:            System.out.println(&quot;color is yellow&quot;);            break;        case blue:            System.out.println(&quot;color is blue&quot;);            break;        }                //遍历枚举        System.out.println(&quot;遍历ColorEnum枚举中的值&quot;);        for(ColorEnum color : ColorEnum.values()){            System.out.println(color);        }                //获取枚举的个数        System.out.println(&quot;ColorEnum枚举中的值有&quot;+ColorEnum.values().length+&quot;个&quot;);        //获取枚举的索引位置，默认从0开始        System.out.println(ColorEnum.red.ordinal());//0        System.out.println(ColorEnum.green.ordinal());//1        System.out.println(ColorEnum.yellow.ordinal());//2        System.out.println(ColorEnum.blue.ordinal());//3                //枚举默认实现了java.lang.Comparable接口        System.out.println(ColorEnum.red.compareTo(ColorEnum.green));//-1                //--------------------------        System.out.println(&quot;===========&quot;);        System.err.println(&quot;季节为&quot; + SeasonEnum.getSeason());                        //--------------        System.out.println(&quot;===========&quot;);        for(Gender gender : Gender.values()){            System.out.println(gender.value);        }              //--------------        System.out.println(&quot;===========&quot;);        for(OrderState order : OrderState.values()){            System.out.println(order.getName());        }    }    }</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>导入项目时遇到的各种问题</title>
      <link href="/2018/09/18/2018-9-18-%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98/"/>
      <url>/2018/09/18/2018-9-18-%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="java编译版本不匹配"><a href="#java编译版本不匹配" class="headerlink" title="java编译版本不匹配"></a><strong>java编译版本不匹配</strong></h3><p> 进入 windows—proferences—java–compiler设置编译出来的文件使用的格式是 1.7版本的 (设置成多少都行,只要兼容,并且与你项目的编译版本一直就可以,我这里统一设置成1.7)<br> 进入项目–properties—java Compiler 把项目编译版本也设置成 1.7<br> 进入项目–properties—Myeclipse—project Facets设置java文件的版本为 1.7，并打勾。   </p><h3 id="Failed-to-execute-goal-org-apache-maven-plugins-maven-war-plugin-2-2-war-default-war"><a href="#Failed-to-execute-goal-org-apache-maven-plugins-maven-war-plugin-2-2-war-default-war" class="headerlink" title="Failed to execute goal org.apache.maven.plugins:maven-war-plugin:2.2:war (default-war)"></a><strong>Failed to execute goal org.apache.maven.plugins:maven-war-plugin:2.2:war (default-war)</strong></h3><p><strong>错误原因</strong><br>Maven默认会去src\main\webapp下去找web.xml，而我们项目经常会改为WebRoot目录代替src\main\webapp目录，那么我们就需要自己重新配置一下web.xml路径；<br>    pom.xml加入如下配置指定我们自己配置web.xml路径   </p><pre><code>&lt;!-- 配置web.xml文件的配置 --&gt;         &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;                &lt;version&gt;2.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;!-- 指定web.xml的路径  --&gt;                    &lt;webXml&gt;WebRoot\WEB-INF\web.xml&lt;/webXml&gt;                    &lt;!-- 指定jsp、js、css的路劲 --&gt;                     &lt;warSourceDirectory&gt;WebRoot&lt;/warSourceDirectory&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;</code></pre><h3 id="Description-Resource-Path-Location-Type-Archive-for-required-library-‘E-maven-cangku-org-mybatis-mybatis-3-3-0-mybatis-3-3-0-jar’-in-project-‘SSMDemo’-cannot-be-read-or-is-not-a-valid-ZIP-file错误"><a href="#Description-Resource-Path-Location-Type-Archive-for-required-library-‘E-maven-cangku-org-mybatis-mybatis-3-3-0-mybatis-3-3-0-jar’-in-project-‘SSMDemo’-cannot-be-read-or-is-not-a-valid-ZIP-file错误" class="headerlink" title="Description Resource Path Location Type Archive for required library: ‘E:/maven/cangku/org/mybatis/mybatis/3.3.0/mybatis-3.3.0.jar’ in project ‘SSMDemo’ cannot be read or is not a valid ZIP file错误 "></a><strong>Description Resource Path Location Type Archive for required library: ‘E:/maven/cangku/org/mybatis/mybatis/3.3.0/mybatis-3.3.0.jar’ in project ‘SSMDemo’ cannot be read or is not a valid ZIP file错误 </strong></h3><p> 原因：网络问题，maven仓库有jar包，但不全<br> 解决方法：到maven仓库删除和这个jar有关的内容，alt+F5刷新，让maven重新下载完整的jar包即可</p><h3 id="spring配置异常之Description-Resource-Path-Location-Type-Referenced-file-contains-errors-htt"><a href="#spring配置异常之Description-Resource-Path-Location-Type-Referenced-file-contains-errors-htt" class="headerlink" title="spring配置异常之Description Resource Path Location Type Referenced file contains errors (htt"></a><strong>spring配置异常之Description Resource Path Location Type Referenced file contains errors (htt</strong></h3><p> 解决方法：把spring-beans.xsd<br>改为spring-beans-3.1.xsd</p><h3 id="maven-install时出现的警告"><a href="#maven-install时出现的警告" class="headerlink" title="maven install时出现的警告"></a><strong>maven install时出现的警告</strong></h3><p><strong>报错信息</strong>  </p><pre><code>WARNING: An illegal reflective access operation has occurredWARNING: Illegal reflective access by com.thoughtworks.xstream.core.util.Fields (file:/E:/bos_repository/bos_repository/com/thoughtworks/xstream/xstream/1.3.1/xstream-1.3.1.jar) to field java.util.Properties.defaultsWARNING: Please consider reporting this to the maintainers of com.thoughtworks.xstream.core.util.FieldsWARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operationsWARNING: All illegal access operations will be denied in a future release</code></pre><p>原因：JDK版本过高，不影响项目运行</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识</title>
      <link href="/2018/09/17/2018-9-17-java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/09/17/2018-9-17-java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="反码-取反-补码"><a href="#反码-取反-补码" class="headerlink" title="反码 取反 补码"></a><strong>反码 取反 补码</strong></h3><p>1.反码是指符号位不变 其他位改变 符号位1为负 0为正<br>2.取反是指所有位都改变<br>3.正数的补码与原码相同 无需改变 , 而负数的补码是 取绝对值 取反 再加1<br>反过来由补码获取原码 减1 取反 取绝对值<br>4.计算机运算都是以补码来运算 如 ~ 2 和 ~-2 都是对补码的取反 而不是原码  </p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h3><p>一个字节（byte）=8位 有2的8次方种可能 范围-128~127 负0（1000 0000）表示-128 正0（0000 0000）表示0<br>以此类推 short = 2个字节 <code>2*8</code>（位） int 4个字节 long 8个字节  </p><h3 id="字符相加"><a href="#字符相加" class="headerlink" title="字符相加"></a><strong>字符相加</strong></h3><p>字符相加是指其对于的ASCII码相加后 在ASCII表中对应的字符 如果没有对应的 即打印一个 ？</p><h3 id="强制转换为int"><a href="#强制转换为int" class="headerlink" title="强制转换为int"></a><strong>强制转换为int</strong></h3><p>在强转为int时，只保留整数部分 小数部分无论多少都舍去 没有四舍五入的操作</p><h3 id="从控制台读取输入的内容"><a href="#从控制台读取输入的内容" class="headerlink" title="从控制台读取输入的内容"></a><strong>从控制台读取输入的内容</strong></h3><p>使用InputStreamReader 读取控制台的内容（system.in）<br>再使用BufferReader 读取InputStrreamReader的内容 之后由BufferReader调用readLine()输出给一个引用变量（String s = br.readLine()）<br>inputStreamReader外面包一层BufferReader</p><pre><code>/*从控制台读取输入内容*/        try {            InputStreamReader isr = new InputStreamReader(System.in);            BufferedReader br = new BufferedReader(isr);            String a = bd.readLine();        } catch (Exception e) {            // TODO: handle exception        }</code></pre><p>或</p><pre><code>Scanner sc = new Scanner(system.in);String s=sc.nextInt();</code></pre><h3 id="String转为float"><a href="#String转为float" class="headerlink" title="String转为float"></a><strong>String转为float</strong></h3><p>Float f = float.parseFloat(a);</p><h3 id="打印菱形"><a href="#打印菱形" class="headerlink" title="打印菱形"></a><strong>打印菱形</strong></h3><p>先使用一个for 控制输出多少行<br>再在里面嵌套2个for<br>第一个for控制每一行里先输出多少个空格<br>第二个for控制空格之后输出多少个星号<code>“*”</code><br>在第二个for中使用if判断是否是第一列和最后一列 输出星号<code>“*”</code><br>否则输出空格     </p><h3 id="何时会被当成垃圾回收"><a href="#何时会被当成垃圾回收" class="headerlink" title="何时会被当成垃圾回收"></a><strong>何时会被当成垃圾回收</strong></h3><p>当指针不再指向该数据时会被当成垃圾等待回收<br>当内存即将不够用的时候，GC会遍历一遍对象，没有被遍历到的对象会被清除  </p><h3 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a><strong>默认构造方法</strong></h3><p>每个对象都会有一个默认的空构造方法<br>public person(){}<br>如果自己写了构造方法 则默认的构造方法会被覆盖<br>要使用空构造方法则需要显式写出来 才能使用  </p><h3 id="this"><a href="#this" class="headerlink" title="this"></a><strong>this</strong></h3><p>this.name 相当于 对象说了一句 我的name<br>用于区分同名成员变量和局部变量    </p><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a><strong>静态变量</strong></h3><p>也称为类变量，因为它是属于类的而不是实例对象的，通过类名.变量来使用它<br>例子：static int a=1;</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a><strong>静态方法</strong></h3><p>静态方法在类编译完就会执行 而且只执行一次属于类而不是实例对象的<br>静态方法不能访问非静态变量 因为静态方法编译后，在类装载时初始化存在内存中，而非静态变量在编译后不存在内存中（只有在new之后才加入到内存），根本就找不到该变量，访问不到 执行顺序：类加载-&gt;main  </p><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a><strong>访问权限</strong></h3><p>记忆很简单 画一个<code>4*4</code>矩阵  范围依次递减 √ 即可<br>|    范围|同类 | 同包|子类|不同包    |<br>| — | — | — | — | — |<br>|     public   | √| √|√|√    |<br>|protected|√ | √|√|<br>  |default  |√| √|<br>  |private  |√ |</p><h3 id="package的作用"><a href="#package的作用" class="headerlink" title="package的作用"></a><strong>package的作用</strong></h3><p>将源文件的字节码打包到同一个包中  </p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a><strong>封装</strong></h3><p>隐藏对象的属性和实现细节，仅对外提供公共访问方式   </p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h3><p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义，可以省略代码，使用extends关键字<br>即可继承那个类。<br>子类可以访问父类的非private属性及方法，但不能缩小父类的访问权限     </p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h3><p>前提是有继承或接口<br>可以创建相同父类或接口类型的不同子类对象<br>这样在写构造方法时 不需要按不同子类类型写多个重载方法  </p><h3 id="动态绑定（迟邦定）-多态"><a href="#动态绑定（迟邦定）-多态" class="headerlink" title="动态绑定（迟邦定） 多态"></a><strong>动态绑定（迟邦定） 多态</strong></h3><p> 在编译时指向的是父类的内存 而运行时   方法实际传入的是哪个子类便更改指向父类的指针为指向子类的内存   把子类当做父类使用 即向上转型</p><h3 id="super-f"><a href="#super-f" class="headerlink" title="super.f()"></a><strong>super.f()</strong></h3><p>指的是调用父类的f方法<br>子类的构造必须先调用父类的构造方法super()   通过参数列表的不同指明调用父类的哪个构造方法<br>因为子类需要用到父类的属性和方法 所以必须先把父类构造出来才能用<br>如果没写 系统默认使用父类空的构造方法</p><h3 id="重写和重载的区别？"><a href="#重写和重载的区别？" class="headerlink" title="重写和重载的区别？"></a><strong>重写和重载的区别？</strong></h3><p>重载：在同一类中。方法名相同，参数列表不同。重载可以改变返回类型。<br>重写：在不同类中(子父类中)。<br>方法声明相同(返回类型，方法名，参数列表均相同)。   </p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><strong>抽象类</strong></h3><p>抽象是将某一类事务归类的研究方法（抽象是一种研究的方法）<br>当父类方法的逻辑很大概率会被子类覆盖重写时 可以将父类定义为抽象类<br>抽象类和抽象方法都要用abstract进行修饰<br>抽象类有构造方法但不能被实例化,只能被子类实例化，子类必须实现父类的所有抽象方法<br>抽象类中可以有变量，也可以有常量<br>抽象类中可以有抽象方法，也可以有非抽象方法<br>abstract不能和provate\static\final共存<br>接口是更加抽象的抽象类<br>一个类中的方法都是抽象的时候，可以抽象为接口<br>接口中的变量常量，默认修饰 public static final<br>方法默认修饰 public abstract<br>抽象类是对一类事物的抽象 而接口是对一个功能的抽象<br>static final 前期绑定<br>多态 后期绑定<br> <strong>当子类不想实现父类抽象方法时 ，则可以在写一个同名的抽象方法即可不用实现</strong>   </p><h3 id="接口不能代替抽象类"><a href="#接口不能代替抽象类" class="headerlink" title="接口不能代替抽象类"></a><strong>接口不能代替抽象类</strong></h3><p>因为如果需要维护一个类的信息和状态时需要用到实例成员变量（没有static修饰）<br>而接口中的变量都用 static final修饰</p><h3 id="符号运算"><a href="#符号运算" class="headerlink" title="符号运算"></a><strong>符号运算</strong></h3><p>左移&lt;&lt;右侧补0<br>右移&gt;&gt;左侧补符号位</p><h3 id="ArrayList与Vector区别"><a href="#ArrayList与Vector区别" class="headerlink" title="ArrayList与Vector区别"></a><strong>ArrayList与Vector区别</strong></h3><p>ArrayList用于异步 容量不足自动扩展为原来的1.5倍<br>Vector用于同步 容量不足自动扩展为原来的2倍</p><h3 id="遍历HashMap"><a href="#遍历HashMap" class="headerlink" title="遍历HashMap"></a><strong>遍历HashMap</strong></h3><p>iterator.next来获取key<br>通过get(key)获取Value<br><img src="https://viabcde.github.io/images/2018-09-26/2018092601.png" alt="enter descriptionhere">  </p><h3 id="HashMap与HashTable区别"><a href="#HashMap与HashTable区别" class="headerlink" title="HashMap与HashTable区别"></a><strong>HashMap与HashTable区别</strong></h3><p>HashMap用于异步 其key与value 可以为空，当多线程同时put的时候，会欺骗程序，hashmap容量不足，导致rehash操作（即扩容），导致死循环<br>HashTable用于同步 其key与value 不可以为空 编译时不报错 运行时出错</p><h3 id="hashMap是根据key的hashCode来寻找存放位置的，那当key为null时，-怎么存储呢？"><a href="#hashMap是根据key的hashCode来寻找存放位置的，那当key为null时，-怎么存储呢？" class="headerlink" title="hashMap是根据key的hashCode来寻找存放位置的，那当key为null时， 怎么存储呢？"></a><strong>hashMap是根据key的hashCode来寻找存放位置的，那当key为null时， 怎么存储呢？</strong></h3><p>在put方法里头，其实第一行就处理了key=null的情况。 </p><pre><code>if (key == null)      return putForNullKey(value);  //那就看看这个putForNullKey是怎么处理的吧。  private V putForNullKey(V value) {      for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {          if (e.key == null) {              V oldValue = e.value;              e.value = value;              e.recordAccess(this);              return oldValue;          }      }      modCount++;      addEntry(0, null, value, 0);      return null;  } </code></pre><p>可以看到，前面那个for循环，是在talbe[0]链表中查找key为null的元素，如果找到，则将value重新赋值给这个元素的value，并返回原来的value。<br>如果上面for循环没找到则将这个元素添加到talbe[0]链表的表头。 </p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a><strong>泛型</strong></h3><pre><code>泛型Generic  起因：      ·JDK1.4以前类型不明确：          ·装入集合的类型都被当作Object对待，从而失去自己的实际类型          ·从集合中取出时往往需要转型，效率低，容易产生错误  解决办法      ·在定义集合的时候同时定义集合中对象的类型      ·实例：          ·可以再定义Collection的时候指定          ·也可以在循环时用Iterator指定      List&lt;String&gt; c = arrayList&lt;String&gt;();      Iterator&lt;String&gt; it = c2.iterator();  好处      ·增强程序的可读性和稳定性  </code></pre><p>定义一个SeqList&lt; T &gt;类<br>在创建实例时可以自定义元素类型 ，如<br>SeqList&lt; String &gt; a =new SeqList&lt; String &gt;();<br>SeqList&lt; Integer &gt; a =new SeqList&lt; Integer &gt;();<br><strong>优点：</strong>不使用泛型 则从list取出来的元素是Object，需要做强制转换<br>如果此时转换的类型与元素期望的类型不符 编译时不报错 运行时报错<br>使用泛型 则不需要强制转换 如果创建与元素期望不符的类型 编译时报错提醒<br><strong>缺点：</strong>仍然可以使用反射机制来加入不同类型的元素<br>collection.getClass().getMethod(“add”,Object.class).invoke(collection1,”aaa”);  </p><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a><strong>finally</strong></h3><p>文件如果不调用close()方法则数据并不会存入文件<br>在finally中关闭文件 连接等操作 防止内存泄漏    </p><h3 id="final"><a href="#final" class="headerlink" title="final"></a><strong>final</strong></h3><p>因为final是常量 不会改变，所以对它进行优化 ，在编译阶段就使用它 而static真正使用是在运行时才能使用</p><h3 id="不同try用throws"><a href="#不同try用throws" class="headerlink" title="不同try用throws"></a><strong>不同try用throws</strong></h3><p>报错时不知道错误发生在哪一行</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h3><p>在剩下的元素中比较出最大/小    的，放在最后</p><pre><code>for(int i=0;i&lt;a.length-1;i++){    for(int j=0;j&lt;a.length-1-i;j++){        if(a[j]&gt;a[j+1]){            temp=a[j];            a[j]=a[j+1];            a[j+1]=temp;        }    }}</code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h3><p>从第一个元素开始通过和剩下的元素比较大小为每一个元素定好位，及最终排好序的位置</p><pre><code>for(int i=0;i&lt;a.length-1;i++){    int min=a[i];    int index=i;    for(int j=i+1;j&lt;a.length,j++){        if(min&gt;a[j]){            min=a[j];            index=j;        }    }    temp=a[i];    a[i]=a[j];    a[index]=temp;}</code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><strong>插入排序</strong></h3><pre><code>for(int i=1;i&lt;a.length;i++){    int insertVal=a[i];    int index=i-1;    while(index&gt;=0&amp;&amp;insertVal&gt;a[index]){        a[index+1]=a[index];        index--;    }    a[index+1]=insertVal;}</code></pre><h3 id="JVM内存管理-内存空间、内存分配、内存回收"><a href="#JVM内存管理-内存空间、内存分配、内存回收" class="headerlink" title="JVM内存管理(内存空间、内存分配、内存回收)"></a><strong>JVM内存管理(内存空间、内存分配、内存回收)</strong></h3><p>当内存空间即将用完，GC就会暂停程序，遍历所有对象并标记为1，没有被标记（及没被遍历到）的对象清除掉，最后再把所有被标记的全部置0</p><h3 id="那为什么要暂停来垃圾回收"><a href="#那为什么要暂停来垃圾回收" class="headerlink" title="那为什么要暂停来垃圾回收"></a><strong>那为什么要暂停来垃圾回收</strong></h3><p>因为如果在标记完成，清除没被标记的对象期间，所有在这个期间new出来的对象都会被误删</p><h3 id="绝对值"><a href="#绝对值" class="headerlink" title="绝对值"></a><strong>绝对值</strong></h3><p>math.abs();</p><h3 id="awt与Swing"><a href="#awt与Swing" class="headerlink" title="awt与Swing"></a><strong>awt与Swing</strong></h3><p>awt 会随系统而改变样式，Swing不会 但却消耗内存</p><h3 id="JFrame"><a href="#JFrame" class="headerlink" title="JFrame"></a><strong>JFrame</strong></h3><p>j.serTitle();<br>j.setSize();<br>j.setLocation();<br>j.setVisival();<br>j.setDefaultColseOperation(JFram_Exit_IN);  </p><h3 id="边界布局"><a href="#边界布局" class="headerlink" title="边界布局"></a><strong>边界布局</strong></h3><p>borderLayout 东西南北中</p><h3 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a><strong>流式布局</strong></h3><p>FlowLayout 随窗口排列</p><h3 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a><strong>静态导入</strong></h3><p>import static 则在类中不需要使用类名.方法名调用方法 只需用方法名即可</p><h3 id="增强的for循环"><a href="#增强的for循环" class="headerlink" title="增强的for循环"></a><strong>增强的for循环</strong></h3><p>for(int i : args){}</p><h3 id="装箱、拆箱"><a href="#装箱、拆箱" class="headerlink" title="装箱、拆箱"></a><strong>装箱、拆箱</strong></h3><p>Integer i=1; 将int类型的 1 装箱为Integer<br>syso(i+3);将Integer类型的i 拆箱为int 之后与3相加</p><h3 id="享-元模式"><a href="#享-元模式" class="headerlink" title="享 元模式"></a><strong>享 元模式</strong></h3><p>把程序共有的部分封装为一个方法 而不同的部分作为方法的参数传入</p><h3 id="获取字节码的方法"><a href="#获取字节码的方法" class="headerlink" title="获取字节码的方法"></a><strong>获取字节码的方法</strong></h3><p>String s=”aaa”;<br>1.String.getClass();<br>2.s.getClass();<br>3.ClassforName(“java.lang.String”);</p><h3 id="获取类的构造方法"><a href="#获取类的构造方法" class="headerlink" title="获取类的构造方法"></a><strong>获取类的构造方法</strong></h3><p>s.getClass().getConstructor();</p><h3 id="获取类的属性"><a href="#获取类的属性" class="headerlink" title="获取类的属性"></a><strong>获取类的属性</strong></h3><p>s.getClass().getFiled</p><h3 id="i-和-i"><a href="#i-和-i" class="headerlink" title="i++和++i"></a><strong>i++和++i</strong></h3><p>在赋值时有区别 但在for循环中只是自加的作用 没有区别 据说++i比i++快一些</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h3><p>数组变量中存了数组第一个元素的首地址、数组的容量，一级有效个数<br>当需要取出第二个元素时，第二个元素首地址=第一个元素首地址+1</p><h3 id="java内存泄漏情况"><a href="#java内存泄漏情况" class="headerlink" title="java内存泄漏情况"></a><strong>java内存泄漏情况</strong></h3><p>忘记关闭数据库连接 忘记删除监听器 没有及时将对象设为null</p><h3 id="equals和"><a href="#equals和" class="headerlink" title="equals和=="></a><strong>equals和==</strong></h3><p>equals表示内容相同 首地址不一定相同<br>而“==”表示首地址相同 此时 内容肯定也相同</p><h3 id="ip和端口"><a href="#ip和端口" class="headerlink" title="ip和端口"></a><strong>ip和端口</strong></h3><p>ip表示网络中的主机 端口表示主机上的程序</p><h3 id="数据类型相加"><a href="#数据类型相加" class="headerlink" title="数据类型相加"></a><strong>数据类型相加</strong></h3><p>1.int型以下(byte short 还有char)作为操作数，jvm会将其类型提升至int   再参与运算；int型以上保持原有类型<br>2.表达式返回值的类型会提升至操作符两边表数范围较大的那一方的类型</p><h3 id="instanceof-判断一个对象是否属于某个类的示例"><a href="#instanceof-判断一个对象是否属于某个类的示例" class="headerlink" title="instanceof 判断一个对象是否属于某个类的示例"></a><strong>instanceof 判断一个对象是否属于某个类的示例</strong></h3><pre><code>public class Test_instanceof {    public static void main(String[] args) {        String s = &quot;Hello&quot;;        int[] a = {1,2};        if(s instanceof String)            System.out.println(&quot;true&quot;);        if(s instanceof Object)            System.out.println(&quot;true&quot;);        if(a instanceof int[])            System.out.println(&quot;true&quot;);    }}</code></pre><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a><strong>继承</strong></h3><p>是子类和父类之间的关系 即把各个子类的公共属性提取出来作为父类<br><img src="https://viabcde.github.io/images/2018-09-27/2018092703.png" alt="enter description here"> </p><h3 id="return"><a href="#return" class="headerlink" title="return"></a><strong>return</strong></h3><p>返回的值 会临时保存在栈内存中 方法结束后该内存才消失</p><h3 id="equals方法默认比较的是首地址-必须重写"><a href="#equals方法默认比较的是首地址-必须重写" class="headerlink" title="equals方法默认比较的是首地址 必须重写"></a><strong>equals方法默认比较的是首地址 必须重写</strong></h3><p>String类 已经重写了equals方法 所以用String 比较时 不用自己重写equals方法  </p><h3 id="局部变量系统不会自动初始化-成员变量才会"><a href="#局部变量系统不会自动初始化-成员变量才会" class="headerlink" title="局部变量系统不会自动初始化 成员变量才会"></a><strong>局部变量系统不会自动初始化 成员变量才会</strong></h3><h3 id="new-String-c-4-3"><a href="#new-String-c-4-3" class="headerlink" title="new String(c,4,3);"></a><strong>new String(c,4,3);</strong></h3><p>从c 的第4个字符串开始截取3个字符</p><h3 id="s-indexof-“java”"><a href="#s-indexof-“java”" class="headerlink" title="s.indexof(“java”)"></a><strong>s.indexof(“java”)</strong></h3><p>首次出现java 的第一个位置</p><h3 id="String-split-s-split-“-”"><a href="#String-split-s-split-“-”" class="headerlink" title="String[] _split= s.split(“,”);"></a><strong>String[] _split= s.split(“,”);</strong></h3><p> 把s 按逗号分离并分别保存到数组中_split</p><p><img src="https://viabcde.github.io/images/2018-09-27/2018092706.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092707.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092708.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092729.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092710.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092711.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092712.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092713.png" alt="enter description here"><br>区别 ：前者是动态绑定 即编译期间 d指向的是Object 的toString 方法<br>运行时d 指向的是传入的子类对象 的toString方法<br>而后者直接调用d的toString方法  </p><h3 id="判断c是否小写"><a href="#判断c是否小写" class="headerlink" title="判断c是否小写"></a><strong>判断c是否小写</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-27/2018092714.png" alt="enter description here"><br>s.charAt(i) 取得s 第i-1个字符<br>s.subString(1,2);表示截取 第2到第3个字符<br>s.subString(2);表示截取第3个字符至结尾所有字符<br>s1+=s2 指的是 s1 s2   的内存都复制保存到第三个内存空间中（因为String是不可变的   所以只能把2个String复制到共同的内存空间） 再把s1的首地址指向第三个内存空间<br>效率较低 改进 用StringBuffer<br>枚举类型 规定只能选择使用的参数时哪几个 使用类名.属性来获取   比如游戏中定义方向只能上下左右四个方向<br><img src="https://viabcde.github.io/images/2018-09-27/2018092715.png" alt="enter description here"><br>用容器的原因<br>数组的长度不能增加 要扩展必须开辟另一空间 再把原来的数组复制过来<br><img src="https://viabcde.github.io/images/2018-09-27/2018092716.png" alt="enter description here"><br>使用多态的原因 因为c只能使用Collection接口中的方法   而不会使用子类ArrayList自己的方法<br>当更换子类LinkList时 不需要修改子类的自己方法 直接替换即可<br>这里的Name类没有重写equals方法 所以其equals方法比较的是首地址是否相同<br>很明显2个Name对象都是各自new 出来的 首地址不同 所以   remove时并不会把之前的Name对象移除<br> <img src="https://viabcde.github.io/images/2018-09-27/2018092717.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092718.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092719.png" alt="enter description here"><br>utf8比较省空间<br>join 即把线程归并回主线程 当做方法使用   只有该线程执行完后才继续执行它下面的代码<br>yield 当前线程让其他线程执行一会<br><img src="https://viabcde.github.io/images/2018-09-27/2018092720.png" alt="enter description here"><br>网关 一边连着子网 替子网转发 一边连着公网上网<br>TCP必须有回复才发<br>UDP 发了不管    </p><h2 id="继承-2"><a href="#继承-2" class="headerlink" title="继承"></a><strong>继承</strong></h2><p> <img src="https://viabcde.github.io/images/blog/2018092801.png" alt="enter description here"></p><h2 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a><strong>接口实现</strong></h2><p> <img src="https://viabcde.github.io/images/blog/2018092802.png" alt="enter description here"></p><h2 id="关联-即A中引用了B"><a href="#关联-即A中引用了B" class="headerlink" title="关联 即A中引用了B"></a><strong>关联 即A中引用了B</strong></h2><p>!<img src="https://viabcde.github.io/images/blog/2018092803.png" alt="enter description here"></p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a><strong>聚合</strong></h2><p><img src="https://viabcde.github.io/images/blog/2018092804.png" alt="enter description here"></p><h2 id="组合-对于-自身属性"><a href="#组合-对于-自身属性" class="headerlink" title="组合 对于 自身属性"></a><strong>组合 对于 自身属性</strong></h2><p><img src="https://viabcde.github.io/images/blog/2018092805.png" alt="enter description here"></p><h2 id="依赖-对于传入方法参数"><a href="#依赖-对于传入方法参数" class="headerlink" title="依赖  对于传入方法参数"></a><strong>依赖  对于传入方法参数</strong></h2><p><img src="https://viabcde.github.io/images/blog/2018092806.png" alt="enter description here"></p><h2 id="为什么尽量不去改动已有的代码"><a href="#为什么尽量不去改动已有的代码" class="headerlink" title="为什么尽量不去改动已有的代码"></a><strong>为什么尽量不去改动已有的代码</strong></h2><p>一是为了防止有些程序员恶意破坏<br>二是改了之后已有的代码还需要重新到各个机器编译安装一次  </p><h2 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a><strong>连接字符串</strong></h2><pre><code>String s=&quot;a&quot;;s=s.concat(&quot;b&quot;);</code></pre><p>syso s=ab</p><h3 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a><strong>生成随机数</strong></h3><pre><code>int x=(int)(Math.random()*100);</code></pre><p>0-100  包括0 不包括100</p><h3 id="毫秒"><a href="#毫秒" class="headerlink" title="毫秒"></a><strong>毫秒</strong></h3><p>System.currentTimeMillis()  获取当前时间并转为毫秒数<br>System.currentTimeMillis() /1000 获取当前时间并转为秒数</p><h2 id="字符串常用的函数"><a href="#字符串常用的函数" class="headerlink" title="字符串常用的函数"></a><strong>字符串常用的函数</strong></h2><p>如果IDE没有代码自动补全功能，所以你应该记住下面的这些方法。<br>toCharArray() // 获得字符串对应的char数组<br>Arrays.sort() // 数组排序<br>Arrays.toString(char[] a) // 数组转成字符串<br>charAt(int x) // 获得某个索引处的字符<br>length() // 字符串长度<br>length // 数组大小</p><h3 id="随机产生26个字母中的20个-可重复"><a href="#随机产生26个字母中的20个-可重复" class="headerlink" title="随机产生26个字母中的20个 可重复"></a><strong>随机产生26个字母中的20个 可重复</strong></h3><pre><code>public Set getChar(){            Set numberSet01 = new HashSet();           Random rdm = new Random();           char ch;           while(numberSet01.size()&lt;20){               int rdGet = Math.abs(rdm.nextInt())%26+97;//产生97到122的随机数a-z值               ch=(char)rdGet;               numberSet01.add(ch);               //Set中是不能放进重复的值的，当它有20个时，就满足你的条件了            }              return numberSet01;           }   </code></pre><h3 id="给定一个java-util-Date对象，如何转化为”2007-3-22-20-23-22”格式的字符串"><a href="#给定一个java-util-Date对象，如何转化为”2007-3-22-20-23-22”格式的字符串" class="headerlink" title="给定一个java.util.Date对象，如何转化为”2007-3-22 20:23:22”格式的字符串"></a><strong>给定一个java.util.Date对象，如何转化为”2007-3-22 20:23:22”格式的字符串</strong></h3><pre><code>   public String date2FormatStr(Date date)       {          SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);          String str = sdf.format(date);          return str;        }   </code></pre><h3 id="判断是否是一个数的因子"><a href="#判断是否是一个数的因子" class="headerlink" title="判断是否是一个数的因子"></a><strong>判断是否是一个数的因子</strong></h3><p>  //如果余数为0说明 该除数是被除数的因子<br>             if(i % j==0)</p><h3 id="弹出对话框并从中获取用户输入的值保存到str中"><a href="#弹出对话框并从中获取用户输入的值保存到str中" class="headerlink" title="弹出对话框并从中获取用户输入的值保存到str中"></a><strong>弹出对话框并从中获取用户输入的值保存到str中</strong></h3><p>String str=javax.swing.JOptionPane.showInputDialog(“请输入N的值（输入exit退出）：”);<br>//用到str的时候可以转换为相应的类型 如<br>int N=Integer.parseInt(str);</p><h3 id="能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？"><a href="#能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？" class="headerlink" title="能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？"></a><strong>能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？</strong></h3><p>是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 127</p><h3 id="哪个类包含-clone-方法？是-Cloneable-还是-Object"><a href="#哪个类包含-clone-方法？是-Cloneable-还是-Object" class="headerlink" title="哪个类包含 clone 方法？是 Cloneable 还是 Object"></a><strong>哪个类包含 clone 方法？是 Cloneable 还是 Object</strong></h3><p>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义</p><h3 id="为什么-Java-中的-String-是不可变的（Immutable）"><a href="#为什么-Java-中的-String-是不可变的（Immutable）" class="headerlink" title="为什么 Java 中的 String 是不可变的（Immutable）"></a><strong>为什么 Java 中的 String 是不可变的（Immutable）</strong></h3><p>Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串</p><h3 id="Java-中的构造器链是什么"><a href="#Java-中的构造器链是什么" class="headerlink" title="Java 中的构造器链是什么"></a><strong>Java 中的构造器链是什么</strong></h3><p>当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现</p><h3 id="Java-中堆和栈有什么区别"><a href="#Java-中堆和栈有什么区别" class="headerlink" title="Java 中堆和栈有什么区别"></a><strong>Java 中堆和栈有什么区别</strong></h3><p>VM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享</p><h3 id="Java-中的-HashSet，内部是如何工作的？"><a href="#Java-中的-HashSet，内部是如何工作的？" class="headerlink" title="Java 中的 HashSet，内部是如何工作的？"></a><strong>Java 中的 HashSet，内部是如何工作的？</strong></h3><p>HashSet 的内部采用 HashMap来实现。由于 Map 需要 key 和 value，所以所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的 key，只允许有一个null key，意思就是 HashSet 中只允许存储一个 null 对象。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态的应用（工厂模式）</title>
      <link href="/2018/09/17/2018-9-17-%E5%A4%9A%E6%80%81/"/>
      <url>/2018/09/17/2018-9-17-%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h3 id="运用多态"><a href="#运用多态" class="headerlink" title="运用多态"></a><strong>运用多态</strong></h3><p><strong>作用：</strong>可以根据需要切换子类即面向接口编程，如果使用配置文件那么连源代码都不需要改;<br>因为父类拥有所有子类的共有的方法，可以替换子类更改方法的实现方式<br>eg.切换不同的容器 Collection c= new ArrayList();<br>比较不确定对象的大小或属性 该对象先得实现compare接口;<br><img src="https://viabcde.github.io/images/2018-09-17/多态1.png" alt="duotai"><br>然后在比较的方法里运用多态的思想 用接口类型来比较对象的大小<br><img src="https://viabcde.github.io/images/2018-09-17/多态2.png" alt="duotai2"><br>第1处多态：根据传入的不同类型的对象比较大小<br>第2处多态：在比较大小时，比较方式定义为接口，利用多态思想传入不同的比较策略<br><strong>总结：</strong>策略模式就是运用接口多态的思想只需要把固定的策略作为接口并写在源代码里，而接口的实现作为参数传入的，当需要变更策略（即接口算法的实现）时只需要替换实现类即可 不需要修改源代码    </p><h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a><strong>示例代码：</strong></h3><p><strong>测试类</strong></p><pre><code>public class Test {    public static void main(String[] args) {        //int[] a = {9, 5, 3, 7, 1};        //Cat[] a = {new Cat(5, 5), new Cat(3, 3), new Cat(1, 1)};        Dog[] a = {new Dog(5), new Dog(3), new Dog(1)};        DataSorter.p(a);        System.out.println();        DataSorter.sort(a);        //java.util.Arrays.sort(a);        DataSorter.p(a);    }}</code></pre><p><strong>接口</strong></p><pre><code>public interface Comparable {    public int compareTo(Object o);}</code></pre><p><strong>面向接口编码</strong></p><pre><code>public class DataSorter {    public static void sort(Object[] a) {        for(int i=a.length; i&gt;0; i--) {            for(int j=0; j&lt;i-1; j++) {                Comparable o1 = (Comparable)a[j];                Comparable o2 = (Comparable)a[j+1];                if(o1.compareTo(o2) == 1) {                    swap(a, j , j+1);                }            }        }    }    private static void swap(Object[] a, int x, int y) {        Object temp = a[x];        a[x] = a[y];        a[y] = temp;    }    public static void sort(int[] a) {        for(int i=a.length; i&gt;0; i--) {            for(int j=0; j&lt;i-1; j++) {                if(a[j] &gt; a[j+1]) {                    swap(a, j , j+1);                }            }        }    }    private static void swap(int[] a, int x, int y) {        int temp = a[x];        a[x] = a[y];        a[y] = temp;    }    public static void p(int[] a) {        for(int i=0; i&lt;a.length; i++) {            System.out.print(a[i] + &quot; &quot;);        }        System.out.println();    }    public static void p(Object[] a) {        for(int i=0; i&lt;a.length; i++) {            System.out.print(a[i] + &quot; &quot;);        }        System.out.println();    }}</code></pre><p><strong>任何实现接口的类都能比较</strong></p><pre><code>public class Dog implements Comparable {    public Dog(int food) {        super();        this.food = food;    }    private int food;    public int getFood() {        return food;    }    public void setFood(int food) {        this.food = food;    }    @Override    public int compareTo(Object o) {        Dog d = (Dog)o;        if(this.food &gt; d.getFood()) return 1;        else if(this.food &lt; d.getFood()) return -1;        else return 0;    }    @Override    public String toString() {        return this.food + &quot;&quot;;    }}</code></pre><h3 id="获得当前的时间戳"><a href="#获得当前的时间戳" class="headerlink" title="获得当前的时间戳"></a>获得当前的时间戳</h3><p><img src="https://viabcde.github.io/images/2018-09-17/获取当前的时间戳.png" alt="shijianchuo"></p><h3 id="单例："><a href="#单例：" class="headerlink" title="单例："></a>单例：</h3><p>在对象的类里面 用静态方法new 对象本身 再通过暴露 getInstance的这个方法去让其他类获取这个对象 从而实现单例<br><img src="https://viabcde.github.io/images/2018-09-17/单例.png" alt="danli">  </p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p><img src="https://viabcde.github.io/images/all/2018092901.png" alt="dai"><br>通过工厂来实现对象的管理与创建 ：<br>因为父类拥有所有子类的公共方法，通过父类来调用方法可以在替换子类时只需替换即可，不需要改代码<br><img src="https://viabcde.github.io/images/2018-09-17/工厂模式.png" alt="gongchanmoshi">  </p><p>这样当子类更替的时候只需要修改一处即可不需要多处修改<br>并且 子类也可以运用多态的思想创建相同父类类型的不同子类对象<br>运用多态，通过继承抽象工厂来实现工厂的管理与创建 可以创建相同抽象工厂类型的不同子类对象</p><h3 id="简单工厂与抽象工厂对比"><a href="#简单工厂与抽象工厂对比" class="headerlink" title="简单工厂与抽象工厂对比"></a>简单工厂与抽象工厂对比</h3><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>只是对类的管理 用来产生多个对象<br>优点：增加扩展工厂的产品对象容易，只需直接增加<br>缺点：相同系列的子类实现要修改时还要在产生一个新的工厂</p><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>则运用了多态的思想 可以创建相同抽象工厂类型的子类对象<br>优点：解决了简单工厂的缺点<br>缺点：扩展工厂的产品困难 ，需要在每一个系列的工厂都增加</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java生成二维码</title>
      <link href="/2018/09/17/2018-9-17-%E7%94%9F%E6%88%90%E4%BA%8C%E4%BD%8D%E7%A0%81/"/>
      <url>/2018/09/17/2018-9-17-%E7%94%9F%E6%88%90%E4%BA%8C%E4%BD%8D%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>jdk:1.6<br>build path – add external archives 把下载好的QRCode.jar引入<br>复制以下代码 运行即可生成二维码  </p><pre><code>import java.awt.Color;import java.awt.Graphics2D;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import java.io.UnsupportedEncodingException;import javax.imageio.ImageIO;import com.swetake.util.Qrcode;public class QrcodeImg {    /**     * 生成二维码图片     * @param content 二维码内容     * @param imgPath 二维码图片的保存路径     */    public static void getQrcodeImg(String content,String imgPath){        int width=140;        int height=140;        //实例化Qrcode        Qrcode qrcode=new Qrcode();        //设置二维码的排错率L(7%) M(15%) Q(25%) H(35%)        qrcode.setQrcodeErrorCorrect(&#39;M&#39;);        qrcode.setQrcodeEncodeMode(&#39;B&#39;);                //设置二维码尺寸(1~49)        qrcode.setQrcodeVersion(7);        //设置图片尺寸        BufferedImage bufImg=new BufferedImage(width, height, BufferedImage.TYPE_INT_BGR);        //绘制二维码图片        Graphics2D gs=bufImg.createGraphics();        //设置二维码背景颜色        gs.setBackground(Color.WHITE);        //创建一个矩形区域        gs.clearRect(0, 0, width, height);        //设置二维码的图片颜色值 黑色        gs.setColor(Color.BLACK);        //获取内容的字节数组,设置编码集        try {            byte[] contentBytes=content.getBytes(&quot;utf-8&quot;);            int pixoff=2;            //输出二维码            //fillRect（左上角x坐标，左上角y坐标，绘制的每一个小黑正方形的长，绘制的每一个小黑正方形的宽）            if(contentBytes.length&gt;0&amp;&amp;contentBytes.length&lt;120){                //calQrcode函数功能：将字符串传换位二维码的01矩阵                boolean[][] codeOut=qrcode.calQrcode(contentBytes);                for(int i=0;i&lt;codeOut.length;i++){                    for(int j=0;j&lt;codeOut.length;j++){                        if(codeOut[j][i]){                            gs.fillRect(j*3+pixoff, i*3+pixoff, 1, 1);                        }                    }                }                }            gs.dispose();            bufImg.flush();            //生成二维码图片            File imgFile=new File(imgPath);            ImageIO.write(bufImg, &quot;png&quot;, imgFile);            System.out.println(&quot;二维码生成成功！&quot;);        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }    }    public static void main(String[] args) {        getQrcodeImg(&quot;https://viabcde.github.io/images/201811/20181107.png&quot;, &quot;E:\\test.png&quot;);    }}</code></pre><h3 id="相关细节说明"><a href="#相关细节说明" class="headerlink" title="相关细节说明"></a><strong>相关细节说明</strong></h3><p>只有一个getQrcodeImg（）方法<br>其中参数  </p><pre><code> * @param content 二维码内容   * @param imgPath 二维码图片的保存路径  </code></pre><p>实例化jar包中QRCode类  </p><p><strong>设置好实例化出来的对象的基本属性（排错率 尺寸）</strong></p><pre><code>        qrcode.setQrcodeErrorCorrect(&#39;M&#39;);        qrcode.setQrcodeEncodeMode(&#39;B&#39;); </code></pre><p>1.设置最低排错率L，mode为A时：45-47：宽高（1-25个字符）<br>2.设置排错率M时，mode为A时，只能存20位（纯数字）；<br>3.设置最低拍错率L，mode为B,时：45-47:宽高（1-17个字符）<br><strong>所要生成的二维码图片的基本属性  （尺寸）</strong></p><h3 id="fillRect"><a href="#fillRect" class="headerlink" title="//fillRect"></a><strong>//fillRect</strong></h3><p>fillRect（左上角x坐标，左上角y坐标，绘制的每一个小黑正方形的长，绘制的每一个小黑正方形的宽）<br><strong>calQrcode函数功能：将字符串传换位二维码的01矩阵</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2018/09/17/2018-9-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2018/09/17/2018-9-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h3><p>运行次数而非时间（因为不同机器的运行环境不同）</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a><strong>空间复杂度</strong></h3><p>占用内存大小</p><h3 id="程序的难易程度"><a href="#程序的难易程度" class="headerlink" title="程序的难易程度"></a><strong>程序的难易程度</strong></h3><p>能否一读便通</p><h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a><strong>健壮性</strong></h3><p>能处理各种非法异常<br>字段表示一个事物的属性（列）<br>记录表示一个事物（行）<br>表是同一类事物的集合<br>视图是为了简化查询<br>程序 = 数据的存储 + 数据的操作 + 可以被计算机执行的语言</p><h3 id="用链表实现栈"><a href="#用链表实现栈" class="headerlink" title="用链表实现栈"></a><strong>用链表实现栈</strong></h3><pre><code>class Node&lt;E&gt; {     Node&lt;E&gt;next=null;     E data;     public Node(E data) {this.data=data;}}public class Stack&lt;E&gt; {    Node&lt;E&gt;top=null;    public boolean isEmpty() {        return top==null;    }    /*新建一个结点，该节点指向当前的头结点     *再修改top指向新建的结点*/    public void push(E data) {        Node&lt;E&gt;newNode=new Node&lt;E&gt;(data);        newNode.next=top;        top=newNode;    }    /*     * 将当前的top结点的值保存到data     * 再把top的指针指向下一个结点*/    public E pop() {        if(isEmpty())            return null;        E data=top.data;        top=top.next;        return data;    }    public E peek() {        if(isEmpty()) {            return null;        }        return top.data;    }}</code></pre><h3 id="数组实现栈"><a href="#数组实现栈" class="headerlink" title="数组实现栈"></a><strong>数组实现栈</strong></h3><pre><code>import java.util.Arrays;public class Mystack&lt;E&gt;{        private Object[] stack;        private int size;        public Mystack() {            stack=new Object[10];        }        public boolean isEmpty() {            return size==0;        }        public E peek() {            if(isEmpty()) {                return null;            }            return(E) stack[size-1];        }        public E pop() {            E e=peek();            stack[size-1]=null;            size--;            return e;        }        public E push(E item) {            ensureCapacity(size+1);            stack[size++]=item;            return item;        }        private void ensureCapacity(int size) {            int len=stack.length;            if(size&gt;len) {                int newLen=10;                stack=Arrays.copyOf(stack,newLen);            }        }}</code></pre><h3 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a><strong>排序问题</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-21/排序.png" alt="enter description here"><br> 对于不同情况，即需要排序的数据的大小n<br> 当n较小时直接使用选择或插入排序<br> 若数据大部分有序的可以选择冒泡或快速排序<br> 但是，要判断是否基本有序的标准很难拿捏，所以…<br> 当n较大时，可以选择堆排序和归并排序等因为它们的时间复杂度为nlogn，从数学的角度来讲，n越大，其递增的速度比n^2慢<br>快些选堆不稳定<br>记忆：堆在北方的方言是坟墓的意思，不慎重考虑，快些选坟墓就不稳定，可能会诈尸！即使2个数是一样的，它还是会做一遍排序操作  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与并发库</title>
      <link href="/2018/09/17/2018-9-17-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2018/09/17/2018-9-17-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><strong>死锁</strong></h3><p>当方法1调用时需要的数据被方法2占用 此时方法1等待方法2<br>但方法2的调用需要方法1 此时方法2又等待方法1<br>构成了死锁</p><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a><strong>同步代码块</strong></h3><p>synchronized(this){}<br>这里的this 可以使任意一个类 如public class  sdfsdgjksdjgh{}也可以  </p><h3 id="线程安全问题："><a href="#线程安全问题：" class="headerlink" title="线程安全问题："></a><strong>线程安全问题：</strong></h3><p>线程安全问题都是由全局变量及静态变量引起的，定义在方法内部的局部私有变量是没有线程安全与否一说的。 </p><h2 id="线程的生命周期的五种状态"><a href="#线程的生命周期的五种状态" class="headerlink" title="线程的生命周期的五种状态"></a><strong>线程的生命周期的五种状态</strong></h2><h3 id="新建（new-Thread）"><a href="#新建（new-Thread）" class="headerlink" title="新建（new Thread）"></a><strong>新建（new Thread）</strong></h3><p>例如：Thread  t1=new Thread();  </p><h3 id="就绪（runnable）"><a href="#就绪（runnable）" class="headerlink" title="就绪（runnable）"></a><strong>就绪（runnable）</strong></h3><p>例如：t1.start();<br>线程已经被启动，正在等待被分配给CPU时间片，即此时线程正在就绪队列中排队等候得到CPU资源。</p><h3 id="运行（running）"><a href="#运行（running）" class="headerlink" title="运行（running）"></a><strong>运行（running）</strong></h3><p>线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，否则它将一直运行到结束。  </p><h3 id="死亡（dead）"><a href="#死亡（dead）" class="headerlink" title="死亡（dead）"></a><strong>死亡（dead）</strong></h3><p>异常终止：调用stop()方法让一个线程终止运行    </p><h3 id="堵塞（blocked）"><a href="#堵塞（blocked）" class="headerlink" title="堵塞（blocked）"></a><strong>堵塞（blocked）</strong></h3><p>正在睡眠：用sleep(long t) 方法可使线程进入睡眠。一个睡眠着的线程在指定的时间过去可进入就绪状态。<br>正在等待：调用wait()方法。（调用notify()方法回到就绪状态）<br>被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）  </p><h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a><strong>sleep和wait的区别</strong></h3><p>sleep是线程类（Thread）的方法，wait是Object类的方法；<br>sleep不释放对象锁，wait放弃对象锁  </p><h3 id="创建线程的2种方法"><a href="#创建线程的2种方法" class="headerlink" title="创建线程的2种方法"></a><strong>创建线程的2种方法</strong></h3><p>运用多态机制 创建Thread的子类对象 thread1 并且覆盖父类的run方法<br>Thread thread = new Thread(){public void run(){}}<br>多态的概念 thread 是 Thrad的一个子类<br>Thread 在start()后调用run()，该run方法 先判断是否有Runable 参数 有则 调用 Runable.run() 没有则往下执行其他代码<br>如果是 子类 覆盖了run() 则不会去找Runable 直接执行子类的run()<br>此时对象可以直接使用start方法启动线程</p><pre><code>Thread thread1=new Thread() {                        public void run() {                while(true) {                    try {                        Thread.sleep(500);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(this.getName());                }                           }        };        thread1.start();</code></pre><p>或</p><pre><code>package thread;public class demo_1 {    public static void main(String[] args) {        cat c=new cat();        c.start();    }}class cat extends Thread{    public void run() {        while(true) {            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                // TODO Auto-generated catch block                e.printStackTrace();            }        System.out.println(&quot;11111&quot;);    }    }}</code></pre><p>如果是实现runable接口 则需要把对象传入Thread 后<br>对象才可调用run启动线程<br>dog d=new dog();<br>Thread t=new Thread(d);<br>d.run();<br>即覆盖实现了Ruable的类d<br>等价于Thread t=new Thread(new dog().run());</p><pre><code>package thread;public class demo_2 {    public static void main(String[] args) {        dog d=new dog();        Thread t=new Thread(d);        d.run();    }}class dog implements Runnable{    public void run() {        while(true) {            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                // TODO Auto-generated catch block                e.printStackTrace();            }        System.out.println(&quot;11111&quot;);    }    }}</code></pre><h2 id="线程通信-wait-notify"><a href="#线程通信-wait-notify" class="headerlink" title="线程通信 wait() notify()"></a><strong>线程通信 wait() notify()</strong></h2><p><strong>wait() 和 nitify() 方法属于类而非线程独有</strong><br><strong>功能：</strong>实现子线程输出10次 主线程main输出10次 如此循环往复50次<br><strong>思路：</strong>因为子线程先输出 所以子线程的输出逻辑应该在主线程之前,用一个boolean控制子线程和main线程能否开启,各自线程在执行完自己的逻辑后用notify 唤醒其他线程  </p><pre><code>import java.util.concurrent.atomic.AtomicInteger;public class TraditionalThreadCommunication {public static void main(String[] args) {    final Business business = new Business();    //重写一个线程的runable()并启动它    new Thread(            new Runnable() {                @Override                public void run() {                    for(int i=1;i&lt;=50;i++){                        business.sub(i);                    }                }            }    ).start();    for(int i=1;i&lt;=50;i++){        business.main(i);    }}}//需要同步的代码放在同一个类 由同一个类（锁）控制访问class Business {private boolean bShouldSub = true;public synchronized void sub(int i){while(!bShouldSub){try {this.wait();} catch (InterruptedException e) {// TODO Auto-generated catch blocke.printStackTrace();}}for(int j=1;j&lt;=10;j++){System.out.println(&quot;sub thread sequence of &quot; + j + &quot;,loop of &quot; + i);}bShouldSub = false;this.notify();}  public synchronized void main(int i){        while(bShouldSub){            try {                this.wait();            } catch (InterruptedException e) {                // TODO Auto-generated catch block                e.printStackTrace();            }        }        for(int j=1;j&lt;=10;j++){            System.out.println(&quot;main thread sequence of &quot; + j + &quot;,loop of &quot; + i);        }        bShouldSub = true;        this.notify();  }}</code></pre><h2 id="condition-await-和condition-signal"><a href="#condition-await-和condition-signal" class="headerlink" title="condition.await()和condition.signal()"></a><strong>condition.await()和condition.signal()</strong></h2><pre><code>condition.await()和condition.signal()类似于 wait 和notify 但后者只能写在synchornized中 前者只能在lock对象中。且能唤醒指定的线程&gt;&gt;&gt; 详情见三个线程的互相通信import java.util.concurrent.atomic.AtomicInteger;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class ConditionCommunication {    public static void main(String[] args) {        final Business business = new Business();        new Thread(                new Runnable() {                    @Override                    public void run() {                        for(int i=1;i&lt;=50;i++){                            business.sub(i);                        }                    }                }        ).start();        for(int i=1;i&lt;=50;i++){            business.main(i);        }    }    static class Business {            Lock lock = new ReentrantLock();            Condition condition = lock.newCondition();          private boolean bShouldSub = true;          public  void sub(int i){              lock.lock();              try{                  while(!bShouldSub){                      try {                        condition.await();                    } catch (Exception e) {                        // TODO Auto-generated catch block                        e.printStackTrace();                    }                  }                    for(int j=1;j&lt;=10;j++){                        System.out.println(&quot;sub thread sequence of &quot; + j + &quot;,loop of &quot; + i);                    }                  bShouldSub = false;                  condition.signal();              }finally{                  lock.unlock();              }          }          public  void main(int i){              lock.lock();              try{                 while(bShouldSub){                        try {                            condition.await();                        } catch (Exception e) {                            // TODO Auto-generated catch block                            e.printStackTrace();                        }                    }                    for(int j=1;j&lt;=100;j++){                        System.out.println(&quot;main thread sequence of &quot; + j + &quot;,loop of &quot; + i);                    }                    bShouldSub = true;                    condition.signal();          }finally{              lock.unlock();          }      }    }}</code></pre><h2 id="三个线程互相通信-线程1启动线程2-2启动3-3启动1"><a href="#三个线程互相通信-线程1启动线程2-2启动3-3启动1" class="headerlink" title="三个线程互相通信 线程1启动线程2 2启动3 3启动1"></a><strong>三个线程互相通信 线程1启动线程2 2启动3 3启动1</strong></h2><pre><code>思路：在类中定义三个condictuonLock lock = new ReentrantLock();Condition condition1 = lock.newCondition();Condition condition2 = lock.newCondition();Condition condition3 = lock.newCondition();然后每个方法使用一个condictionimport java.util.concurrent.atomic.AtomicInteger;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class ThreeConditionCommunication {    public static void main(String[] args) {        final Business business = new Business();        new Thread(                new Runnable() {                    @Override                    public void run() {                        for(int i=1;i&lt;=50;i++){                            business.sub2(i);                        }                    }                }        ).start();        new Thread(                new Runnable() {                    @Override                    public void run() {                        for(int i=1;i&lt;=50;i++){                            business.sub3(i);                        }                    }                }        ).start();              for(int i=1;i&lt;=50;i++){            business.main(i);        }    }    static class Business {            Lock lock = new ReentrantLock();            Condition condition1 = lock.newCondition();            Condition condition2 = lock.newCondition();            Condition condition3 = lock.newCondition();          private int shouldSub = 1;          public  void sub2(int i){              lock.lock();              try{                  while(shouldSub != 2){                      try {                        condition2.await();                    } catch (Exception e) {                        // TODO Auto-generated catch block                        e.printStackTrace();                    }                  }                    for(int j=1;j&lt;=10;j++){                        System.out.println(&quot;sub2 thread sequence of &quot; + j + &quot;,loop of &quot; + i);                    }                  shouldSub = 3;                  condition3.signal();              }finally{                  lock.unlock();              }          }          public  void sub3(int i){              lock.lock();              try{                  while(shouldSub != 3){                      try {                        condition3.await();                    } catch (Exception e) {                        // TODO Auto-generated catch block                        e.printStackTrace();                    }                  }                    for(int j=1;j&lt;=20;j++){                        System.out.println(&quot;sub3 thread sequence of &quot; + j + &quot;,loop of &quot; + i);                    }                  shouldSub = 1;                  condition1.signal();              }finally{                  lock.unlock();              }          }                 public  void main(int i){              lock.lock();              try{                 while(shouldSub != 1){                        try {                            condition1.await();                        } catch (Exception e) {                            // TODO Auto-generated catch block                            e.printStackTrace();                        }                    }                    for(int j=1;j&lt;=100;j++){                        System.out.println(&quot;main thread sequence of &quot; + j + &quot;,loop of &quot; + i);                    }                    shouldSub = 2;                    condition2.signal();          }finally{              lock.unlock();          }      }    }}</code></pre><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a><strong>线程安全问题</strong></h2><h3 id="适应自旋锁-内核锁-自旋锁"><a href="#适应自旋锁-内核锁-自旋锁" class="headerlink" title="适应自旋锁=内核锁+自旋锁"></a><strong>适应自旋锁=内核锁+自旋锁</strong></h3><p>内核锁就是如果资源被占用就排队，知道别人提醒它资源可用<br>自旋锁就是如果资源被占用，就会间歇性的不断尝试去访问资源<br>2者的折中就是资源被占用，适应一定的策略隔一段时间去请求资源</p><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a><strong>lock</strong></h3><pre><code>lock方法不属于线程 每个类可以使用lock来实现同步import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class LockTest {    public static void main(String[] args) {        new LockTest().init();    }    private void init(){        final Outputer outputer = new Outputer();        new Thread(new Runnable(){            @Override            public void run() {                while(true){                    try {                        Thread.sleep(10);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    outputer.output(&quot;zhangxiaoxiang&quot;);                }            }        }).start();        new Thread(new Runnable(){            @Override            public void run() {                while(true){                    try {                        Thread.sleep(10);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    outputer.output(&quot;lihuoming&quot;);                }            }        }).start();    }    static class Outputer{        Lock lock = new ReentrantLock();        public void output(String name){            int len = name.length();            lock.lock();            //用try的原因 防止 syso语句异常 没有解锁 造成死锁            try{                for(int i=0;i&lt;len;i++){                    System.out.print(name.charAt(i));                }                System.out.println();            }finally{                lock.unlock();            }        }        public synchronized void output2(String name){            int len = name.length();            for(int i=0;i&lt;len;i++){                    System.out.print(name.charAt(i));            }            System.out.println();        }        public static synchronized void output3(String name){            int len = name.length();            for(int i=0;i&lt;len;i++){                    System.out.print(name.charAt(i));            }            System.out.println();        }       }}</code></pre><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a><strong>读写锁</strong></h3><pre><code>读写锁不是属于线程的 而是属于类import java.util.Random;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;public class ReadWriteLockTest {    public static void main(String[] args) {        final Queue3 q3 = new Queue3();        for(int i=0;i&lt;3;i++)        {            new Thread(){                public void run(){                    while(true){                        q3.get();                                           }                }            }.start();            new Thread(){                public void run(){                    while(true){                        q3.put(new Random().nextInt(10000));                    }                }                       }.start();        }    }}class Queue3{    private Object data = null;//共享数据，只能有一个线程能写该数据，但可以有多个线程同时读该数据。    ReadWriteLock rwl = new ReentrantReadWriteLock();    public void get(){        //读锁 能同时访问 但是 当第一个线程读的时候数据为空        //则它会解开读锁 再为当前数据加上写锁 其他线程无法访问直至第一个线程从        //数据库获取到了数据并传入给了该被读取的变量        rwl.readLock().lock();        try {            System.out.println(Thread.currentThread().getName() + &quot; be ready to read data!&quot;);            Thread.sleep((long)(Math.random()*1000));            System.out.println(Thread.currentThread().getName() + &quot;have read data :&quot; + data);                   } catch (InterruptedException e) {            e.printStackTrace();        }finally{            rwl.readLock().unlock();        }    }    public void put(Object data){        //写锁 不能同时访问        rwl.writeLock().lock();        try {            System.out.println(Thread.currentThread().getName() + &quot; be ready to write data!&quot;);                              Thread.sleep((long)(Math.random()*1000));            this.data = data;                   System.out.println(Thread.currentThread().getName() + &quot; have write data: &quot; + data);                         } catch (InterruptedException e) {            e.printStackTrace();        }finally{            rwl.writeLock().unlock();        }    }}</code></pre><h3 id="缓存的原理"><a href="#缓存的原理" class="headerlink" title="缓存的原理"></a><strong>缓存的原理</strong></h3><pre><code>缓存的原理 从map里根据key读取数据加读锁如果map里没有，则解开读锁 加上写锁 从数据库读取并写入缓存 然后写锁解开 加上读锁注意：因为可能有多个线程同时运行到 解开读锁这一步 此时不需要都去数据库读取数据 只需读取一次即可 所以仍然需要再次判读是否有线程抢先读取了import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;public class CacheDemo {    private Map&lt;String, Object&gt; cache = new HashMap&lt;String, Object&gt;();    public static void main(String[] args) {    }    //加锁的原因：如果有多个线程同时访问且当前数据为空 则都会去数据库get 重复执行了    //如果数据为空 则把读锁解开 把写锁加上 从数据库获取数据后 写锁解开 还原为读锁    private ReadWriteLock rwl = new ReentrantReadWriteLock();    public  Object getData(String key){        rwl.readLock().lock();        Object value = null;        try{            value = cache.get(key);            if(value == null){                rwl.readLock().unlock();                rwl.writeLock().lock();                try{                    //这里再次判断数据是否为空的原因：是因为可能出现多个线程已经执行到了上面的rwl.writeLock().lock();语句                    //如果没有再次判断，虽然第一个线程已经获取了数据，下一个线程也会再次从数据库获取数据                    if(value==null){                        value = &quot;aaaa&quot;;//实际是去queryDB();                    }                }finally{                    rwl.writeLock().unlock();                }                rwl.readLock().lock();            }        }finally{            rwl.readLock().unlock();        }        return value;    }}</code></pre><h3 id="线程范围的数据共享（用HashMap版）"><a href="#线程范围的数据共享（用HashMap版）" class="headerlink" title="线程范围的数据共享（用HashMap版）"></a><strong>线程范围的数据共享（用HashMap版）</strong></h3><p>功能：使用HashMap实现仅在单个线程内数据共享<br>思路：把每个线程的线程作为key 数据作为value存入map</p><pre><code>import java.util.HashMap;import java.util.Map;import java.util.Random;public class ThreadScopeShareData {    private static int data = 0;    private static Map&lt;Thread, Integer&gt; threadData = new HashMap&lt;Thread, Integer&gt;();    public static void main(String[] args) {        for(int i=0;i&lt;40;i++){            new Thread(new Runnable(){                @Override                public void run() {                     data = new Random().nextInt();                    System.out.println(Thread.currentThread().getName()                             + &quot; has put data :&quot; + data);                    //把每个线程的数据单独保存起来 否则当线程创建后run方法运行一半                     //其他线程可能会修改了本线程的数据                    threadData.put(Thread.currentThread(), data);                    new A().get();                    new B().get();                }            }).start();/*          try {                Thread.sleep(100);            } catch (InterruptedException e) {                // TODO Auto-generated catch block                e.printStackTrace();            }*/        }    }    static class A{        public void get(){            int data = threadData.get(Thread.currentThread());            System.out.println(&quot;A from &quot; + Thread.currentThread().getName()                     + &quot; get data :&quot; + data);        }    }    static class B{        public void get(){            int data = threadData.get(Thread.currentThread());                      System.out.println(&quot;B from &quot; + Thread.currentThread().getName()                     + &quot; get data :&quot; + data);        }           }}</code></pre><h3 id="使用ThreadLocal实现线程范围内数据共享"><a href="#使用ThreadLocal实现线程范围内数据共享" class="headerlink" title="使用ThreadLocal实现线程范围内数据共享"></a><strong>使用ThreadLocal实现线程范围内数据共享</strong></h3><p>ThreadLocal在线程结束时便清空</p><pre><code>import java.util.HashMap;import java.util.Map;import java.util.Random;public class ThreadLocalTest {    public static void main(String[] args) {        for(int i=0;i&lt;2;i++){            new Thread(new Runnable(){                @Override                public void run() {                    int data = new Random().nextInt();                    MyThreadScopeData.getThreadInstance().setName(&quot;name&quot; + data);                    MyThreadScopeData.getThreadInstance().setAge(data);                    new A().get();                    new B().get();                }            }).start();        }    }    static class A{        public void get(){                    MyThreadScopeData myData =MyThreadScopeData.getThreadInstance();            System.out.println(&quot;A from &quot; + Thread.currentThread().getName()                     + &quot; getMyData: &quot; + myData.getName() + &quot;,&quot; +                    myData.getAge());        }    }    static class B{        public void get(){              MyThreadScopeData myData = MyThreadScopeData.getThreadInstance();            System.out.println(&quot;B from &quot; + Thread.currentThread().getName()                     + &quot; getMyData: &quot; + myData.getName() + &quot;,&quot; +                    myData.getAge());                   }           }}class MyThreadScopeData{    private MyThreadScopeData(){}    public static /*synchronized*/ MyThreadScopeData getThreadInstance(){    //该instance保留到当前线程死亡为止 系统自动clear        MyThreadScopeData instance = map.get();        if(instance == null){            instance = new MyThreadScopeData();            map.set(instance);        }        return instance;    }    private static ThreadLocal&lt;MyThreadScopeData&gt; map = new ThreadLocal&lt;MyThreadScopeData&gt;();    private String name;    private int age;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }}</code></pre><h3 id="线程间共享数据"><a href="#线程间共享数据" class="headerlink" title="线程间共享数据"></a><strong>线程间共享数据</strong></h3><pre><code>public class MultiThreadShareData {    private static ShareData1 data1 = new ShareData1();    public static void main(String[] args) {        ShareData1 data2 = new ShareData1();        //自定义的Runable方法，继承了Runable接口        new Thread(new MyRunnable1(data2)).start();        new Thread(new MyRunnable2(data2)).start();         }}       class MyRunnable1 implements Runnable{        private ShareData1 data1;        public MyRunnable1(ShareData1 data1){            this.data1 = data1;        }        public void run() {            data1.decrement();                  }    }    class MyRunnable2 implements Runnable{        private ShareData1 data1;        public MyRunnable2(ShareData1 data1){            this.data1 = data1;        }        public void run() {            data1.increment();        }    }    class ShareData1{        private int j = 0;        public synchronized void increment(){            j++;        }               public synchronized void decrement(){            j--;        }    }</code></pre><h3 id="3种线程池"><a href="#3种线程池" class="headerlink" title="3种线程池"></a><strong>3种线程池</strong></h3><pre><code>只需要调用线程池的excute()方法即可启动线程import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;public class ThreadPoolTest {    public static void main(String[] args) {        //线程池 自定义每次只能同时执行3个线程        ExecutorService threadPool = Executors.newFixedThreadPool(3);        //缓存线程池 可根据需要动态变化 可同时执行的线程数量        //ExecutorService threadPool = Executors.newCachedThreadPool();        //单线程池 线程死亡自动启动另一个线程 保证线程池有线程在运行        //ExecutorService threadPool = Executors.newSingleThreadExecutor();        for(int i=1;i&lt;=10;i++){            final int task = i;            threadPool.execute(new Runnable(){                @Override                public void run() {                    for(int j=1;j&lt;=10;j++){                        try {                            Thread.sleep(20);                        } catch (InterruptedException e) {                            // TODO Auto-generated catch block                            e.printStackTrace();                        }                        System.out.println(/*Thread.currentThread().getName() +&quot;  of&quot;+*/&quot; task  &quot;+ task +&quot; has loop  &quot; + j + &quot; times   &quot; );                    }                }            });        }        //以上代码虽然让线程以启动 但每个线程的run方法在执行的同时 以下的代码也同时执行        //如果此时调用shutdownNow()方法,很有可能会让执行一半的run方法停止 从而运行时报线程本打断的错误        //threadPool.shutdownNow();        //改为调用次方法 当全部线程空闲才关闭线程池        threadPool.shutdown();        System.out.println(&quot;all of 10 tasks have committed! &quot;);        //定时器 6s后执行 每个2s执行一次 缺点只能定制几秒以后 可以用目标时间减去此刻时间实现        Executors.newScheduledThreadPool(3).scheduleAtFixedRate(new Runnable(){            public void run() {System.out.println(&quot;bombing!&quot;);}            },6,2,TimeUnit.SECONDS);    }}</code></pre><h3 id="Callable-and-Future"><a href="#Callable-and-Future" class="headerlink" title="Callable and Future"></a><strong>Callable and Future</strong></h3><pre><code>package cn.itcast.heima2;import java.util.Random;import java.util.concurrent.Callable;import java.util.concurrent.CompletionService;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorCompletionService;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.TimeUnit;public class CallableAndFuture {    public static void main(String[] args) {        //future有什么用 ？等一会取得线程的执行结果        ExecutorService threadPool =  Executors.newSingleThreadExecutor();        Future&lt;String&gt; future =            threadPool.submit(                new Callable&lt;String&gt;() {                    public String call() throws Exception {                        Thread.sleep(2000);                        return &quot;hello&quot;;                    };                }        );        System.out.println(&quot;等待结果&quot;);        try {            //1s之内没有取得结果则报错            System.out.println(&quot;拿到结果：&quot; + future.get(1000,TimeUnit.SECONDS));        } catch (Exception e) {            e.printStackTrace();        }         //对线程池中的线程 先执行完的结果先被获取        //类似qq农场 那块才熟了收哪块        ExecutorService threadPool2 =  Executors.newFixedThreadPool(10);        CompletionService&lt;Integer&gt; completionService = new ExecutorCompletionService&lt;Integer&gt;(threadPool2);        for(int i=1;i&lt;=10;i++){            final int seq = i;            completionService.submit(new Callable&lt;Integer&gt;() {                @Override                public Integer call() throws Exception {                    Thread.sleep(new Random().nextInt(5000));                    return seq;                }            });        }        for(int i=0;i&lt;10;i++){            try {                System.out.println(                        completionService.take().get());            }  catch (Exception e) {                e.printStackTrace();            }        }    }}</code></pre><h3 id="控制能同时有几个线程并发Semaphore"><a href="#控制能同时有几个线程并发Semaphore" class="headerlink" title="控制能同时有几个线程并发Semaphore"></a><strong>控制能同时有几个线程并发Semaphore</strong></h3><pre><code>import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;public class SemaphoreTest {    public static void main(String[] args) {        ExecutorService service = Executors.newCachedThreadPool();        final  Semaphore sp = new Semaphore(5);        for(int i=0;i&lt;10;i++){            Runnable runnable = new Runnable(){                    public void run(){                    try {                        sp.acquire();                    } catch (InterruptedException e1) {                        e1.printStackTrace();                    }                    System.out.println(&quot;线程&quot; + Thread.currentThread().getName() +                             &quot;进入，当前已有&quot; + (5-sp.availablePermits()) + &quot;个并发&quot;);                    try {                        Thread.sleep((long)(Math.random()*10000));                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(&quot;线程&quot; + Thread.currentThread().getName() +                             &quot;即将离开&quot;);                                        sp.release();                    //下面代码有时候执行不准确，因为其没有和上面的代码合成原子单元                    System.out.println(&quot;线程&quot; + Thread.currentThread().getName() +                             &quot;已离开，当前已有&quot; + (3-sp.availablePermits()) + &quot;个并发&quot;);                                    }            };            service.execute(runnable);                  }    }}</code></pre><h3 id="控制只有3个线程同时完成后线程才能继续执行"><a href="#控制只有3个线程同时完成后线程才能继续执行" class="headerlink" title="控制只有3个线程同时完成后线程才能继续执行"></a><strong>控制只有3个线程同时完成后线程才能继续执行</strong></h3><pre><code>控制只有在线程池中3个线程都完成到达cb.wait()时，线程才同时继续运行import java.util.concurrent.CyclicBarrier;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class CyclicBarrierTest {    public static void main(String[] args) {        ExecutorService service = Executors.newCachedThreadPool();        final  CyclicBarrier cb = new CyclicBarrier(3);        for(int i=0;i&lt;3;i++){            Runnable runnable = new Runnable(){                    public void run(){                    try {                        Thread.sleep((long)(Math.random()*10000));                          System.out.println(&quot;线程&quot; + Thread.currentThread().getName() +                                 &quot;即将到达集合地点1，当前已有&quot; + (cb.getNumberWaiting()+1) + &quot;个已经到达，&quot; + (cb.getNumberWaiting()==2?&quot;都到齐了，继续走啊&quot;:&quot;正在等候&quot;));                                         cb.await();                        Thread.sleep((long)(Math.random()*10000));                          System.out.println(&quot;线程&quot; + Thread.currentThread().getName() +                                 &quot;即将到达集合地点2，当前已有&quot; + (cb.getNumberWaiting()+1) + &quot;个已经到达，&quot; + (cb.getNumberWaiting()==2?&quot;都到齐了，继续走啊&quot;:&quot;正在等候&quot;));                        cb.await();                         Thread.sleep((long)(Math.random()*10000));                          System.out.println(&quot;线程&quot; + Thread.currentThread().getName() +                                 &quot;即将到达集合地点3，当前已有&quot; + (cb.getNumberWaiting() + 1) + &quot;个已经到达，&quot; + (cb.getNumberWaiting()==2?&quot;都到齐了，继续走啊&quot;:&quot;正在等候&quot;));                                             cb.await();                                         } catch (Exception e) {                        e.printStackTrace();                    }                               }            };            service.execute(runnable);        }        service.shutdown();    }}</code></pre><h3 id="CountDownLatch的用法"><a href="#CountDownLatch的用法" class="headerlink" title="CountDownLatch的用法"></a><strong>CountDownLatch的用法</strong></h3><pre><code> 使用倒计时器 控制只有被唤几次才会醒    final CountDownLatch cdOrder = new CountDownLatch(1);import java.util.concurrent.CountDownLatch;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class CountdownLatchTest {    public static void main(String[] args) {        ExecutorService service = Executors.newCachedThreadPool();        //当处于await状态时 需要countDown1次才被唤醒        final CountDownLatch cdOrder = new CountDownLatch(1);        //当处于await状态时 需要countDown3次才被唤醒        final CountDownLatch cdAnswer = new CountDownLatch(3);              for(int i=0;i&lt;3;i++){            Runnable runnable = new Runnable(){                    public void run(){                    try {                        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() +                                 &quot;正准备接受命令&quot;);                                             cdOrder.await();                        System.out.println(&quot;线程&quot; + Thread.currentThread().getName() +                         &quot;已接受命令&quot;);                                                       Thread.sleep((long)(Math.random()*10000));                          System.out.println(&quot;线程&quot; + Thread.currentThread().getName() +                                 &quot;回应命令处理结果&quot;);                                                cdAnswer.countDown();                                           } catch (Exception e) {                        e.printStackTrace();                    }                               }            };            service.execute(runnable);        }               try {            Thread.sleep((long)(Math.random()*10000));            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() +                     &quot;即将发布命令&quot;);                                  cdOrder.countDown();            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() +             &quot;已发送命令，正在等待结果&quot;);                cdAnswer.await();            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() +             &quot;已收到所有响应结果&quot;);           } catch (Exception e) {            e.printStackTrace();        }                       service.shutdown();    }}</code></pre><h3 id="线程间使用Exchanger交换数据"><a href="#线程间使用Exchanger交换数据" class="headerlink" title="线程间使用Exchanger交换数据"></a><strong>线程间使用Exchanger交换数据</strong></h3><pre><code>将数据都放在同一个Exchanger中进行2个线程间的数据交换import java.util.concurrent.Exchanger;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ExchangerTest {    public static void main(String[] args) {        ExecutorService service = Executors.newCachedThreadPool();        final Exchanger exchanger = new Exchanger();        service.execute(new Runnable(){            public void run() {                try {                                   String data1 = &quot;zxx&quot;;                    System.out.println(&quot;a线程&quot; + Thread.currentThread().getName() +                     &quot;正在把数据&quot; + data1 +&quot;换出去&quot;);                    Thread.sleep((long)(Math.random()*10000));                    String data2 = (String)exchanger.exchange(data1);                    System.out.println(&quot;a线程&quot; + Thread.currentThread().getName() +                     &quot;换回的数据为&quot; + data2);                }catch(Exception e){                }            }           });        service.execute(new Runnable(){            public void run() {                try {                                   String data1 = &quot;lhm&quot;;                    System.out.println(&quot;线程&quot; + Thread.currentThread().getName() +                     &quot;正在把数据&quot; + data1 +&quot;换出去&quot;);                    Thread.sleep((long)(Math.random()*10000));                                      String data2 = (String)exchanger.exchange(data1);                    System.out.println(&quot;线程&quot; + Thread.currentThread().getName() +                     &quot;换回的数据为&quot; + data2);                }catch(Exception e){                }                           }           });         }}</code></pre><h3 id="使用阻塞队列存取数据"><a href="#使用阻塞队列存取数据" class="headerlink" title="使用阻塞队列存取数据"></a><strong>使用阻塞队列存取数据</strong></h3><pre><code>存数据queue.put(1);取数据queue.take(）;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;public class BlockingQueueTest {    public static void main(String[] args) {    //自定义队列能存放3个数据        final BlockingQueue queue = new ArrayBlockingQueue(3);        for(int i=0;i&lt;2;i++){            new Thread(){                public void run(){                    while(true){                        try {                            Thread.sleep((long)(Math.random()*1000));                            System.out.println(Thread.currentThread().getName() + &quot;准备放数据!&quot;);                            //放数据                            queue.put(1);                            System.out.println(Thread.currentThread().getName() + &quot;已经放了数据，&quot; +                                                                   &quot;队列目前有&quot; + queue.size() + &quot;个数据&quot;);                        } catch (InterruptedException e) {                            e.printStackTrace();                        }                    }                }            }.start();        }        new Thread(){            public void run(){                while(true){                    try {                        //将此处的睡眠时间分别改为100和1000，观察运行结果                        Thread.sleep(1000);                        System.out.println(Thread.currentThread().getName() + &quot;准备取数据!&quot;);                        //取数据                        queue.take();                        System.out.println(Thread.currentThread().getName() + &quot;已经取走数据，&quot; +                                                           &quot;队列目前有&quot; + queue.size() + &quot;个数据&quot;);                                        } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        }.start();              }}</code></pre><h3 id="阻塞队列的通信"><a href="#阻塞队列的通信" class="headerlink" title="阻塞队列的通信"></a><strong>阻塞队列的通信</strong></h3><pre><code>import java.util.Collections;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;import java.util.concurrent.atomic.AtomicInteger;public class BlockingQueueCommunication {    public static void main(String[] args) {        final Business business = new Business();        new Thread(                new Runnable() {                                    @Override                    public void run() {                                         for(int i=1;i&lt;=5;i++){                            business.sub(i);                        }                                           }                }        ).start();        for(int i=1;i&lt;=5;i++){            business.main(i);        }           }     static class Business {                           BlockingQueue&lt;Integer&gt; queue1 = new ArrayBlockingQueue&lt;Integer&gt;(1);          BlockingQueue&lt;Integer&gt; queue2 = new ArrayBlockingQueue&lt;Integer&gt;(1);          //匿名构造方法 不能用静态代码块 因为queue1 queue2要在类加载时才初始化          {            //  Collections.synchronizedMap(null);              try {                  System.out.println(&quot;xxxxxdfsd把vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvsafdsa&quot;);                queue2.put(1);            } catch (InterruptedException e) {                e.printStackTrace();            }          }          public   void sub(int i){                try {                    queue1.put(1);                } catch (InterruptedException e) {                    e.printStackTrace();                }                for(int j=1;j&lt;=10;j++){                    System.out.println(&quot;sub：&quot;+i+&quot;[&quot;+1+&quot;]&quot;);                }                try {                    //因为queue2里没有数据，所以需要在初始化的时候先把数据放入queue2 才能把数据取出来                     queue2.take();                } catch (InterruptedException e) {                    e.printStackTrace();                }          }          public   void main(int i){                try {                    queue2.put(1);                } catch (InterruptedException e1) {                    e1.printStackTrace();                }                for(int j=1;j&lt;=100;j++){                    System.out.println(&quot;main：&quot;+ i+&quot;[&quot;+1+&quot;]&quot;);                }                try {                    queue1.take();                } catch (InterruptedException e) {                    e.printStackTrace();                }          }      }}</code></pre><h3 id="使用CopyOnWriteArrayList可以在迭代时移除数据"><a href="#使用CopyOnWriteArrayList可以在迭代时移除数据" class="headerlink" title="使用CopyOnWriteArrayList可以在迭代时移除数据"></a><strong>使用CopyOnWriteArrayList可以在迭代时移除数据</strong></h3><pre><code>如果使用ArrayList 则不能在迭代输出的时候 删除元素 否则 可能会造成死循环1.如果在移除第一个之后 版本记录号+1 期望版本记录号不变 进入下一次while时，next() 去判断 当前版本号和except版本号不同 throws Exception2.如果在移除第二个之后 size-1变为2 ,当进入下一次循环 cursor 加1 此时cursor等于2 hasnext 去判断cursor与 size 若相等则 while循环退出 不再读取下一个 （cursor=0指向第一个 =1指向第二个...）3.如果移除最后一个size由3变为2 再一次进入while hasnext cursor加1变为 3 ，不等于size 继续循环 curosr 继续加 size不变 curosr永远大于size while 永远循环综上 ArrayList 在迭代时不能移除数据应使用CopyOnWriteArrayListimport java.util.ArrayList;import java.util.Collection;import java.util.Iterator;import java.util.concurrent.CopyOnWriteArrayList;public class CollectionModifyExceptionTest {    public static void main(String[] args) {        Collection&lt;User&gt; users = new CopyOnWriteArrayList&lt;User&gt;();            //new ArrayList();        users.add(new User(&quot;张三&quot;,28));           users.add(new User(&quot;李四&quot;,25));                   users.add(new User(&quot;王五&quot;,31));           Iterator&lt;User&gt; itrUsers = users.iterator();        while(itrUsers.hasNext()){            System.out.println(&quot;aaaa&quot;);            User user = (User)itrUsers.next();            if(&quot;李四&quot;.equals(user.getName())){                users.remove(user);                //itrUsers.remove();            } else {                System.out.println(user);                           }        }    }}    </code></pre><h3 id="16条日志交由4个线程分别输出"><a href="#16条日志交由4个线程分别输出" class="headerlink" title="16条日志交由4个线程分别输出"></a><strong>16条日志交由4个线程分别输出</strong></h3><pre><code>import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;public class Test {    public static void main(String[] args){        final BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;String&gt;(1);                //创建四个线程 同时去queue里面获取一个日志 即1s获取并打印了4条日志        for(int i=0;i&lt;4;i++){            new Thread(new Runnable(){                @Override                public void run() {                    while(true){                        try {                            String log = queue.take();                            parseLog(log);                        } catch (InterruptedException e) {                            // TODO Auto-generated catch block                            e.printStackTrace();                        }                    }                }            }).start();        }        System.out.println(&quot;begin:&quot;+(System.currentTimeMillis()/1000));        /*模拟处理16行日志，下面的代码产生了16个日志对象，当前代码需要运行16秒才能打印完这些日志。        修改程序代码，开四个线程让这16个对象在4秒钟打完。        */        for(int i=0;i&lt;16;i++){  //这行代码不能改动            final String log = &quot;&quot;+(i+1);//这行代码不能改动            {                    try {                        queue.put(log);                    } catch (InterruptedException e) {                        // TODO Auto-generated catch block                        e.printStackTrace();                    }                    //Test.parseLog(log);            }        }    }    //parseLog方法内部的代码不能改动    public static void parseLog(String log){        System.out.println(log+&quot;:&quot;+(System.currentTimeMillis()/1000));        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        }           }}</code></pre><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><strong>Semaphore</strong></h3><pre><code>import java.util.concurrent.Semaphore;import java.util.concurrent.SynchronousQueue;public class Test {    public static void main(String[] args) {        final Semaphore semaphore = new Semaphore(1);        final SynchronousQueue&lt;String&gt; queue = new SynchronousQueue&lt;String&gt;();        for(int i=0;i&lt;10;i++){            new Thread(new Runnable(){                @Override                public void run() {                     try {                        semaphore.acquire();                        String input = queue.take();                        String output = TestDo.doSome(input);                        System.out.println(Thread.currentThread().getName()+ &quot;:&quot; + output);                        semaphore.release();                    } catch (InterruptedException e) {                        // TODO Auto-generated catch block                        e.printStackTrace();                    }                   }            }).start();        }        System.out.println(&quot;begin:&quot;+(System.currentTimeMillis()/1000));        for(int i=0;i&lt;10;i++){  //这行不能改动            String input = i+&quot;&quot;;  //这行不能改动            try {                queue.put(input);            } catch (InterruptedException e) {                // TODO Auto-generated catch block                e.printStackTrace();            }        }    }}//不能改动此TestDo类class TestDo {    public static String doSome(String input){        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        }        String output = input + &quot;:&quot;+ (System.currentTimeMillis() / 1000);        return output;    }}</code></pre><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><strong>CopyOnWriteArrayList</strong></h3><pre><code>package syn;import java.util.ArrayList;import java.util.Iterator;import java.util.concurrent.CopyOnWriteArrayList;//不能改动此Test类    public class Test extends Thread{    private TestDo testDo;    private String key;    private String value;    public Test(String key,String key2,String value){        this.testDo = TestDo.getInstance();        /*常量&quot;1&quot;和&quot;1&quot;是同一个对象，下面这行代码就是要用&quot;1&quot;+&quot;&quot;的方式产生新的对象，        以实现内容没有改变，仍然相等（都还为&quot;1&quot;），但对象却不再是同一个的效果*/        this.key = key+key2; /*      a = &quot;1&quot;+&quot;&quot;;        b = &quot;1&quot;+&quot;&quot;*/        this.value = value;    }    public static void main(String[] args) throws InterruptedException{        Test a = new Test(&quot;1&quot;,&quot;&quot;,&quot;1&quot;);        Test b = new Test(&quot;1&quot;,&quot;&quot;,&quot;2&quot;);        Test c = new Test(&quot;3&quot;,&quot;&quot;,&quot;3&quot;);        Test d = new Test(&quot;4&quot;,&quot;&quot;,&quot;4&quot;);        System.out.println(&quot;begin:&quot;+(System.currentTimeMillis()/1000));        a.start();        b.start();        c.start();        d.start();    }    public void run(){        testDo.doSome(key, value);    }}class TestDo {    private TestDo() {}    private static TestDo _instance = new TestDo();     public static TestDo getInstance() {        return _instance;    }    //一个线程在迭代时，另一个线程不能对集合进行操作 改用CopyOnWriteArrayList    //private ArrayList keys = new ArrayList();    private CopyOnWriteArrayList keys = new CopyOnWriteArrayList();    public void doSome(Object key, String value) {        Object o = key;        //判断集合是否有相同的key 没有则加入 有则将当前的o 改为集合里值和o相同的对象 因为只有对象相同的锁才能访问互斥        if(!keys.contains(o)){            keys.add(o);        }else{            for(Iterator iter=keys.iterator();iter.hasNext();){                try {                    Thread.sleep(20);                } catch (InterruptedException e) {                    // TODO Auto-generated catch block                    e.printStackTrace();                }                Object oo = iter.next();                if(oo.equals(o)){                    o = oo;                    break;                }            }        }        synchronized(o)        // 以大括号内的是需要局部同步的代码，不能改动!        {            try {                Thread.sleep(1000);                System.out.println(key+&quot;:&quot;+value + &quot;:&quot;                        + (System.currentTimeMillis() / 1000));            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}</code></pre><h3 id="使用volatile停止线程-而且volatile可以保证flag为系统内存的值而不是缓存里的值，避免了值不一致的情况"><a href="#使用volatile停止线程-而且volatile可以保证flag为系统内存的值而不是缓存里的值，避免了值不一致的情况" class="headerlink" title="使用volatile停止线程,而且volatile可以保证flag为系统内存的值而不是缓存里的值，避免了值不一致的情况"></a><strong>使用volatile停止线程,而且volatile可以保证flag为系统内存的值而不是缓存里的值，避免了值不一致的情况</strong></h3><pre><code>public class MyThread implements Runnable{    private volatile boolean flag;    public void stop() {        // TODO Auto-generated method stub        flag = false;    }    @Override    public void run() {        // TODO Auto-generated method stub        while(true)             System.out.println(&quot;a&quot;);    }}/*test*/public class Test_thread {    public static void main(String[] args) {        // TODO Auto-generated method stub        MyThread mt = new MyThread();        mt.run();        mt.stop();    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/2018/09/17/2018-9-17-%E9%9D%A2%E8%AF%95/"/>
      <url>/2018/09/17/2018-9-17-%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#什么是虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="什么是虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a><strong>什么是虚拟机？为什么Java被称作是“平台无关的编程语言”？</strong></h3><p>虚拟机可以将java字节码解析成机器可识别的0101二进制文件<br>java由编译器一次编译成clas文件能在各个装有虚拟机的平台运行  </p><h3 id="JDK-和-JRE-的区别是什么？"><a href="#JDK-和-JRE-的区别是什么？" class="headerlink" title="JDK 和 JRE 的区别是什么？"></a><strong>JDK 和 JRE 的区别是什么？</strong></h3><p>JRE是java运行环境，主要就是虚拟机<br>JDK包括JRE、编译器和其他工具  </p><h3 id="static关键字-Java中是否可以覆盖-override-一个private或者是static的方法？"><a href="#static关键字-Java中是否可以覆盖-override-一个private或者是static的方法？" class="headerlink" title="static关键字,Java中是否可以覆盖(override)一个private或者是static的方法？"></a><strong><code>static</code>关键字,Java中是否可以覆盖(override)一个private或者是static的方法？</strong></h3><p>static 和private编译时绑定成静态绑定：<br>就是在编译期间就已经加载到了内存，包括private、static、final修饰的变量和方法，还有构造函数，都是静态绑定<br>而覆盖是在运行时动态绑定的  </p><h3 id="是否可以在static环境中访问非static变量？"><a href="#是否可以在static环境中访问非static变量？" class="headerlink" title="是否可以在static环境中访问非static变量？"></a><strong>是否可以在static环境中访问非static变量？</strong></h3><p>不可以 因为static在类加载时就初始化了，而此时非static的还没加载，会报错  </p><h3 id="什么是自动拆装箱？"><a href="#什么是自动拆装箱？" class="headerlink" title="什么是自动拆装箱？"></a><strong>什么是自动拆装箱？</strong></h3><p>自动装箱和拆箱就是基本类型和引用类型之间的转换，至于为什么要转换，因为基本类型转换为引用类型后，就可以new对象，从而调用包装类中封装好的方法进行基本类型之间的转换或者toString（当然用类名直接调用也可以，便于一眼看出该方法是静态的），还有就是如果集合中想存放基本类型，泛型的限定类型只能是对应的包装类型。</p><h3 id="Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？"><a href="#Java中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？" class="headerlink" title="Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？"></a><strong>Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</strong></h3><p>Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。  </p><h3 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a><strong>接口和抽象类的区别是什么？</strong></h3><p>三个方面 关键字 方法  成员变量 其他  </p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a><strong>关键字</strong></h3><p>接口是对某一功能的抽象  关键字interface  无方法体（java9之后才有）implements后所有的方法必须实现   接口是最顶级的抽象 其变量只能是static final 即常量<br>抽象类是对某一事物的抽象  关键字abstract  有方法体 有抽象和非抽象方法 extends后不一定要实现所有方法  抽象类可以是任意类型的变量<br>类单继承 接口多实现    </p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a><strong>双亲委派模型</strong></h3><p>当类加载器需要加载class文件时会一层往一层去询问父类加载器能不能加载这个class文件，只有询问到最顶层父类后，才开始从父类往下找有能力加载该文件的加载器 </p><h3 id="在JDK1-4中引入了一个NIO的类库，使得Java涉及IO的操作拥有阻塞式和非阻塞式两种，问一下阻塞IO与非阻塞IO有什么区别？有什么优缺点？"><a href="#在JDK1-4中引入了一个NIO的类库，使得Java涉及IO的操作拥有阻塞式和非阻塞式两种，问一下阻塞IO与非阻塞IO有什么区别？有什么优缺点？" class="headerlink" title="在JDK1.4中引入了一个NIO的类库，使得Java涉及IO的操作拥有阻塞式和非阻塞式两种，问一下阻塞IO与非阻塞IO有什么区别？有什么优缺点？"></a><strong>在JDK1.4中引入了一个NIO的类库，使得Java涉及IO的操作拥有阻塞式和非阻塞式两种，问一下阻塞IO与非阻塞IO有什么区别？有什么优缺点？</strong></h3><p>// 答案如下：<br>// 1. 在阻塞模式下，若从网络中读取不到指定大小的数据量，阻塞IO就在那里阻塞着。比如，后面已经有10个字节的数据发过来，但是假如现在只收到8个字节，那么当前线程就在那傻傻地等待下一个字节的到来，直到把这10个字节读取完，这才将阻塞放开通行。<br>// 2. 在非阻塞模式下，若从网络流中读取不到指定大小的数据量，非阻塞IO就立即通行。比如，后面已经有10个字节的数据发过来，但是我现在只收到8个字节，那么当前线程就读取这8个字节的数据，读完后就立即返回，等另外两个字节来的时候再去读取。<br>// 3. 从上面可以看出，阻塞IO在性能方面是很低下的，如果要使用阻塞IO完成一个Web服务器的话，那么对于每一个请求都必须启用一个线程进行处理。而使用非阻塞IO的话，一到两个线程基本上就够了，因为线程不会产生阻塞，好比一下接收A请求的数据，另一下接收B请求的数据，等等，就是不停的东奔西跑，直接到把数据接收完了。<br>// 4. 虽然说，非阻塞IO比阻塞IO有更高的性能，但是对于开发来说，难度就成数倍递增了。由于是有多少数据就读取多少数据，这样在读取完整之前需要将已经读取到的数据保存起来，而且需要与其他地方来的数据隔离开来不能混在一起，否则就不知道这数据是谁的了。  </p><h2 id="————————————-试题————————————————"><a href="#————————————-试题————————————————" class="headerlink" title="————————————-试题————————————————"></a><strong>————————————-试题————————————————</strong></h2><p>下面都是我自己的答案非官方，仅供参考，如果有疑问或错误请一定要提出来，大家一起进步啦~~~<br><strong>下面哪些是Thread类的方法（）</strong><br>A start()       B run()       C exit()       D getPriority()<br>答案：ABD<br>解析：看Java API docs吧：<a href="http://docs.oracle.com/javase/7/docs/api/，exit()是System类的方法，如System.exit(0)。" target="_blank" rel="noopener">http://docs.oracle.com/javase/7/docs/api/，exit()是System类的方法，如System.exit(0)。</a><br><strong>下面关于java.lang.Exception类的说法正确的是（）</strong><br>A 继承自Throwable      B Serialable      CD 不记得，反正不正确<br>答案：A<br>解析：Java异常的基类为java.lang.Throwable，java.lang.Error和java.lang.Exception继承 Throwable，RuntimeException和其它的Exception等继承Exception，具体的RuntimeException继承RuntimeException。<br>扩展：错误和异常的区别(Error vs Exception)<br>java.lang.Error: Throwable的子类，用于标记严重错误。合理的应用程序不应该去try/catch这种错误。绝大多数的错误都是非正常的，就根本不该出现的。<br>java.lang.Exception: Throwable的子类，用于指示一种合理的程序想去catch的条件。即它仅仅是一种程序运行条件，而非严重错误，并且鼓励用户程序去catch它。<br>Error和RuntimeException 及其子类都是未检查的异常（unchecked exceptions），而所有其他的Exception类都是检查了的异常（checked exceptions）.<br>checked exceptions: 通常是从一个可以恢复的程序中抛出来的，并且最好能够从这种异常中使用程序恢复。比如FileNotFoundException,    ParseException等。检查了的异常发生在编译阶段，必须要使用try…catch（或者throws）否则编译不通过。<br>unchecked exceptions: 通常是如果一切正常的话本不该发生的异常，但是的确发生了。发生在运行期，具有不确定性，主要是由于程序的逻辑问题所引起的。比如ArrayIndexOutOfBoundException, ClassCastException等。从语言本身的角度讲，程序不该去catch这类异常，虽然能够从诸如RuntimeException这样的异常中catch并恢复，但是并不鼓励终端程序员这么做，因为完全没要必要。因为这类错误本身就是bug，应该被修复，出现此类错误时程序就应该立即停止执行。 因此，面对Errors和unchecked exceptions应该让程序自动终止执行，程序员不该做诸如try/catch这样的事情，而是应该查明原因，修改代码逻辑。<br>RuntimeException：RuntimeException体系包括错误的类型转换、数组越界访问和试图访问空指针等等。<br>处理RuntimeException的原则是：如果出现 RuntimeException，那么一定是程序员的错误。例如，可以通过检查数组下标和数组边界来避免数组越界访问异常。其他（IOException等等）checked异常一般是外部错误，例如试图从文件尾后读取数据等，这并不是程序本身的错误，而是在应用环境中出现的外部错误。<br><strong>下面程序的运行结果是（）</strong><br>String str1 = “hello”;<br>String str2 = “he” + new String(“llo”);<br>System.err.println(str1 == str2);<br>答案：false<br>解析：因为str2中的llo是新申请的内存块，而==判断的是对象的地址而非值，所以不一样。如果是String str2 = str1，那么就是true了。<br><strong>下列说法正确的有（）</strong><br>A． class中的constructor不可省略<br>B． constructor必须与class同名，但方法不能与class同名<br>C． constructor在一个对象被new时执行<br>D．一个class只能定义一个constructor<br>答案：C<br>解析：这里可能会有误区，其实普通的类方法是可以和类名同名的，和构造方法唯一的区分就是，构造方法没有返回值。<br><strong>具体选项不记得，但用到的知识如下：</strong>       </p><pre class=" language-vbscript"><code class="language-vbscript">String []a = new String[10]; </code></pre><p>则：<code>a[0]~a[9] = null</code><br>a.length = 10<br>如果是<code>int []a = new int[10];</code><br>则：<code>a[0]~a[9] = 0</code><br>a.length = 10<br><strong>下面程序的运行结果：（）</strong>     </p><pre><code>public static void main(String args[]) {        Thread t = new Thread() {            public void run() {                pong();            }        };        t.run();        System.out.print(&quot;ping&quot;);    }    static void pong() {        System.out.print(&quot;pong&quot;);    }</code></pre><p>A pingpong        B pongping       C pingpong和pongping都有可能       D 都不输出<br>答案：B<br>解析：这里考的是Thread类中start()和run()方法的区别了。start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程，进而调用run()方法来执行任务，而单独的调用run()就跟调用普通方法是一样的，已经失去线程的特性了。因此在启动一个线程的时候一定要使用start()而不是run()。<br><strong>下列属于关系型数据库的是（）</strong><br>A. Oracle    B MySql    C IMS     D MongoDB<br>答案：AB<br>解答：IMS（Information Management System ）数据库是IBM公司开发的两种数据库类型之一;<br>一种是关系数据库，典型代表产品：DB2；<br>另一种则是层次数据库，代表产品：IMS层次数据库。<br>非关系型数据库有MongoDB、memcachedb、Redis等。<br><strong>GC线程是否为守护线程？（）</strong><br>答案：是<br>解析：线程分为守护线程和非守护线程（即用户线程）。<br>只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。<br>守护线程最典型的应用就是 GC (垃圾回收器)<br><strong>volatile关键字是否能保证线程安全？（）</strong><br>答案：不能<br>解析：volatile关键字用在多线程同步中，可保证读取的可见性，JVM只是保证从主内存加载到线程工作内存的值是最新的读取值，而非cache中。但多个线程对<br>volatile的写操作，无法保证线程安全。例如假如线程1，线程2 在进行read,load 操作中，发现主内存中count的值都是5，那么都会加载这个最新的值，在线程1堆count进行修改之后，会write到主内存中，主内存中的count变量就会变为6；线程2由于已经进行read,load操作，在进行运算之后，也会更新主内存count的变量值为6；导致两个线程及时用volatile关键字修改之后，还是会存在并发的情况。<br><strong>下列说法正确的是（）</strong><br>A LinkedList继承自List<br>B AbstractSet继承自Set<br>C HashSet继承自AbstractSet<br>D WeakMap继承自HashMap<br>答案：AC<br>解析：下面是一张下载的Java中的集合类型的继承关系图，一目了然。<br><strong>存在使i + 1 &lt; i的数吗（）</strong>    </p><p>答案：存在<br>解析：如果i为int型，那么当i为int能表示的最大整数时，i+1就溢出变成负数了，此时不就&lt;i了吗。<br>扩展：存在使i &gt; j || i &lt;= j不成立的数吗（）<br>答案：存在<br>解析：比如Double.NaN或Float.NaN，感谢@BuilderQiu网友指出。<br><strong>0.6332的数据类型是（）</strong><br>A float     B double     C Float      D Double<br>答案：B<br>解析：默认为double型，如果为float型需要加上f显示说明，即0.6332f<br><strong>下面哪个流类属于面向字符的输入流(  )</strong><br>A  BufferedWriter           B  FileInputStream          C  ObjectInputStream          D  InputStreamReader<br> 答案：D<br> 解析：Java的IO操作中有面向字节(Byte)和面向字符(Character)两种方式。<br> 面向字节的操作为以8位为单位对二进制的数据进行操作，对数据不进行转换，这些类都是InputStream和OutputStream的子类。<br> 面向字符的操作为以字符为单位对数据进行操作，在读的时候将二进制数据转为字符，在写的时候将字符转为二进制数据，这些类都是Reader和Writer的子类。<br>总结：以InputStream（输入）/OutputStream（输出）为后缀的是字节流；<br>          以Reader（输入）/Writer（输出）为后缀的是字符流。<br>扩展：Java流类图结构，一目了然，解决大部分选择题：<br><strong>Java接口的修饰符可以为（）</strong><br>A private     B protected     C final       D abstract<br>答案：CD<br>解析：接口很重要，为了说明情况，这里稍微啰嗦点：<br>（1）接口用于描述系统对外提供的所有服务,因此接口中的成员常量和方法都必须是公开(public)类型的,确保外部使用者能访问它们；<br>（2）接口仅仅描述系统能做什么,但不指明如何去做,所以接口中的方法都是抽象(abstract)方法；<br>（3）接口不涉及和任何具体实例相关的细节,因此接口没有构造方法,不能被实例化,没有实例变量，只有静态（static）变量；<br>（4）接口的中的变量是所有实现类共有的，既然共有，肯定是不变的东西，因为变化的东西也不能够算共有。所以变量是不可变(final)类型，也就是常量了。<br>（5） 接口中不可以定义变量？如果接口可以定义变量，但是接口中的方法又都是抽象的，在接口中无法通过行为来修改属性。有的人会说了，没有关系，可以通过 实现接口的对象的行为来修改接口中的属性。这当然没有问题，但是考虑这样的情况。如果接口 A 中有一个public 访问权限的静态变量 a。按照 Java 的语义，我们可以不通过实现接口的对象来访问变量 a，通过 A.a = xxx; 就可以改变接口中的变量 a 的值了。正如抽象类中是可以这样做的，那么实现接口 A 的所有对象也都会自动拥有这一改变后的 a 的值了，也就是说一个地方改变了 a，所有这些对象中 a 的值也都跟着变了。这和抽象类有什么区别呢，怎么体现接口更高的抽象级别呢，怎么体现接口提供的统一的协议呢，那还要接口这种抽象来做什么呢？所以接口中 不能出现变量，如果有变量，就和接口提供的统一的抽象这种思想是抵触的。所以接口中的属性必然是常量，只能读不能改，这样才能为实现接口的对象提供一个统 一的属性。<br>通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现 implements）开放，接口是对开闭原则的一种体现。<br>所以：<br>接口的方法默认是public abstract；<br>接口中不可以定义变量即只能定义常量(加上final修饰就会变成常量)。所以接口的属性默认是public static final 常量，且必须赋初值。<br>注意：final和abstract不能同时出现。<br><strong>不通过构造函数也能创建对象吗（）</strong><br>A 是     B 否<br>答案：A<br>解析：Java创建对象的几种方式（重要）：<br>(1) 用new语句创建对象，这是最常见的创建对象的方法。<br>(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。<br>(3) 调用对象的clone()方法。<br>(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。<br>(1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用构造函数。<br><strong>ArrayList list = new ArrayList(20);中的list扩充几次（）</strong><br>A 0     B 1     C 2      D 3<br>答案：A<br>解析：这里有点迷惑人，大家都知道默认ArrayList的长度是10个，所以如果你要往list里添加20个元素肯定要扩充一次（扩充为原来的1.5倍），但是这里显示指明了需要多少空间，所以就一次性为你分配这么多空间，也就是不需要扩充了。<br><strong>下面哪些是对称加密算法（）</strong><br>A DES   B AES   C DSA   D RSA<br>答案：AB<br>解析：常用的对称加密算法有：DES、3DES、RC2、RC4、AES<br>常用的非对称加密算法有：RSA、DSA、ECC<br>使用单向散列函数的加密算法：MD5、SHA<br>18.新建一个流对象，下面哪个选项的代码是错误的？（）<br>A）new BufferedWriter(new FileWriter(“a.txt”));<br>B）new BufferedReader(new FileInputStream(“a.dat”));<br>C）new GZIPOutputStream(new FileOutputStream(“a.zip”));<br>D）new ObjectInputStream(new FileInputStream(“a.dat”));<br>答案：B<br>解析：请记得13题的那个图吗？Reader只能用FileReader进行实例化。<br><strong>下面程序能正常运行吗（）</strong>    </p><pre><code>public class NULL {    public static void haha(){        System.out.println(&quot;haha&quot;);    }    public static void main(String[] args) {        ((NULL)null).haha();    }}</code></pre><p>答案：能正常运行<br>解析：输出为haha，因为null值可以强制转换为任何java类类型,(String)null也是合法的。但null强制转换后是无效对象，其返回值还是为null，而static方法的调用是和类名绑定的，不借助对象进行访问所以能正确输出。反过来，没有static修饰就只能用对象进行访问，使用null调用对象肯定会报空指针错了。这里和C++很类似。这里感谢@Florian网友解答。<br><strong>下面程序的运行结果是什么（）</strong>   </p><pre><code>class HelloA {    public HelloA() {        System.out.println(&quot;HelloA&quot;);    }    { System.out.println(&quot;I&#39;m A class&quot;); }    static { System.out.println(&quot;static A&quot;); }}public class HelloB extends HelloA {    public HelloB() {        System.out.println(&quot;HelloB&quot;);    }        { System.out.println(&quot;I&#39;m B class&quot;); }        static { System.out.println(&quot;static B&quot;); }        public static void main(String[] args) { 　　　　 new HelloB(); 　　 }}</code></pre><p>答案：<br>static A<br>static B<br>I’m A class<br>HelloA<br>I’m B class<br>HelloB<br>解析：说实话我觉得这题很好，考查静态语句块、构造语句块（就是只有大括号的那块）以及构造函数的执行顺序。<br>对象的初始化顺序：（1）类加载之后，按从上到下（从父类到子类）执行被static修饰的语句；（2）当static语句执行完之后,再执行main方法；（3）如果有语句new了自身的对象，将从上到下执行构造代码块、构造器（两者可以说绑定在一起）。<br>下面稍微修改下上面的代码，以便更清晰的说明情况：<br>View Code<br>此时输出结果为：   </p><pre><code>static Astatic B-------main start-------I&#39;m A classHelloAI&#39;m B classHelloBI&#39;m A classHelloAI&#39;m B classHelloB-------main end-------</code></pre><p><strong>getCustomerInfo()方法如下，try中可以捕获三种类型的异常，如果在该方法运行中产生了一个IOException，将会输出什么结果（）</strong>    </p><pre><code>    public void getCustomerInfo() {        try {            // do something that may cause an Exception        } catch (java.io.FileNotFoundException ex) {            System.out.print(&quot;FileNotFoundException!&quot;);        } catch (java.io.IOException ex) {            System.out.print(&quot;IOException!&quot;);        } catch (java.lang.Exception ex) {            System.out.print(&quot;Exception!&quot;);        }    }</code></pre><p>A IOException!<br>BIOException!Exception!<br>CFileNotFoundException!IOException!<br>DFileNotFoundException!IOException!Exception!<br>答案：A<br>解析：考察多个catch语句块的执行顺序。当用多个catch语句时，catch语句块在次序上有先后之分。从最前面的catch语句块依次先后进行异常类型匹配，这样如果父异常在子异常类之前，那么首先匹配的将是父异常类，子异常类将不会获得匹配的机会，也即子异常类型所在的catch语句块将是不可到达的语句。所以，一般将父类异常类即Exception老大放在catch语句块的最后一个。<br><strong>下面代码的运行结果为：（）</strong>   </p><pre><code>import java.io.*;import java.util.*;public class foo{    public static void main (String[] args){        String s;        System.out.println(&quot;s=&quot; + s);    }}</code></pre><p>A 代码得到编译，并输出“s=”<br>B 代码得到编译，并输出“s=null”<br>C 由于String s没有初始化，代码不能编译通过<br>D 代码得到编译，但捕获到 NullPointException异常<br>答案：C<br>解析：开始以为会输出null什么的，运行后才发现Java中所有定义的基本类型或对象都必须初始化才能输出值。<br>  <strong>System.out.println(“5” + 2);的输出结果应该是（）。</strong><br>A 52                   B7                     C2                     D5<br>答案：A<br>解析：没啥好说的，Java会自动将2转换为字符串。<br> <strong>指出下列程序运行的结果 （）</strong>  </p><pre><code>public class Example {    String str = new String(&quot;good&quot;);    char[] ch = { &#39;a&#39;, &#39;b&#39;, &#39;c&#39; };    public static void main(String args[]) {        Example ex = new Example();        ex.change(ex.str, ex.ch);        System.out.print(ex.str + &quot; and &quot;);        System.out.print(ex.ch);    }    public void change(String str, char ch[]) {        str = &quot;test ok&quot;;        ch[0] = &#39;g&#39;;    }}</code></pre><p>A、 good and abc<br>B、 good and gbc<br>C、 test ok and abc<br>D、 test ok and gbc<br>答案：B<br>解析：大家可能以为Java中String和数组都是对象所以肯定是对象引用，然后就会选D，其实这是个很大的误区：因为在java里没有引用传递，只有值传递<br>这个值指的是实参的地址的拷贝，得到这个拷贝地址后，你可以通过它修改这个地址的内容（引用不变），因为此时这个内容的地址和原地址是同一地址，<br>但是你不能改变这个地址本身使其重新引用其它的对象，也就是值传递，可能说的不是很清楚，下面给出一个完整的能说明情况的例子吧：<br>程序有些啰嗦，但能反映问题，该程序运行结果为：  </p><pre><code>对象交换前：p1 = Alexia female对象交换前：p2 = Edward male对象交换后：p1 = Alexia female对象交换后：p2 = Edward male对象数组交换前：arraya[0] = Alexia female, arraya[1] = Edward male对象数组交换前：arrayb[0] = jmwang female, arrayb[1] = hwu male对象数组交换后：arraya[0] = Alexia female, arraya[1] = Edward male对象数组交换后：arrayb[0] = jmwang female, arrayb[1] = hwu male基本类型数组交换前：a[0] = 0, a[1] = 1基本类型数组交换前：b[0] = 1, b[1] = 2基本类型数组交换后：a[0] = 0, a[1] = 1基本类型数组交换后：b[0] = 1, b[1] = 2对象数组内容交换并改变后：arraya[1] = wjl male对象数组内容交换并改变后：arrayb[1] = Edward male基本类型数组内容交换并改变后：a[1] = 5基本类型数组内容交换并改变后：b[1] = 1</code></pre><p>说明：不管是对象、基本类型还是对象数组、基本类型数组，在函数中都不能改变其实际地址但能改变其中的内容。<br><strong>要从文件”file.dat”中读出第10个字节到变量c中,下列哪个方法适合? （）</strong><br>A FileInputStream in=new FileInputStream(“file.dat”); in.skip(9); int c=in.read();<br>B FileInputStream in=new FileInputStream(“file.dat”); in.skip(10); int c=in.read();<br>C FileInputStream in=new FileInputStream(“file.dat”); int c=in.read();<br>D RandomAccessFile in=new RandomAccessFile(“file.dat”); in.skip(9); int c=in.readByte();<br>答案：A?D?<br>解析：long skip(long n)作用是跳过n个字节不读，主要用在包装流中的，因为一般流（如FileInputStream）只能顺序一个一个的读不能跳跃读，但是包装流可以用skip方法跳跃读取。那么什么是包装流呢？各种字节节点流类，它们都只具有读写字节内容的方法，以FileInputStream与FileOutputStream为例，它们只能在文件中读取或者向文件中写入字节，在实际应用中我们往往需要在文件中读取或者写入各种类型的数据，就必须先将其他类型的数据转换成字节数组后写入文件，或者从文件中读取到的字节数组转换成其他数据类型，想想都很麻烦！！因此想通过FileOutputStream将一个浮点小数写入到文件中或将一个整数写入到文件时是非常困难的。这时就需要包装类DataInputStream/DataOutputStream，它提供了往各种输入输出流对象中读入或写入各种类型的数据的方法。<br>DataInputStream/DataOutputStream并没有对应到任何具体的流设备，一定要给它传递一个对应具体流设备的输入或输出流对象，完成类似 DataInputStream/DataOutputStream功能的类就是一个包装类，也叫过滤流类或处理流类。它对InputOutStream/OutputStream流类进行了包装，使编程人员使用起来更方便。其中DataInputStream包装类的构造函数语法：public DataInputStream(InputStream in)。包装类也可以包装另外一个包装类。<br>首先BC肯定 是错的，那A正确吗？按上面的解析应该也不对，但我试了下，发现A也是正确的，与网上解析的资料有些出入，下面是我的code：<br>那么D呢，RandomAccessFile是IO包的类，但是其自成一派，从Object直接继承而来。可以对文件进行读取和写入。支持文件的随机访问，即可以随机读取文件中的某个位置内容，这么说RandomAccessFile肯定可以达到题目的要求，但是选项有些错误，比如RandomAccessFile的初始化是两个参数而非一个参数，采用的跳跃读取方法是skipBytes()而非skip()，即正确的写法是：<br>RandomAccessFile in = new RandomAccessFile(“file.dat”, “r”);<br>in.skipBytes(9);<br>int c = in.readByte();<br>这样也能读到第十个字节，也就是A和D都能读到第十个字节，那么到底该选哪个呢？A和D有啥不同吗？求大神解答~~~<br><strong>下列哪种异常是检查型异常，需要在编写程序时声明 （）</strong><br>ANullPointerException        BClassCastException      CFileNotFoundException       D IndexOutOfBoundsException<br>答案：C<br>解析：看第2题的解析。<br><strong>下面的方法，当输入为2的时候返回值是多少?（）</strong>    </p><pre><code>    public static int getValue(int i) {        int result = 0;        switch (i) {        case 1:            result = result + i;        case 2:            result = result + i * 2;        case 3:            result = result + i * 3;        }        return result;    }</code></pre><p>A0                    B2                    C4                     D10<br>答案：D<br>解析：注意这里case后面没有加break，所以从case 2开始一直往下运行。<br><strong>选项中哪一行代码可以替换题目中//add code here而不产生编译错误？（）</strong>   </p><pre><code>public abstract class MyClass {     public int constInt = 5;     //add code here     public void method() {     }}</code></pre><p>Apublic abstract void method(int a);<br>B constInt = constInt + 5;<br>C public int method();<br>D public abstract void anotherMethod() {}<br>答案：A<br>解析：考察抽象类的使用。<br>抽象类遵循的原则：<br>（1）abstract关键字只能修饰类和方法，不能修饰字段。<br>（2）抽象类不能被实例化（无法使用new关键字创建对象实例），只能被继承。<br>（3）抽象类可以包含属性，方法，构造方法，初始化块，内部类，枚举类，和普通类一样，普通方法一定要实现，变量可以初始化或不初始化但不能初始化后在抽象类中重新赋值或操作该变量（只能在子类中改变该变量）。<br>（4）抽象类中的抽象方法（加了abstract关键字的方法）不能实现。<br>（5）含有抽象方法的类必须定义成抽象类。<br>扩展：抽象类和接口的区别，做个总结吧：<br>（1）接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的。   </p><p>（2）abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface，实现多重继承。接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。   </p><p>（3）在abstract class 中可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface中，只能够有静态的不能被修改的数据成员（也就是必须是 static final的，不过在 interface中一般不定义数据成员），所有的成员方法默认都是 public abstract 类型的。  </p><p>（4）abstract class和interface所反映出的设计理念不同。其实abstract class表示的是”is-a”关系，interface表示的是”has-a”关系。   </p><p>（5）实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。抽象类中可以有非抽象方法。接口中则不能有实现方法。   </p><p>（6）接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以在子类中重新赋值。<br><strong>阅读Shape和Circle两个类的定义。在序列化一个Circle的对象circle到文件时，下面哪个字段会被保存到文件中？ (  )</strong>    </p><pre><code>class Shape {       public String name;}class Circle extends Shape implements Serializable{       private float radius;       transient int color;       public static String type = &quot;Circle&quot;;}</code></pre><p>Aname<br>B radius<br>C color<br>D type<br>答案：B<br>解析：这里有详细的解释：<a href="http://www.cnblogs.com/lanxuezaipiao/p/3369962.html" target="_blank" rel="noopener">http://www.cnblogs.com/lanxuezaipiao/p/3369962.html</a><br><strong>下面是People和Child类的定义和构造方法，每个构造方法都输出编号。在执行new Child(“mike”)的时候都有哪些构造方法被顺序调用？请选择输出结果 ( )</strong>       </p><pre><code>class People {    String name;    public People() {        System.out.print(1);    }    public People(String name) {        System.out.print(2);        this.name = name;    }}class Child extends People {    People father;    public Child(String name) {        System.out.print(3);        this.name = name;        father = new People(name + &quot;:F&quot;);    }    public Child() {        System.out.print(4);    }}</code></pre><p>A312              B 32               C 432              D 132<br>答案：D<br>解析：考察的又是父类与子类的构造函数调用次序。在Java中，子类的构造过程中必须调用其父类的构造函数，是因为有继承关系存在时，子类要把父类的内容继承下来。但如果父类有多个构造函数时，该如何选择调用呢？<br>第一个规则：子类的构造过程中，必须调用其父类的构造方法。一个类，如果我们不写构造方法，那么编译器会帮我们加上一个默认的构造方法（就是没有参数的构造方法），但是如果你自己写了构造方法，那么编译器就不会给你添加了，所以有时候当你new一个子类对象的时候，肯定调用了子类的构造方法，但是如果在子类构造方法中我们并没有显示的调用基类的构造方法，如：super();  这样就会调用父类没有参数的构造方法。<br>第二个规则：如果子类的构造方法中既没有显示的调用基类构造方法，而基类中又没有无参的构造方法，则编译出错，所以，通常我们需要显示的：super(参数列表)，来调用父类有参数的构造函数，此时无参的构造函数就不会被调用。<br>总之，一句话：子类没有显示调用父类构造函数，不管子类构造函数是否带参数都默认调用父类无参的构造函数，若父类没有则编译出错。<br>最后，给大家出个思考题：下面程序的运行结果是什么？    </p><pre><code>public class Dervied extends Base {    private String name = &quot;dervied&quot;;    public Dervied() {        tellName();        printName();    }    public void tellName() {        System.out.println(&quot;Dervied tell name: &quot; + name);    }        public void printName() {        System.out.println(&quot;Dervied print name: &quot; + name);    }    public static void main(String[] args){        new Dervied();        }}class Base {        private String name = &quot;base&quot;;    public Base() {        tellName();        printName();    }       public void tellName() {        System.out.println(&quot;Base tell name: &quot; + name);    }        public void printName() {        System.out.println(&quot;Base print name: &quot; + name);    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神秘博文——总有一招操作适合你</title>
      <link href="/2018/09/17/2018-9-17-%E7%A5%9E%E7%A7%98%E5%8D%9A%E6%96%87%E2%80%94%E2%80%94%E6%80%BB%E6%9C%89%E4%B8%80%E6%8B%9B%E6%93%8D%E4%BD%9C%E9%80%82%E5%90%88%E4%BD%A0/"/>
      <url>/2018/09/17/2018-9-17-%E7%A5%9E%E7%A7%98%E5%8D%9A%E6%96%87%E2%80%94%E2%80%94%E6%80%BB%E6%9C%89%E4%B8%80%E6%8B%9B%E6%93%8D%E4%BD%9C%E9%80%82%E5%90%88%E4%BD%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a><strong>优化</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-17/优化1.png" alt="duotai"><br><img src="https://viabcde.github.io/images/2018-09-17/显示myeclipse占用的内存.png" alt="duotai">     </p><h3 id="查看网页源代码"><a href="#查看网页源代码" class="headerlink" title="查看网页源代码"></a><strong>查看网页源代码</strong></h3><p>Ctrl+U</p><h3 id="测试浏览器是否支持html5访问"><a href="#测试浏览器是否支持html5访问" class="headerlink" title="测试浏览器是否支持html5访问"></a><strong>测试浏览器是否支持html5访问</strong></h3><p><a href="http://html5test.com" target="_blank" rel="noopener">http://html5test.com</a></p><h3 id="word封面加下划线"><a href="#word封面加下划线" class="headerlink" title="word封面加下划线"></a><strong>word封面加下划线</strong></h3><p> 打好字 ctrl+U 在字后面打空格自动生成下划线<br>在字前面打空格 选中所有空格 ctrl+U  </p><h3 id="邮件服务器的搭建和客户端的安装"><a href="#邮件服务器的搭建和客户端的安装" class="headerlink" title="邮件服务器的搭建和客户端的安装"></a><strong>邮件服务器的搭建和客户端的安装</strong></h3><p>1.安装易邮服务器<br>2.修改自己的域名<br>工具—服务器设置—-修改单域名为自己定义的域名 这里为 shop.com<br>此后注册的账号为<a href="mailto:*@shop.com" target="_blank" rel="noopener">*@shop.com</a><br><img src="https://viabcde.github.io/images/blog/20180928194.png" alt="enter descriptionhere"><br>3.安装foxmail<br>邮箱—-新建账户—- <a href="mailto:**@shop.com" target="_blank" rel="noopener">**@shop.com</a><br>接收邮件服务器设为 localhost<br>发送邮件服务器设为 loaclhost  </p><h3 id="制作自定义桌面图标教程"><a href="#制作自定义桌面图标教程" class="headerlink" title="制作自定义桌面图标教程"></a><strong>制作自定义桌面图标教程</strong></h3><p>首先 图标要求是256<em>256d的 可以使用PS修改 步骤如下：<br>1.将文件导入PS中<br>2.安装Alt 点击背景<br>3.图像-&gt; 画布大小<br>修改宽高一致<br>4.魔棒工具去除背景<br>5.图像-&gt;图像大小 改为256</em>256<br>6.存储为png<br>7.打开greenFish<br>8.导入该png图片 直接存储为iso即可  </p><h3 id="WIN10开机卡在了正在准备自动修复"><a href="#WIN10开机卡在了正在准备自动修复" class="headerlink" title="WIN10开机卡在了正在准备自动修复"></a><strong>WIN10开机卡在了正在准备自动修复</strong></h3><p>Win10系统启动到LOGO界面后，强制重启，反复3次左右，至到显示疑难解答，我们点击疑难解答进入；<br>选重置此点电脑。<br>接下来这里，我选择的删除所有内容。这里是准备要格式化系统分区C盘，如果想保留C盘内容建议选择另外一个选项，然后自己研究一下吧。之后出现的选项一定要选【仅限安装了windows驱动】 这个选项，另外一个貌似是整个硬盘格掉了。<br>最后选择初始化。就等着还原吧。对了。提前准备好网卡驱动！</p><h3 id="计算机寻址范围："><a href="#计算机寻址范围：" class="headerlink" title="计算机寻址范围："></a><strong>计算机寻址范围：</strong></h3><p>指的是32位  2的32次方<br>64为 2的64次方  </p><h3 id="关于磁盘"><a href="#关于磁盘" class="headerlink" title="关于磁盘"></a><strong>关于磁盘</strong></h3><p>磁盘中的凹槽每一个存放4kb的内存 当文件内存小与4kb 在磁盘依然是占用4kb的空间 如果文件超过了4kb 则占用8kb的空间 以此类推 每超过 即加4kb<br>存储数据不会每次读取到都存一次   而是先存到缓存中待存到足够大时再一次性存入磁盘<br>当对数据进行增加、删除、修改时 数据在磁盘上不连续 读取时通过指针串联读取<br>指针多次跳转会 毁磁盘  </p><h3 id="配置java环境的原因"><a href="#配置java环境的原因" class="headerlink" title="配置java环境的原因"></a><strong>配置java环境的原因</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-27/2018092705.png" alt="enter description here"></p><h3 id="整除"><a href="#整除" class="headerlink" title="整除"></a><strong>整除</strong></h3><p>如果整数a除以非零整数b，商为整数，余数为零<br>则a能被b整除    </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> 调试bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用类库</title>
      <link href="/2018/09/17/2018-9-17-%E7%B1%BB%E5%BA%93/"/>
      <url>/2018/09/17/2018-9-17-%E7%B1%BB%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p><div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"><br>                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-e2445db1a8.css"><br>                        <div class="htmledit_views"></div></div></p><p><strong style="font-size:18px;">Java类库概念：</strong><span style="font-size:18px;">Java的应用程序接口(API)以包的形式来组织，每个包提供了大量的相关类、接口和异常处理类，这些包的集合就是Java的类库</span></p><p><span style="font-size:18px;">包名以Java开始的包是Java<strong>核心包</strong>(Java Core Package)；</span></p><br><p><span style="font-size:18px;">包名以Javax开始的包是Java<strong>扩展包</strong>(Java Extension Package)，例如javax.swing包；</span></p><br><p><strong><span style="font-size:18px;">常用的Java核心包(Java Core Package)</span></strong></p><br><p><span style="font-size:18px;"><strong>1.java.lang</strong>Java编程语言的基本类库</span></p><br><p><span style="font-size:18px;">2.java.applet创建applet需要的所有类</span></p><br><p><span style="font-size:18px;">3.java.awt创建用户界面以及绘制和管理图形、图像的类</span></p><br><p><span style="font-size:18px;">4.java.io通过数据流、对象序列以及文件系统实现的系统输入、输出</span></p><br><p><span style="font-size:18px;">5.java.net用于实现网络通讯应用的所有类</span></p><br><p><span style="font-size:18px;"><strong>6.java.util</strong>集合类、时间处理模式、日期时间工具等各类常用工具包</span></p><br><p><span style="font-size:18px;">其它还有</span></p><br><p><span style="font-size:18px;">7.java.sql访问和处理来自于Java标准数据源数据的类</span></p><br><p><span style="font-size:18px;">8.java.test以一种独立于自然语言的方式处理文本、日期、数字和消息的类和接口</span></p><br><p><span style="font-size:18px;">9.java.security设计网络安全方案需要的一些类</span></p><br><p><span style="font-size:18px;">10.java.beans开发Java Beans需要的所有类</span></p><br><p><span style="font-size:18px;">11.java.math简明的整数算术以及十进制算术的基本函数</span></p><br><p><span style="font-size:18px;">12.java.rmi与远程方法调用相关的所有类</span></p><br><p><strong><span style="font-size:18px;">常用的Java扩展包(Java Extension Package)</span></strong></p><br><p><span style="font-size:18px;">1.javax.accessibility定义了用户界面组件之间相互访问的一种机制</span></p><br><p><span style="font-size:18px;">2. javax.naming.<em>为命名服务提供了一系列类和接口</em></span></p><br><p><span style="font-size:18px;">3.javax.swing.提供了一系列轻量级的用户界面组件，是目前Java用户界面常用的包</span></p><br><p><span style="font-size:18px;">注1：最重要且常用的是1和6，已用黑体标出的为，需重点掌握</span></p><br><p><span style="font-size:18px;">注2：在使用Java时，除了java.lang外，其他的包都需要import语句引入之后才能使用。</span></p><br><p><span style="font-size:18px;">重点讲解内容：java.lang和java.util。<br></span></p><br><p><span style="font-size:18px;"><strong>java.lang包</strong></span></p><br><p><span style="font-size:18px;">这个包称为java语言包，是由编译器自动引入的。程序中不必用import语句就可以使用。它所包含的类和接口对所有实际的Java程序都是必要的。</span></p><br><p><span style="font-size:18px;">1.object类</span></p><br><p><span style="font-size:18px;">2.数学类(Math)</span></p><br><p><span style="font-size:18px;">3.数据类型类</span></p><br><p><span style="font-size:18px;">4.线程类</span></p><br><p><span style="font-size:18px;">5.字符串类(String类和StringBuffer类)</span></p><br><p><span style="font-size:18px;">6.系统及运行类(System类和Runtime类)</span></p><br><p><span style="font-size:18px;">7.错误和异常处理类(Throwable、Exception、Error)</span></p><br><p><span style="font-size:18px;">8.过程类(process)</span></p><p><span style="font-size:18px;"><strong>java.util包</strong></span></p><br><p><span style="font-size:18px;">1. 日期类、日历类（Data、Calendar、GregorianCalendar）</span></p><br><p><span style="font-size:18px;">2. 随机数类（Random）</span></p><br><p><span style="font-size:18px;">3. 位运算类（BitSet）</span></p><br><p><span style="font-size:18px;">4. 矢量类（Vector）</span></p><br><p><span style="font-size:18px;">5. 数据结构类（Stack）</span></p><br><p><span style="font-size:18px;">6. 散列表类（Hashtable）</span></p><br><p><span style="font-size:18px;">7. StringTokenizer类<br></span></p><br><br><p><br><br></p><br><table cellspacing="0" cellpadding="0" border="1" style="color:rgb(0,0,0);"><tbody><tr><td><br><p><span style="font-size:18px;">包名</span></p><br></td><br><td><br><p><span style="font-size:18px;">主要功能</span></p><br></td><br></tr><tr><td><br><p><span style="font-size:18px;">java.applet</span></p><br></td><br><td><br><p><span style="font-size:18px;">提供了创建applet需要的所有类</span></p><br></td><br></tr><tr><td><br><p><span style="font-size:18px;">java.awt.<em></em></span></p><br></td><br><td><br><p><span style="font-size:18px;">提供了创建用户界面以及绘制和管理图形、图像的类</span></p><br></td><br></tr><tr><td><br><p><span style="font-size:18px;">java.beans.</span></p><br></td><br><td><br><p><span style="font-size:18px;">提供了开发Java Beans需要的所有类</span></p><br></td><br></tr><tr><td><br><p><span style="font-size:18px;">java.io</span></p><br></td><br><td><br><p><span style="font-size:18px;">提供了通过数据流、对象序列以及文件系统实现的系统输入、输出</span></p><br></td><br></tr><tr><td><br><p><span style="font-size:18px;">java.lang.<em></em></span></p><br></td><br><td><br><p><span style="font-size:18px;">Java编程语言的基本类库</span></p><br></td><br></tr><tr><td><br><p><span style="font-size:18px;">java.math.</span></p><br></td><br><td><br><p><span style="font-size:18px;">提供了简明的整数算术以及十进制算术的基本函数</span></p><br></td><br></tr><tr><td><br><p><span style="font-size:18px;">java.rmi</span></p><br></td><br><td><br><p><span style="font-size:18px;">提供了与远程方法调用相关的所有类</span></p><br></td><br></tr><tr><td><br><p><span style="font-size:18px;">java.net</span></p><br></td><br><td><br><p><span style="font-size:18px;">提供了用于实现网络通讯应用的所有类</span></p><br></td><br></tr><tr><td><br><p><span style="font-size:18px;">java.security.<em></em></span></p><br></td><br><td><br><p><span style="font-size:18px;">提供了设计网络安全方案需要的一些类</span></p><br></td><br></tr><tr><td><br><p><span style="font-size:18px;">java.sql</span></p><br></td><br><td><br><p><span style="font-size:18px;">提供了访问和处理来自于Java标准数据源数据的类</span></p><br></td><br></tr><tr><td><br><p><span style="font-size:18px;">java.test</span></p><br></td><br><td><br><p><span style="font-size:18px;">包括以一种独立于自然语言的方式处理文本、日期、数字和消息的类和接口</span></p><br></td><br></tr><tr><td><br><p><span style="font-size:18px;">java.util.</span></p><br></td><br><td><br><p><span style="font-size:18px;">包括集合类、时间处理模式、日期时间工具等各类常用工具包</span></p><br></td><br></tr><tr><td><br><p><span style="font-size:18px;">javax.accessibility</span></p><br></td><br><td><br><p><span style="font-size:18px;">定义了用户界面组件之间相互访问的一种机制</span></p><br></td><br></tr><tr><td><br><p><span style="font-size:18px;">javax.naming.<em></em></span></p><br></td><br><td><br><p><span style="font-size:18px;">为命名服务提供了一系列类和接口</span></p><br></td><br></tr><tr><td><br><p><span style="font-size:18px;">javax.swing.</span></p><br></td><br><td><br><p><span style="font-size:18px;">提供了一系列轻量级的用户界面组件，是目前Java用户界面常用的包</span></p><br></td><br></tr></tbody></table><br><p><strong><span style="font-size:18px;">常用的Java&gt;Java编程语言的基本类库</span></strong></p><br><p><span style="font-size:18px;">2.java.applet创建applet需要的所有类</span></p><br><p><span style="font-size:18px;">3.java.awt创建用户界面以及绘制和管理图形、图像的类</span></p><br><p><span style="font-size:18px;">4.java.io通过数据流、对象序列以及文件系统实现的系统输入、输出</span></p><br><p><span style="font-size:18px;">5.java.net用于实现网络通讯应用的所有类</span></p><br><p><span style="font-size:18px;"><strong>6.java.util</strong>集合类、时间处理模式、日期时间工具等各类常用工具包</span></p><br><p><br></p><br><p><span style="font-size:18px;">7.java.sql访问和处理来自于Java标准数据源数据的类</span></p><br><p><span style="font-size:18px;">8.java.test以一种独立于自然语言的方式处理文本、日期、数字和消息的类和接口</span></p><br><p><span style="font-size:18px;">9.java.security设计网络安全方案需要的一些类</span></p><br><p><span style="font-size:18px;">10.  java.beans开发Java Beans需要的所有类</span></p><br><p><span style="font-size:18px;">11. java.math简明的整数算术以及十进制算术的基本函数</span></p><br><p><span style="font-size:18px;">12. java.rmi与远程方法调用相关的所有类</span></p><br><p><strong><span style="font-size:18px;">常用的Java扩展包(Java Extension Package)</span></strong></p><br><p><span style="font-size:18px;">1.javax.accessibility定义了用户界面组件之间相互访问的一种机制</span></p><br><p><span style="font-size:18px;">2.javax.naming.<em>为命名服务提供了一系列类和接口</em></span></p><br><p><span style="font-size:18px;">3.javax.swing.提供了一系列轻量级的用户界面组件，是目前Java用户界面常用的包</span></p><br><p><span style="font-size:18px;">注1：最重要且常用的是1和6，已用黑体标出的为，需重点掌握</span></p><br><p><span style="font-size:18px;">注2：在使用Java时，<strong>除了java.lang外，其他的包都需要import语句</strong>引入之后才能使用。</span></p><br><p><span style="font-size:18px;">重点讲解内容：java.lang和java.util。<br></span></p><br><p><strong><span style="font-size:18px;">java.lang包</span></strong></p><br><p><span style="font-size:18px;">这个包称为java语言包，是由编译器自动引入的。程序中不必用import语句就可以使用。它所包含的类和接口对所有实际的Java程序都是必要的。</span></p><br><p><span style="font-size:18px;">1.object类</span></p><br><p><span style="font-size:18px;">2.数学类(Math)</span></p><br><p><span style="font-size:18px;">3.数据类型类</span></p><br><p><span style="font-size:18px;">4.线程类</span></p><br><p><span style="font-size:18px;">5.字符串类(String类和StringBuffer类)</span></p><br><p><span style="font-size:18px;">6.系统及运行类(System类和Runtime类)</span></p><br><p><span style="font-size:18px;">7.错误和异常处理类(Throwable、Exception、Error)</span></p><br><p><span style="font-size:18px;">8.过程类(process)</span></p><br><p><strong><span style="font-size:18px;">java.util包</span></strong></p><br><p><span style="font-size:18px;">1. 日期类、日历类（Data、Calendar、GregorianCalendar）</span></p><br><p><span style="font-size:18px;">2. 随机数类（Random）</span></p><br><p><span style="font-size:18px;">3. 位运算类（BitSet）</span></p><br><p><span style="font-size:18px;">4. 矢量类（Vector）</span></p><br><p><span style="font-size:18px;">5. 数据结构类（Stack）</span></p><br><p><span style="font-size:18px;">6. 散列表类（Hashtable）</span></p><br><p><span style="font-size:18px;">7. StringTokenizer类<br></span></p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态代理</title>
      <link href="/2016/10/12/2018-9-17-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2016/10/12/2018-9-17-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="使用代理的原因"><a href="#使用代理的原因" class="headerlink" title="使用代理的原因"></a><strong>使用代理的原因</strong></h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a><strong>原因</strong></h3><p>1.把业务代码和系统控制层代码分离，降低类的耦合度。<br>2.在原来的代码上修改代码还不如自己直接重写快。<br><strong>因此产生了静态代理</strong>    </p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a><strong>静态代理</strong></h3><p>通过被代理类注入的方式，实现既可以使用增强逻辑，又可以通过类名.方法调用被代理类的方法  </p><pre><code>增强：             System.out.println(&quot;do some log&quot;);被代理类的方法：        被代理类类名.方法();增强：　　　　          System.out.println(method);</code></pre><p>解决了代码间的强耦合。<br>但缺点在于重复代码过多，eg.当接口增加了方法，代理类也必须增加方法，同时之前写的日志等代理逻辑仍需要在新增的方法重写一遍。（所以适用于小的系统）<br><strong>因此产生了动态代理</strong></p><h3 id="动态代理解决了以上的不足"><a href="#动态代理解决了以上的不足" class="headerlink" title="动态代理解决了以上的不足"></a><strong>动态代理解决了以上的不足</strong></h3><p>动态代理实现了在运行时动态对指定的方法进行绑定，然后在代理类执行增强的逻辑和通过反射机制（invoke）调用被代理类的方法</p><pre><code>增强：             System.out.println(&quot;do some log&quot;);被代理类的方法：        method.invoke(target, args);增强：　　　　          System.out.println(method);</code></pre><p>解决了静态代理把需要代理的方法写死在代理类中的问题</p><h3 id="动态代理又分两种"><a href="#动态代理又分两种" class="headerlink" title="动态代理又分两种"></a><strong>动态代理又分两种</strong></h3><p>一种是代理哪些有接口的类 这种动态代理是基于JDK的动态代理<br>另一种是代理那些没有接口的类 这种动态代理是基于cglib的动态代理<br>它们都不会自己去调用被代理对象的方法，而是交由第三方去invoke</p><p><a href="https://github.com/viabcde/mycoding.github.io/tree/master/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">源代码</a>  </p><h3 id="有接口的动态代理"><a href="#有接口的动态代理" class="headerlink" title="有接口的动态代理"></a><strong>有接口的动态代理</strong></h3><p>被代理类至少实现一个接口<br><strong>创建代理对象的方法：</strong><br>ClassLoader:和被代理对象使用相同的类加载器<br>Class[]：字节码数组，被代理类实现的接口<br>InvocationHandler：写增强代码要实现的接口</p><pre><code>new ProxyInstance(ClassLoader,Class[],InvocationHandler)</code></pre><pre><code>package proxy;public class Actor implements IActor {    @Override    public void basicAct(float money){        System.out.println(&quot;1W只能基本表演&quot;+money);    }    @Override    public void DangerAct(float money){        System.out.println(&quot;5w危险表演&quot;+money);    }}</code></pre><pre><code>package proxy;public interface IActor {    public abstract void basicAct(float money);    public abstract void DangerAct(float money);}</code></pre><pre><code>package proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class Client {    /**     * @param args     */    public static void main(String[] args) {            final IActor actor =new Actor();        IActor proxyActor = (IActor)Proxy.newProxyInstance(actor.getClass().getClassLoader(), actor.getClass().getInterfaces(),                 new InvocationHandler() {                                        @Override                    public Object invoke(Object proxy, Method method, Object[] args)                            throws Throwable {                        Object ReturnValue = null;                        Float money=(Float) args[0];                        if(&quot;basicAct&quot;.equals(method.getName())){                            if(money&gt;10000){                                ReturnValue = method.invoke(actor, money/2);                            }                        }                        if(&quot;DangerAct&quot;.equals(method.getName())){                            if(money&gt;50000){                                ReturnValue = method.invoke(actor, money/3);                            }                        }                        return ReturnValue;                    }                });        proxyActor.basicAct(20000);        proxyActor.DangerAct(60000);        }}</code></pre><h3 id="无接口的动态代理"><a href="#无接口的动态代理" class="headerlink" title="无接口的动态代理"></a><strong>无接口的动态代理</strong></h3><p>要求：被代理类不能是Final修饰的类<br>创建代理对象的方法：<br>create(Class,Callback)<br>Class:被代理对象的字节码<br>Callback:实现该接口的子接口MethodInterceptor<br><img src="https://viabcde.github.io/images/2018-09-17/spring7.png" alt="">    </p><pre><code>package proxyExtend;public class Actor  {    public void basicAct(float money){        System.out.println(&quot;1W只能基本表演&quot;+money);    }    public void DangerAct(float money){        System.out.println(&quot;5w危险表演&quot;+money);    }}</code></pre><pre><code>package proxyExtend;import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;public class Client {    /**     * @param args     */    public static void main(String[] args) {                final Actor actor =new Actor();        Actor proxyActor = (Actor)Enhancer.create(actor.getClass(),                     new MethodInterceptor() {                                                @Override                        public Object intercept(Object proxy, Method method, Object[] args,                                MethodProxy methodproxy) throws Throwable {                            Object ReturnValue = null;                            Float money=(Float) args[0];                            if(&quot;basicAct&quot;.equals(method.getName())){                                if(money&gt;10000){                                    ReturnValue = method.invoke(actor, money/2);                                }                            }                            if(&quot;DangerAct&quot;.equals(method.getName())){                                if(money&gt;50000){                                    ReturnValue = method.invoke(actor, money/3);                                }                            }                            return ReturnValue;                        }                    });        proxyActor.basicAct(20000);        proxyActor.DangerAct(60000);            }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二篇博客</title>
      <link href="/2016/10/12/2018-9-15-%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
      <url>/2016/10/12/2018-9-15-%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>编写一个程序的步骤<br>在day04_javase的视频中，感觉这个老师讲的是超级详细，容易懂得怎么样做，简直是手把手写注释<br>先一个程序：<br>1先分析你这个程序流程<br>2.在写代码钱用注释写出每一个步骤执行什么（大体的框架）<br>3.安装注释在下面一行一行写代码，清晰明了无比<br>（由于那个需求分析的ppt插入不进来，所以一般人还是不太看得懂我说的）<br>1.先分析这个程序的流程，<br>2.用文字注释写在编写的代码行，<br>3.根据注释写出代码<br><img src="https://viabcde.github.io/images/201812/41.png" alt="enter descriptionhere"><br><img src="https://viabcde.github.io/images/201812/42.png" alt="enter descriptionhere">     </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Date</title>
      <link href="/2016/10/12/2018-9-17-Date/"/>
      <url>/2016/10/12/2018-9-17-Date/</url>
      
        <content type="html"><![CDATA[<h2 id="java-Date"><a href="#java-Date" class="headerlink" title="java Date"></a><strong>java Date</strong></h2><h3 id="在编程中，一般涉及到日期的操作有三种："><a href="#在编程中，一般涉及到日期的操作有三种：" class="headerlink" title="在编程中，一般涉及到日期的操作有三种："></a><strong>在编程中，一般涉及到日期的操作有三种：</strong></h3><p>日期的表示、转换、设定修改<br>java把这三个功能分成了三个类，其中：  </p><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a><strong>Date类</strong></h3><p>负责时间表示，从1970.1.1 00:00:00 到当前时间的毫秒数进行计时，毫秒数就是指从1970年到对应时间的毫秒数。在Java 的Date类内部其实也是一个毫秒数，对外表现为一个Date对象  </p><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a><strong>Calendar</strong></h3><p>负责对Date类进行修改等，以及从Date类提取年月日等信息。  </p><h3 id="DateFormat"><a href="#DateFormat" class="headerlink" title="DateFormat"></a><strong>DateFormat</strong></h3><p>负责日期转换，比如读取特定格式的字符串，转换成date对象，或者将date对象按照指定的格式转成字符串。  </p><h3 id="Date类-1"><a href="#Date类-1" class="headerlink" title="Date类"></a><strong>Date类</strong></h3><p>Date类内部其实是一个从1970到其代表的时间之间的毫秒数，有一个filed要表示这个毫秒数，这就是 fastTime这个域的作用了。<br>private transient long fastTime;<br>Date的两个构造函数，一个是无参的，一个是接收了一个long类型的毫秒数，无参构造函数其实是调用了系统的当前毫秒数。最终都是将fastTime这个属性赋值一个对应时间的毫秒数。    </p><pre><code>public Date() {    this(System.currentTimeMillis());}public Date(long date) {    fastTime = date;}</code></pre><p>Date类还可以对时间进行比较，比如before，after，compareTo等方法，都是对时间的先后进行比较的。<br>Date类还是保留一些工具类的方法的，比如这个静态的getMillisOf()就是获取date对象的毫秒数。    </p><pre><code>static final long getMillisOf(Date date) {    if (date.cdate == null || date.cdate.isNormalized()) {        return date.fastTime;    }    BaseCalendar.Date d = (BaseCalendar.Date) date.cdate.clone();    return gcal.getTime(d);}</code></pre><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a><strong>Calendar类</strong></h3><p>Calendar的使用：<br>Calendar是一个抽象类，不能直接实例化，但是Calendar类提供一个工厂方法，即getInstance来创建一个Calendar实例。<br>通过setTime()设定一个Calendar内部的毫秒数，之后就可以得到它的年月日信息。<br>也可以对Calendar直接设定年月日属性，从而获取对应的Date对象。<br>注意，Calendar的一月是从0开始的，即你设定月份为4时，其实是五月。<br>下面是一个Calendar的简单示例。  </p><pre><code>Date now = new Date();Calendar calendar = Calendar.getInstance();calendar.setTime(now);calendar.get(Calendar.YEAR);System.out.println(&quot;the year is &quot;+calendar.get(Calendar.YEAR));System.out.println(&quot;the month is &quot;+calendar.get(Calendar.MONTH));calendar.set(Calendar.YEAR, 2014);calendar.set(Calendar.MONTH, 2);calendar.set(Calendar.DAY_OF_MONTH, 12);System.out.println(&quot;calendar date is &quot;+calendar.getTime());</code></pre><p>输出：<br>the year is 2016<br>the month is 9<br>calendar date is Wed Mar 12 22:17:50 CST 2014<br>在讲到Calendar就不可避免的涉及到java的国际化问题和时区的问题。  </p><h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a><strong>国际化</strong></h3><p>Locale 表示地区，每一个Locale对象都代表了一个特定的地理、政治和文化地区。<br>你可以用如下代码看看你的系统默认地区。  </p><pre><code>Locale locale = Locale.getDefault();locale.getCountry();locale.getLanguage();System.out.println(&quot;default locale is &quot;+locale);System.out.println(&quot;default country is &quot;+locale.getCountry());System.out.println(&quot;default language is &quot;+locale.getLanguage());</code></pre><p>比如我这里的输出就是：<br>default locale is zh_CN<br>default country is CN<br>default language is zh<br>说明了我所在的国家时CN，语言是zh。  </p><h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a><strong>时区</strong></h3><p>在java中用java.util.TimeZone类来表示一个时区。每一个时区都一个id，可以利用TimeZone.getAvailableIDs()这个方法获取所有的id。<br>你可以试试利用如下代码看看你的系统默认时区。  </p><pre><code>TimeZone timeZone = TimeZone.getDefault();  System.out.println(&quot;default time zone is &quot;+ timeZone.getDisplayName());  </code></pre><p>本文的默认时区是<br>default time zone is 中国标准时间<br>3 Calendar的工厂构造方法<br>前面说到，Calendar是一个抽象类，提供了static的工厂构造方法 来提供一个实例。<br>Calendar有多个的工厂构造方法：  </p><pre><code>public static Calendar getInstance(){    return createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT));}public static Calendar getInstance(Locale aLocale){    return createCalendar(TimeZone.getDefault(), aLocale);}public static Calendar getInstance(TimeZone zone, Locale aLocale){    return createCalendar(zone, aLocale);}</code></pre><p>从上面的代码看出，Calendar的实例构造最终都是调用了这个方法<br>private static Calendar createCalendar(TimeZone zone, Locale aLocale)<br>这个方法接收两个参数，一个是时区，一个是地区。通过对地区的判定返回不同的Calendar的子类（实现类）<br>当我们有了Calendar的实例后，就可以对Date对象进行分析，提取出对应的年月日；也可以通过设定对应的年月日从而获取对应的Date对象。  </p><h3 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a><strong>DateFormat类</strong></h3><p>1 DateFormat类的作用<br>DateFormat用来在Date对象和字符串之间进行转化。<br>比如，我有一个date，想转成2013年12月01日这种样式，或者想从2013-12-01这个字符串转成一个date对象，都可以利用DateFormat类。<br>2 DateFormat类的结构<br>DateFormat本身是一个抽象类，但是定义好了所有的方法，一般使用它的子类SimpleDateFormat，这也是一个标准的模板模式（template pattern）。<br>在DateFormat中定义了众多的方法，最重要的就是parse()和format()，这两个方法一个是将字符串转成Date对象，一个是将Date对象按照指定的模式进行转换字符串。<br>3 利用DateFormat进行转换<br>DateFormat虽然是个抽象类，我们在日常中可以使用它的子类SimpleDateFormat类，但DateFormat还是提供了一些static方法构建DateFormat实例，进行简单的转换日期功能。<br>DateFormat提供的转换格式分为两种，一种是只转换Date部分，一种是转换Date和Time两个部分。<br>先看只转换Date部分的，从代码中能看出，你可以调用getDateInstance()这个系列方法，最后其实调用的都是get方法。<br>这个系列主要需要注意的两个参数就是style参数和Locale参数。style决定日期格式的长度，默认的的default是2，从DateFormat类中定义了几个常数，这个2就是medium，也可以设置为LONG。另一个参数是地区，决定日期输出语言，中文就是年月日，英文就是单词了，我下面用一个例子说明不同参数的区别。  </p><pre><code>DateFormat format = DateFormat.getDateInstance(DateFormat.SHORT, Locale.SIMPLIFIED_CHINESE);DateFormat format2 = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.SIMPLIFIED_CHINESE);DateFormat format3 = DateFormat.getDateInstance(DateFormat.LONG, Locale.SIMPLIFIED_CHINESE);DateFormat format4 = DateFormat.getDateInstance(DateFormat.SHORT, Locale.ENGLISH);DateFormat format5 = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.ENGLISH);DateFormat format6 = DateFormat.getDateInstance(DateFormat.LONG, Locale.ENGLISH);try {    System.out.println(&quot;format : &quot; +format.format(new Date()));    System.out.println(&quot;format2 : &quot;+format2.format(new Date()));    System.out.println(&quot;format3 : &quot;+format3.format(new Date()));    System.out.println(&quot;format4 : &quot;+format4.format(new Date()));    System.out.println(&quot;format5 : &quot;+format5.format(new Date()));    System.out.println(&quot;format6 : &quot;+format6.format(new Date()));} catch (Exception e) {    e.printStackTrace();}</code></pre><p>输出：<br>format : 16-11-2<br>format2 : 2016-11-2<br>format3 : 2016年11月2日<br>format4 : 11/2/16<br>format5 : Nov 2, 2016<br>format6 : November 2, 2016<br>上面的例子，对构造DateFormat的地区和style参数就进行了说明，可看出style参数设为SHORT时，中英文的日期表示也是不一样的。<br>再说说DateFormat的转换日期和时间格式，即转换的Date对象同时包含日期和时间数据。这也是一个系列的方法，与上面说的getDateInstance()系列类似。<br>与只转换日期格式的Date有个重要的地方就是这里有两个sytle，一个是日期style，一个是时间style，可以根据自己的需要自由组合日期和时间style。  </p><pre><code>public final static DateFormat getDateTimeInstance(){    return get(DEFAULT, DEFAULT, 3, Locale.getDefault(Locale.Category.FORMAT));}public final static DateFormat getDateTimeInstance(int dateStyle,  int timeStyle){    return get(timeStyle, dateStyle, 3, Locale.getDefault(Locale.Category.FORMAT));}public final static DateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale aLocale){    return get(timeStyle, dateStyle, 3, aLocale);}</code></pre><h3 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a><strong>SimpleDateFormat类</strong></h3><p>1 SimpleDateFormat使用<br>其实这个SimpleDateFormat类是我们日常转换字符串和Date对象最常用的类。<br>我们如果用DateFormat进行转换格式，只能用它规定的几种格式进行转换，非常的不直观，从字面我们看不出来从Date转出来的日期是怎样的格式。<br>但是如果用SimpleDateFormat就不一样了，在构造SimpleDateFormat我们可以直接传一个pattern，只要pattern符合要求且是合理的，就可以对Date和字符串进行转换了。<br>这个其实不用多说，只要来一个例子就都明白了，这里有一个坑，就是m和M是不一样的，m是分钟（minute），而M是月份，用的时候一定要注意。  </p><pre><code>String dateString = &quot;2013-02-12T12:22:33&quot;;SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&#39;T&#39;hh:mm:ss&quot;);System.out.println(&quot;simpleDate format &quot; + simpleDateFormat.format(new Date()));try {    System.out.println(&quot;simpleDate parse &quot;+ simpleDateFormat.parse(dateString));} catch (ParseException e) {    e.printStackTrace();}</code></pre><p>输出：<br>simpleDate format 2016-11-02T09:19:58<br>simpleDate parse Tue Feb 12 00:22:33 CST 2013<br>还有就是当parse时，只有你的字符串和SimpleDateFormat的pattern完全匹配才能识别，否则报错。<br>总结：<br>当我们只需要一个日期时，或从系统取得，或从数据库查询，都可以放入一个Date对象。<br>当我们需要对Date进行详细分析，获取其中的年月日分秒各个部分的信息，用Calendar类。<br>当我们需要对一个字符串转成Date对象，或者想让一个Date对象按照我们预期的格式进行输出字符串时，需要用DateFormat类或它的子类SimpleDateFormat。  </p><h3 id="system-out-println"><a href="#system-out-println" class="headerlink" title="system.out.println()"></a><strong>system.out.println()</strong></h3><p>out是system类中的一个静态变量，它可以调用printStream的println()方法  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2016/10/12/2018-9-17-java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/"/>
      <url>/2016/10/12/2018-9-17-java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/</url>
      
        <content type="html"><![CDATA[<h3 id="int与Integer的基本使用对比"><a href="#int与Integer的基本使用对比" class="headerlink" title="* int与Integer的基本使用对比**"></a>* int与Integer的基本使用对比**</h3><p>（1）由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p><pre><code>Integer i = new Integer(100);//新建的对象，不取常量池中的100Integer j = new Integer(100);System.out.print(i == j); //false</code></pre><p>Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p><pre><code>Integer i = new Integer(100);int j = 100；System.out.print(i == j); //true，和int比较则自动拆箱为int，比较</code></pre><p>（3）非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）</p><pre><code>Integer i = new Integer(100);//新建的对象，不取常量池的100Integer j = 100;//取常量池中的100System.out.print(i == j); //false</code></pre><p>（4）对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p><pre><code>Integer i = 100;//非new对象，取常量池中的100Integer j = 100;System.out.print(i == j); //trueInteger i = 128;//超过127，常量池没有，则新建对象Integer j = 128;System.out.print(i == j); //false</code></pre><p>　　对于第4条的原因： java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)。而java API中对Integer类型的valueOf的定义如下，对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了。</p><pre><code>public static Integer valueOf(int i){    assert IntegerCache.high &gt;= 127;    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high){        return IntegerCache.cache[i + (-IntegerCache.low)];    }    return new Integer(i);}</code></pre><h3 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a><strong>线程池的作用</strong></h3><p>当启动和销毁线程的时间总和大于线程执行时间时，就需要线程池来提高效率</p><h3 id="short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错"><a href="#short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错" class="headerlink" title="short s1 =1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?"></a><strong><code>short s1 =1; s1 = s1 + 1;</code>有什么错? <code>short s1 = 1; s1 += 1;</code>有什么错?</strong></h3><p><code>short s1 = 1; s1 = s1 + 1;</code> （s1+1运算结果是int型，需要强制转换类型）   <code>short s1 = 1; s1 += 1;</code>（可以正确编译）</p><h3 id="Spring整合ORM框架时事务管理用的是"><a href="#Spring整合ORM框架时事务管理用的是" class="headerlink" title="Spring整合ORM框架时事务管理用的是"></a><strong>Spring整合ORM框架时事务管理用的是</strong></h3><p>由相应ORM框架的事务管理器类如Hibernate对应于HibernateTransactionManager<br>整合过后可配置由Spring控制事务的提交。<br>http请求由请求行、消息报头、请求正文组成，http响应由状态行、消息报头和响应正文组成   </p><h3 id="Object类的常用方法"><a href="#Object类的常用方法" class="headerlink" title="Object类的常用方法"></a><strong>Object类的常用方法</strong></h3><pre><code>protected Object clone()//创建并返回此对象的一个副本。   boolean equals(Object obj)//指示其他某个对象是否与此对象“相等”。   String toString()//返回该对象的字符串表示。void wait()//在其他线程调用此对象的 notify() 方法或 notifyAll() //方法前，导致当前线程等待。 void notify()//唤醒在此对象监视器上等待的单个线程。   void notifyAll()//唤醒在此对象监视器上等待的所有线程。int hashCode()//返回该对象的哈希码值。Class&lt;&gt; getClass()//返回此 Object 的运行时类。  protected void finalize()//当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</code></pre><h3 id="常用的类，包，接口，常见的runtime-exception"><a href="#常用的类，包，接口，常见的runtime-exception" class="headerlink" title="常用的类，包，接口，常见的runtime exception"></a><strong>常用的类，包，接口，常见的runtime exception</strong></h3><p>常用的类：BufferedReader、BufferedWriter、FileReader、FileWirter、String、Integer 、StringBuffer、Stack<br>常用的包：java.lang、java.awt、java.io、java.util、java.sql、javax.xml、java.NET<br>常用的接口： List、Map、Document、NodeList、Remote<br>常见的异常：ArithmeticException （a=5/0即数学运算中除0异常）ClassCastException （强制转换异常）NullPointerException（空指针异常，使用Null时）ArrayIndexOutofBoundsException（数组越界）StringIndexOutBoundsException（指示索引或者为负或者超出字符串大小）IndexOutOfBoundsException（下标越界）NegativeArraySizeException（创建大小为负的数组）IllegalArgumentException（传递非法参数）SecurityException（安全异常）NumberFormatException（数据格式异常，字符串-&gt;数字）FileNotFoundException（文件未找到异常）SQLException（操作数据库异常）IOException（I/O输入输出异常）   </p><h3 id="平时一般怎么处理事务呢？"><a href="#平时一般怎么处理事务呢？" class="headerlink" title="平时一般怎么处理事务呢？"></a><strong>平时一般怎么处理事务呢？</strong></h3><p>spring的事务是通过“声明式事务”的方式对事务进行管理，即在配置文件中进行声明，通过AOP将事务切面切入程序，最大的好处是大大减少了代码量，提高了工作效率。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2016/10/12/2018-9-15-1/"/>
      <url>/2016/10/12/2018-9-15-1/</url>
      
        <content type="html"><![CDATA[<p>所谓三天不读口生,三天不练手生，许多知识即使你现在掌握了，但只要一个暑假不接触，很快便又把知识还给老师，回到原点了.  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 标签 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
