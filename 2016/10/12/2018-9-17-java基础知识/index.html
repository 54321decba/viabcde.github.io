
<!DOCTYPE html>
<html lang="" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>廖锡洪</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="viabcde,"> 
    
    <meta name="author" content="viacbde"> 
    <link rel="alternative" href="atom.xml" title="廖锡洪" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
</head>
</html>
<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">Java基础知识</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">Java基础知识</h1>
        <div class="stuff">
            <span>十月 12, 2016</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/java/">java</a><span class="post-tags-list-count">7</span></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/标签/">标签</a><span class="post-tags-list-count">162</span></li></ul>


        </div>
        <div class="content markdown">
            <h3 id="反码-取反-补码"><a href="#反码-取反-补码" class="headerlink" title="反码 取反 补码"></a><strong>反码 取反 补码</strong></h3><p>1.反码是指符号位不变 其他位改变 符号位1为负 0为正<br>2.取反是指所有位都改变<br>3.正数的补码与原码相同 无需改变 , 而负数的补码是 取绝对值 取反 再加1<br>反过来由补码获取原码 减1 取反 取绝对值<br>4.计算机运算都是以补码来运算 如 ~ 2 和 ~-2 都是对补码的取反 而不是原码  </p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h3><p>一个字节（byte）=8位 有2的8次方种可能 范围-128~127 负0（1000 0000）表示-128 正0（0000 0000）表示0<br>以此类推 short = 2个字节 <code>2*8</code>（位） int 4个字节 long 8个字节  </p>
<h3 id="字符相加"><a href="#字符相加" class="headerlink" title="字符相加"></a><strong>字符相加</strong></h3><p>字符相加是指其对于的ASCII码相加后 在ASCII表中对应的字符 如果没有对应的 即打印一个 ？</p>
<h3 id="强制转换为int"><a href="#强制转换为int" class="headerlink" title="强制转换为int"></a><strong>强制转换为int</strong></h3><p>在强转为int时，只保留整数部分 小数部分无论多少都舍去 没有四舍五入的操作</p>
<h3 id="从控制台读取输入的内容"><a href="#从控制台读取输入的内容" class="headerlink" title="从控制台读取输入的内容"></a><strong>从控制台读取输入的内容</strong></h3><p>使用InputStreamReader 读取控制台的内容（system.in）<br>再使用BufferReader 读取InputStrreamReader的内容 之后由BufferReader调用readLine()输出给一个引用变量（String s = br.readLine()）<br>inputStreamReader外面包一层BufferReader<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*从控制台读取输入内容*/</span><br><span class="line">		try &#123;</span><br><span class="line">			InputStreamReader isr = new InputStreamReader(System.in);</span><br><span class="line">			BufferedReader br = new BufferedReader(isr);</span><br><span class="line">			String a = bd.readLine();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			// TODO: handle exception</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = new Scanner(system.in);</span><br><span class="line">String s=sc.nextInt();</span><br></pre></td></tr></table></figure>
<h3 id="String转为float"><a href="#String转为float" class="headerlink" title="String转为float"></a><strong>String转为float</strong></h3><p>Float f = float.parseFloat(a);</p>
<h3 id="打印菱形"><a href="#打印菱形" class="headerlink" title="打印菱形"></a><strong>打印菱形</strong></h3><p>先使用一个for 控制输出多少行<br>再在里面嵌套2个for<br>第一个for控制每一行里先输出多少个空格<br>第二个for控制空格之后输出多少个星号<code>“*”</code><br>在第二个for中使用if判断是否是第一列和最后一列 输出星号<code>“*”</code><br>否则输出空格     </p>
<h3 id="何时会被当成垃圾回收"><a href="#何时会被当成垃圾回收" class="headerlink" title="何时会被当成垃圾回收"></a><strong>何时会被当成垃圾回收</strong></h3><p>当指针不再指向该数据时会被当成垃圾等待回收<br>当内存即将不够用的时候，GC会遍历一遍对象，没有被遍历到的对象会被清除  </p>
<h3 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a><strong>默认构造方法</strong></h3><p>每个对象都会有一个默认的空构造方法<br>public person(){}<br>如果自己写了构造方法 则默认的构造方法会被覆盖<br>要使用空构造方法则需要显式写出来 才能使用  </p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a><strong>this</strong></h3><p>this.name 相当于 对象说了一句 我的name<br>用于区分同名成员变量和局部变量    </p>
<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a><strong>静态变量</strong></h3><p>也称为类变量，因为它是属于类的而不是实例对象的，通过类名.变量来使用它<br>例子：static int a=1;</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a><strong>静态方法</strong></h3><p>静态方法在类编译完就会执行 而且只执行一次属于类而不是实例对象的<br>静态方法不能访问非静态变量 因为静态方法编译后，在类装载时初始化存在内存中，而非静态变量在编译后不存在内存中（只有在new之后才加入到内存），根本就找不到该变量，访问不到 执行顺序：类加载-&gt;main  </p>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a><strong>访问权限</strong></h3><p>记忆很简单 画一个<code>4*4</code>矩阵  范围依次递减 √ 即可<br>|    范围|同类 | 同包|子类|不同包    |<br>| — | — | — | — | — |<br>|     public   | √| √|√|√    |<br>|protected|√ | √|√|<br>  |default  |√| √|<br>  |private  |√ |</p>
<h3 id="package的作用"><a href="#package的作用" class="headerlink" title="package的作用"></a><strong>package的作用</strong></h3><p>将源文件的字节码打包到同一个包中  </p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a><strong>封装</strong></h3><p>隐藏对象的属性和实现细节，仅对外提供公共访问方式   </p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h3><p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义，可以省略代码，使用extends关键字<br>即可继承那个类。<br>子类可以访问父类的非private属性及方法，但不能缩小父类的访问权限     </p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h3><p>前提是有继承或接口<br>可以创建相同父类或接口类型的不同子类对象<br>这样在写构造方法时 不需要按不同子类类型写多个重载方法  </p>
<h3 id="动态绑定（迟邦定）-多态"><a href="#动态绑定（迟邦定）-多态" class="headerlink" title="动态绑定（迟邦定） 多态"></a><strong>动态绑定（迟邦定） 多态</strong></h3><p> 在编译时指向的是父类的内存 而运行时   方法实际传入的是哪个子类便更改指向父类的指针为指向子类的内存   把子类当做父类使用 即向上转型</p>
<h3 id="super-f"><a href="#super-f" class="headerlink" title="super.f()"></a><strong>super.f()</strong></h3><p>指的是调用父类的f方法<br>子类的构造必须先调用父类的构造方法super()   通过参数列表的不同指明调用父类的哪个构造方法<br>因为子类需要用到父类的属性和方法 所以必须先把父类构造出来才能用<br>如果没写 系统默认使用父类空的构造方法</p>
<h3 id="重写和重载的区别？"><a href="#重写和重载的区别？" class="headerlink" title="重写和重载的区别？"></a><strong>重写和重载的区别？</strong></h3><p>重载：在同一类中。方法名相同，参数列表不同。重载可以改变返回类型。<br>重写：在不同类中(子父类中)。<br>方法声明相同(返回类型，方法名，参数列表均相同)。   </p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><strong>抽象类</strong></h3><p>抽象是将某一类事务归类的研究方法（抽象是一种研究的方法）<br>当父类方法的逻辑很大概率会被子类覆盖重写时 可以将父类定义为抽象类<br>抽象类和抽象方法都要用abstract进行修饰<br>抽象类有构造方法但不能被实例化,只能被子类实例化，子类必须实现父类的所有抽象方法<br>抽象类中可以有变量，也可以有常量<br>抽象类中可以有抽象方法，也可以有非抽象方法<br>abstract不能和provate\static\final共存<br>接口是更加抽象的抽象类<br>一个类中的方法都是抽象的时候，可以抽象为接口<br>接口中的变量常量，默认修饰 public static final<br>方法默认修饰 public abstract<br>抽象类是对一类事物的抽象 而接口是对一个功能的抽象<br>static final 前期绑定<br>多态 后期绑定<br> <strong>当子类不想实现父类抽象方法时 ，则可以在写一个同名的抽象方法即可不用实现</strong>   </p>
<h3 id="接口不能代替抽象类"><a href="#接口不能代替抽象类" class="headerlink" title="接口不能代替抽象类"></a><strong>接口不能代替抽象类</strong></h3><p>因为如果需要维护一个类的信息和状态时需要用到实例成员变量（没有static修饰）<br>而接口中的变量都用 static final修饰</p>
<h3 id="符号运算"><a href="#符号运算" class="headerlink" title="符号运算"></a><strong>符号运算</strong></h3><p>左移&lt;&lt;右侧补0<br>右移&gt;&gt;左侧补符号位</p>
<h3 id="ArrayList与Vector区别"><a href="#ArrayList与Vector区别" class="headerlink" title="ArrayList与Vector区别"></a><strong>ArrayList与Vector区别</strong></h3><p>ArrayList用于异步 容量不足自动扩展为原来的1.5倍<br>Vector用于同步 容量不足自动扩展为原来的2倍</p>
<h3 id="遍历HashMap"><a href="#遍历HashMap" class="headerlink" title="遍历HashMap"></a><strong>遍历HashMap</strong></h3><p>iterator.next来获取key<br>通过get(key)获取Value<br><img src="https://viabcde.github.io/images/2018-09-26/2018092601.png" alt="enter description
here">  </p>
<h3 id="HashMap与HashTable区别"><a href="#HashMap与HashTable区别" class="headerlink" title="HashMap与HashTable区别"></a><strong>HashMap与HashTable区别</strong></h3><p>HashMap用于异步 其key与value 可以为空，当多线程同时put的时候，会欺骗程序，hashmap容量不足，导致rehash操作（即扩容），导致死循环<br>HashTable用于同步 其key与value 不可以为空 编译时不报错 运行时出错</p>
<h3 id="hashMap是根据key的hashCode来寻找存放位置的，那当key为null时，-怎么存储呢？"><a href="#hashMap是根据key的hashCode来寻找存放位置的，那当key为null时，-怎么存储呢？" class="headerlink" title="hashMap是根据key的hashCode来寻找存放位置的，那当key为null时， 怎么存储呢？"></a><strong>hashMap是根据key的hashCode来寻找存放位置的，那当key为null时， 怎么存储呢？</strong></h3><p>在put方法里头，其实第一行就处理了key=null的情况。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (key == null)  </span><br><span class="line">    return putForNullKey(value);  </span><br><span class="line">//那就看看这个putForNullKey是怎么处理的吧。  </span><br><span class="line">private V putForNullKey(V value) &#123;  </span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;  </span><br><span class="line">        if (e.key == null) &#123;  </span><br><span class="line">            V oldValue = e.value;  </span><br><span class="line">            e.value = value;  </span><br><span class="line">            e.recordAccess(this);  </span><br><span class="line">            return oldValue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    modCount++;  </span><br><span class="line">    addEntry(0, null, value, 0);  </span><br><span class="line">    return null;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，前面那个for循环，是在talbe[0]链表中查找key为null的元素，如果找到，则将value重新赋值给这个元素的value，并返回原来的value。<br>如果上面for循环没找到则将这个元素添加到talbe[0]链表的表头。 </p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a><strong>泛型</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">泛型Generic  </span><br><span class="line">起因：  </span><br><span class="line">    ·JDK1.4以前类型不明确：  </span><br><span class="line">        ·装入集合的类型都被当作Object对待，从而失去自己的实际类型  </span><br><span class="line">        ·从集合中取出时往往需要转型，效率低，容易产生错误  </span><br><span class="line">解决办法  </span><br><span class="line">    ·在定义集合的时候同时定义集合中对象的类型  </span><br><span class="line">    ·实例：  </span><br><span class="line">        ·可以再定义Collection的时候指定  </span><br><span class="line">        ·也可以在循环时用Iterator指定  </span><br><span class="line">    List&lt;String&gt; c = arrayList&lt;String&gt;();  </span><br><span class="line">    Iterator&lt;String&gt; it = c2.iterator();  </span><br><span class="line">好处  </span><br><span class="line">    ·增强程序的可读性和稳定性</span><br></pre></td></tr></table></figure>
<p>定义一个SeqList&lt; T &gt;类<br>在创建实例时可以自定义元素类型 ，如<br>SeqList&lt; String &gt; a =new SeqList&lt; String &gt;();<br>SeqList&lt; Integer &gt; a =new SeqList&lt; Integer &gt;();<br><strong>优点：</strong>不使用泛型 则从list取出来的元素是Object，需要做强制转换<br>如果此时转换的类型与元素期望的类型不符 编译时不报错 运行时报错<br>使用泛型 则不需要强制转换 如果创建与元素期望不符的类型 编译时报错提醒<br><strong>缺点：</strong>仍然可以使用反射机制来加入不同类型的元素<br>collection.getClass().getMethod(“add”,Object.class).invoke(collection1,”aaa”);  </p>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a><strong>finally</strong></h3><p>文件如果不调用close()方法则数据并不会存入文件<br>在finally中关闭文件 连接等操作 防止内存泄漏    </p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a><strong>final</strong></h3><p>因为final是常量 不会改变，所以对它进行优化 ，在编译阶段就使用它 而static真正使用是在运行时才能使用</p>
<h3 id="不同try用throws"><a href="#不同try用throws" class="headerlink" title="不同try用throws"></a><strong>不同try用throws</strong></h3><p>报错时不知道错误发生在哪一行</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h3><p>在剩下的元素中比较出最大/小    的，放在最后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;a.length-1;i++)&#123;</span><br><span class="line">	for(int j=0;j&lt;a.length-1-i;j++)&#123;</span><br><span class="line">		if(a[j]&gt;a[j+1])&#123;</span><br><span class="line">			temp=a[j];</span><br><span class="line">			a[j]=a[j+1];</span><br><span class="line">			a[j+1]=temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h3><p>从第一个元素开始通过和剩下的元素比较大小为每一个元素定好位，及最终排好序的位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;a.length-1;i++)&#123;</span><br><span class="line">	int min=a[i];</span><br><span class="line">	int index=i;</span><br><span class="line">	for(int j=i+1;j&lt;a.length,j++)&#123;</span><br><span class="line">		if(min&gt;a[j])&#123;</span><br><span class="line">			min=a[j];</span><br><span class="line">			index=j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	temp=a[i];</span><br><span class="line">	a[i]=a[j];</span><br><span class="line">	a[index]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><strong>插入排序</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;a.length;i++)&#123;</span><br><span class="line">	int insertVal=a[i];</span><br><span class="line">	int index=i-1;</span><br><span class="line">	while(index&gt;=0&amp;&amp;insertVal&gt;a[index])&#123;</span><br><span class="line">		a[index+1]=a[index];</span><br><span class="line">		index--;</span><br><span class="line">	&#125;</span><br><span class="line">	a[index+1]=insertVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JVM内存管理-内存空间、内存分配、内存回收"><a href="#JVM内存管理-内存空间、内存分配、内存回收" class="headerlink" title="JVM内存管理(内存空间、内存分配、内存回收)"></a><strong>JVM内存管理(内存空间、内存分配、内存回收)</strong></h3><p>当内存空间即将用完，GC就会暂停程序，遍历所有对象并标记为1，没有被标记（及没被遍历到）的对象清除掉，最后再把所有被标记的全部置0</p>
<h3 id="那为什么要暂停来垃圾回收"><a href="#那为什么要暂停来垃圾回收" class="headerlink" title="那为什么要暂停来垃圾回收"></a><strong>那为什么要暂停来垃圾回收</strong></h3><p>因为如果在标记完成，清除没被标记的对象期间，所有在这个期间new出来的对象都会被误删</p>
<h3 id="绝对值"><a href="#绝对值" class="headerlink" title="绝对值"></a><strong>绝对值</strong></h3><p>math.abs();</p>
<h3 id="awt与Swing"><a href="#awt与Swing" class="headerlink" title="awt与Swing"></a><strong>awt与Swing</strong></h3><p>awt 会随系统而改变样式，Swing不会 但却消耗内存</p>
<h3 id="JFrame"><a href="#JFrame" class="headerlink" title="JFrame"></a><strong>JFrame</strong></h3><p>j.serTitle();<br>j.setSize();<br>j.setLocation();<br>j.setVisival();<br>j.setDefaultColseOperation(JFram_Exit_IN);  </p>
<h3 id="边界布局"><a href="#边界布局" class="headerlink" title="边界布局"></a><strong>边界布局</strong></h3><p>borderLayout 东西南北中</p>
<h3 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a><strong>流式布局</strong></h3><p>FlowLayout 随窗口排列</p>
<h3 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a><strong>静态导入</strong></h3><p>import static 则在类中不需要使用类名.方法名调用方法 只需用方法名即可</p>
<h3 id="增强的for循环"><a href="#增强的for循环" class="headerlink" title="增强的for循环"></a><strong>增强的for循环</strong></h3><p>for(int i : args){}</p>
<h3 id="装箱、拆箱"><a href="#装箱、拆箱" class="headerlink" title="装箱、拆箱"></a><strong>装箱、拆箱</strong></h3><p>Integer i=1; 将int类型的 1 装箱为Integer<br>syso(i+3);将Integer类型的i 拆箱为int 之后与3相加</p>
<h3 id="享-元模式"><a href="#享-元模式" class="headerlink" title="享 元模式"></a><strong>享 元模式</strong></h3><p>把程序共有的部分封装为一个方法 而不同的部分作为方法的参数传入</p>
<h3 id="获取字节码的方法"><a href="#获取字节码的方法" class="headerlink" title="获取字节码的方法"></a><strong>获取字节码的方法</strong></h3><p>String s=”aaa”;<br>1.String.getClass();<br>2.s.getClass();<br>3.ClassforName(“java.lang.String”);</p>
<h3 id="获取类的构造方法"><a href="#获取类的构造方法" class="headerlink" title="获取类的构造方法"></a><strong>获取类的构造方法</strong></h3><p>s.getClass().getConstructor();</p>
<h3 id="获取类的属性"><a href="#获取类的属性" class="headerlink" title="获取类的属性"></a><strong>获取类的属性</strong></h3><p>s.getClass().getFiled</p>
<h3 id="i-和-i"><a href="#i-和-i" class="headerlink" title="i++和++i"></a><strong>i++和++i</strong></h3><p>在赋值时有区别 但在for循环中只是自加的作用 没有区别 据说++i比i++快一些</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h3><p>数组变量中存了数组第一个元素的首地址、数组的容量，一级有效个数<br>当需要取出第二个元素时，第二个元素首地址=第一个元素首地址+1</p>
<h3 id="java内存泄漏情况"><a href="#java内存泄漏情况" class="headerlink" title="java内存泄漏情况"></a><strong>java内存泄漏情况</strong></h3><p>忘记关闭数据库连接 忘记删除监听器 没有及时将对象设为null</p>
<h3 id="equals和"><a href="#equals和" class="headerlink" title="equals和=="></a><strong>equals和==</strong></h3><p>equals表示内容相同 首地址不一定相同<br>而“==”表示首地址相同 此时 内容肯定也相同</p>
<h3 id="ip和端口"><a href="#ip和端口" class="headerlink" title="ip和端口"></a><strong>ip和端口</strong></h3><p>ip表示网络中的主机 端口表示主机上的程序</p>
<h3 id="数据类型相加"><a href="#数据类型相加" class="headerlink" title="数据类型相加"></a><strong>数据类型相加</strong></h3><p>1.int型以下(byte short 还有char)作为操作数，jvm会将其类型提升至int   再参与运算；int型以上保持原有类型<br>2.表达式返回值的类型会提升至操作符两边表数范围较大的那一方的类型</p>
<h3 id="instanceof-判断一个对象是否属于某个类的示例"><a href="#instanceof-判断一个对象是否属于某个类的示例" class="headerlink" title="instanceof 判断一个对象是否属于某个类的示例"></a><strong>instanceof 判断一个对象是否属于某个类的示例</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test_instanceof &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String s = &quot;Hello&quot;;</span><br><span class="line">		int[] a = &#123;1,2&#125;;</span><br><span class="line">		if(s instanceof String)</span><br><span class="line">			System.out.println(&quot;true&quot;);</span><br><span class="line">		if(s instanceof Object)</span><br><span class="line">			System.out.println(&quot;true&quot;);</span><br><span class="line">		if(a instanceof int[])</span><br><span class="line">			System.out.println(&quot;true&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a><strong>继承</strong></h3><p>是子类和父类之间的关系 即把各个子类的公共属性提取出来作为父类<br><img src="https://viabcde.github.io/images/2018-09-27/2018092703.png" alt="enter description here"> </p>
<h3 id="return"><a href="#return" class="headerlink" title="return"></a><strong>return</strong></h3><p>返回的值 会临时保存在栈内存中 方法结束后该内存才消失</p>
<h3 id="equals方法默认比较的是首地址-必须重写"><a href="#equals方法默认比较的是首地址-必须重写" class="headerlink" title="equals方法默认比较的是首地址 必须重写"></a><strong>equals方法默认比较的是首地址 必须重写</strong></h3><p>String类 已经重写了equals方法 所以用String 比较时 不用自己重写equals方法  </p>
<h3 id="局部变量系统不会自动初始化-成员变量才会"><a href="#局部变量系统不会自动初始化-成员变量才会" class="headerlink" title="局部变量系统不会自动初始化 成员变量才会"></a><strong>局部变量系统不会自动初始化 成员变量才会</strong></h3><h3 id="new-String-c-4-3"><a href="#new-String-c-4-3" class="headerlink" title="new String(c,4,3);"></a><strong>new String(c,4,3);</strong></h3><p>从c 的第4个字符串开始截取3个字符</p>
<h3 id="s-indexof-“java”"><a href="#s-indexof-“java”" class="headerlink" title="s.indexof(“java”)"></a><strong>s.indexof(“java”)</strong></h3><p>首次出现java 的第一个位置</p>
<h3 id="String-split-s-split-“-”"><a href="#String-split-s-split-“-”" class="headerlink" title="String[] _split= s.split(“,”);"></a><strong>String[] _split= s.split(“,”);</strong></h3><p> 把s 按逗号分离并分别保存到数组中_split</p>
<p><img src="https://viabcde.github.io/images/2018-09-27/2018092706.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092707.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092708.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092729.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092710.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092711.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092712.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092713.png" alt="enter description here"><br>区别 ：前者是动态绑定 即编译期间 d指向的是Object 的toString 方法<br>运行时d 指向的是传入的子类对象 的toString方法<br>而后者直接调用d的toString方法  </p>
<h3 id="判断c是否小写"><a href="#判断c是否小写" class="headerlink" title="判断c是否小写"></a><strong>判断c是否小写</strong></h3><p><img src="https://viabcde.github.io/images/2018-09-27/2018092714.png" alt="enter description here"><br>s.charAt(i) 取得s 第i-1个字符<br>s.subString(1,2);表示截取 第2到第3个字符<br>s.subString(2);表示截取第3个字符至结尾所有字符<br>s1+=s2 指的是 s1 s2   的内存都复制保存到第三个内存空间中（因为String是不可变的   所以只能把2个String复制到共同的内存空间） 再把s1的首地址指向第三个内存空间<br>效率较低 改进 用StringBuffer<br>枚举类型 规定只能选择使用的参数时哪几个 使用类名.属性来获取   比如游戏中定义方向只能上下左右四个方向<br><img src="https://viabcde.github.io/images/2018-09-27/2018092715.png" alt="enter description here"><br>用容器的原因<br>数组的长度不能增加 要扩展必须开辟另一空间 再把原来的数组复制过来<br><img src="https://viabcde.github.io/images/2018-09-27/2018092716.png" alt="enter description here"><br>使用多态的原因 因为c只能使用Collection接口中的方法   而不会使用子类ArrayList自己的方法<br>当更换子类LinkList时 不需要修改子类的自己方法 直接替换即可<br>这里的Name类没有重写equals方法 所以其equals方法比较的是首地址是否相同<br>很明显2个Name对象都是各自new 出来的 首地址不同 所以   remove时并不会把之前的Name对象移除<br> <img src="https://viabcde.github.io/images/2018-09-27/2018092717.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092718.png" alt="enter description here"><br><img src="https://viabcde.github.io/images/2018-09-27/2018092719.png" alt="enter description here"><br>utf8比较省空间<br>join 即把线程归并回主线程 当做方法使用   只有该线程执行完后才继续执行它下面的代码<br>yield 当前线程让其他线程执行一会<br><img src="https://viabcde.github.io/images/2018-09-27/2018092720.png" alt="enter description here"><br>网关 一边连着子网 替子网转发 一边连着公网上网<br>TCP必须有回复才发<br>UDP 发了不管    </p>
<h2 id="继承-2"><a href="#继承-2" class="headerlink" title="继承"></a><strong>继承</strong></h2><p> <img src="https://viabcde.github.io/images/blog/2018092801.png" alt="enter description here"></p>
<h2 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a><strong>接口实现</strong></h2><p> <img src="https://viabcde.github.io/images/blog/2018092802.png" alt="enter description here"></p>
<h2 id="关联-即A中引用了B"><a href="#关联-即A中引用了B" class="headerlink" title="关联 即A中引用了B"></a><strong>关联 即A中引用了B</strong></h2><p>!<img src="https://viabcde.github.io/images/blog/2018092803.png" alt="enter description here"></p>
<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a><strong>聚合</strong></h2><p><img src="https://viabcde.github.io/images/blog/2018092804.png" alt="enter description here"></p>
<h2 id="组合-对于-自身属性"><a href="#组合-对于-自身属性" class="headerlink" title="组合 对于 自身属性"></a><strong>组合 对于 自身属性</strong></h2><p><img src="https://viabcde.github.io/images/blog/2018092805.png" alt="enter description here"></p>
<h2 id="依赖-对于传入方法参数"><a href="#依赖-对于传入方法参数" class="headerlink" title="依赖  对于传入方法参数"></a><strong>依赖  对于传入方法参数</strong></h2><p><img src="https://viabcde.github.io/images/blog/2018092806.png" alt="enter description here"></p>
<h2 id="为什么尽量不去改动已有的代码"><a href="#为什么尽量不去改动已有的代码" class="headerlink" title="为什么尽量不去改动已有的代码"></a><strong>为什么尽量不去改动已有的代码</strong></h2><p>一是为了防止有些程序员恶意破坏<br>二是改了之后已有的代码还需要重新到各个机器编译安装一次  </p>
<h2 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a><strong>连接字符串</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s=&quot;a&quot;;</span><br><span class="line">s=s.concat(&quot;b&quot;);</span><br></pre></td></tr></table></figure>
<p>syso s=ab</p>
<h3 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a><strong>生成随机数</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int x=(int)(Math.random()*100);</span><br></pre></td></tr></table></figure>
<p>0-100  包括0 不包括100</p>
<h3 id="毫秒"><a href="#毫秒" class="headerlink" title="毫秒"></a><strong>毫秒</strong></h3><p>System.currentTimeMillis()  获取当前时间并转为毫秒数<br>System.currentTimeMillis() /1000 获取当前时间并转为秒数</p>
<h2 id="字符串常用的函数"><a href="#字符串常用的函数" class="headerlink" title="字符串常用的函数"></a><strong>字符串常用的函数</strong></h2><p>如果IDE没有代码自动补全功能，所以你应该记住下面的这些方法。<br>toCharArray() // 获得字符串对应的char数组<br>Arrays.sort() // 数组排序<br>Arrays.toString(char[] a) // 数组转成字符串<br>charAt(int x) // 获得某个索引处的字符<br>length() // 字符串长度<br>length // 数组大小</p>
<h3 id="随机产生26个字母中的20个-可重复"><a href="#随机产生26个字母中的20个-可重复" class="headerlink" title="随机产生26个字母中的20个 可重复"></a><strong>随机产生26个字母中的20个 可重复</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Set getChar()&#123;    </span><br><span class="line">        Set numberSet01 = new HashSet();   </span><br><span class="line">        Random rdm = new Random();   </span><br><span class="line">        char ch;   </span><br><span class="line">        while(numberSet01.size()&lt;20)&#123;    </span><br><span class="line">           int rdGet = Math.abs(rdm.nextInt())%26+97;//产生97到122的随机数a-z值   </span><br><span class="line">            ch=(char)rdGet;   </span><br><span class="line">            numberSet01.add(ch);   </span><br><span class="line">            //Set中是不能放进重复的值的，当它有20个时，就满足你的条件了    </span><br><span class="line">        &#125;    </span><br><span class="line">          return numberSet01;   </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="给定一个java-util-Date对象，如何转化为”2007-3-22-20-23-22”格式的字符串"><a href="#给定一个java-util-Date对象，如何转化为”2007-3-22-20-23-22”格式的字符串" class="headerlink" title="给定一个java.util.Date对象，如何转化为”2007-3-22 20:23:22”格式的字符串"></a><strong>给定一个java.util.Date对象，如何转化为”2007-3-22 20:23:22”格式的字符串</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String date2FormatStr(Date date)   </span><br><span class="line"> &#123;    </span><br><span class="line">   SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    </span><br><span class="line">   String str = sdf.format(date);    </span><br><span class="line">   return str;    </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断是否是一个数的因子"><a href="#判断是否是一个数的因子" class="headerlink" title="判断是否是一个数的因子"></a><strong>判断是否是一个数的因子</strong></h3><p>  //如果余数为0说明 该除数是被除数的因子<br>             if(i % j==0)</p>
<h3 id="弹出对话框并从中获取用户输入的值保存到str中"><a href="#弹出对话框并从中获取用户输入的值保存到str中" class="headerlink" title="弹出对话框并从中获取用户输入的值保存到str中"></a><strong>弹出对话框并从中获取用户输入的值保存到str中</strong></h3><p>String str=javax.swing.JOptionPane.showInputDialog(“请输入N的值（输入exit退出）：”);<br>//用到str的时候可以转换为相应的类型 如<br>int N=Integer.parseInt(str);</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="/music/1.mp3">
            </audio>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci="55316b017b800ec5c0da" data-cs="fbe9f4aafee144a34ec283ca34c833ad6da91507" data-r="talk" data-o="viacbde" data-a="viabcde" data-d="false">查看评论</div>


    </div>
    
        <div class="side">
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#反码-取反-补码"><span class="toc-number">1.</span> <span class="toc-text">反码 取反 补码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型"><span class="toc-number">2.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符相加"><span class="toc-number">3.</span> <span class="toc-text">字符相加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#强制转换为int"><span class="toc-number">4.</span> <span class="toc-text">强制转换为int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从控制台读取输入的内容"><span class="toc-number">5.</span> <span class="toc-text">从控制台读取输入的内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String转为float"><span class="toc-number">6.</span> <span class="toc-text">String转为float</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#打印菱形"><span class="toc-number">7.</span> <span class="toc-text">打印菱形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#何时会被当成垃圾回收"><span class="toc-number">8.</span> <span class="toc-text">何时会被当成垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#默认构造方法"><span class="toc-number">9.</span> <span class="toc-text">默认构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-number">10.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态变量"><span class="toc-number">11.</span> <span class="toc-text">静态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态方法"><span class="toc-number">12.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问权限"><span class="toc-number">13.</span> <span class="toc-text">访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#package的作用"><span class="toc-number">14.</span> <span class="toc-text">package的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#封装"><span class="toc-number">15.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-number">16.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态"><span class="toc-number">17.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态绑定（迟邦定）-多态"><span class="toc-number">18.</span> <span class="toc-text">动态绑定（迟邦定） 多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super-f"><span class="toc-number">19.</span> <span class="toc-text">super.f()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写和重载的区别？"><span class="toc-number">20.</span> <span class="toc-text">重写和重载的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类"><span class="toc-number">21.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口不能代替抽象类"><span class="toc-number">22.</span> <span class="toc-text">接口不能代替抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#符号运算"><span class="toc-number">23.</span> <span class="toc-text">符号运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList与Vector区别"><span class="toc-number">24.</span> <span class="toc-text">ArrayList与Vector区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历HashMap"><span class="toc-number">25.</span> <span class="toc-text">遍历HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap与HashTable区别"><span class="toc-number">26.</span> <span class="toc-text">HashMap与HashTable区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashMap是根据key的hashCode来寻找存放位置的，那当key为null时，-怎么存储呢？"><span class="toc-number">27.</span> <span class="toc-text">hashMap是根据key的hashCode来寻找存放位置的，那当key为null时， 怎么存储呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型"><span class="toc-number">28.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finally"><span class="toc-number">29.</span> <span class="toc-text">finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">30.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不同try用throws"><span class="toc-number">31.</span> <span class="toc-text">不同try用throws</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#冒泡排序"><span class="toc-number">32.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择排序"><span class="toc-number">33.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入排序"><span class="toc-number">34.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM内存管理-内存空间、内存分配、内存回收"><span class="toc-number">35.</span> <span class="toc-text">JVM内存管理(内存空间、内存分配、内存回收)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#那为什么要暂停来垃圾回收"><span class="toc-number">36.</span> <span class="toc-text">那为什么要暂停来垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绝对值"><span class="toc-number">37.</span> <span class="toc-text">绝对值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#awt与Swing"><span class="toc-number">38.</span> <span class="toc-text">awt与Swing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JFrame"><span class="toc-number">39.</span> <span class="toc-text">JFrame</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#边界布局"><span class="toc-number">40.</span> <span class="toc-text">边界布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#流式布局"><span class="toc-number">41.</span> <span class="toc-text">流式布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态导入"><span class="toc-number">42.</span> <span class="toc-text">静态导入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增强的for循环"><span class="toc-number">43.</span> <span class="toc-text">增强的for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#装箱、拆箱"><span class="toc-number">44.</span> <span class="toc-text">装箱、拆箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#享-元模式"><span class="toc-number">45.</span> <span class="toc-text">享 元模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取字节码的方法"><span class="toc-number">46.</span> <span class="toc-text">获取字节码的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取类的构造方法"><span class="toc-number">47.</span> <span class="toc-text">获取类的构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取类的属性"><span class="toc-number">48.</span> <span class="toc-text">获取类的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-和-i"><span class="toc-number">49.</span> <span class="toc-text">i++和++i</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-number">50.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java内存泄漏情况"><span class="toc-number">51.</span> <span class="toc-text">java内存泄漏情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equals和"><span class="toc-number">52.</span> <span class="toc-text">equals和==</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ip和端口"><span class="toc-number">53.</span> <span class="toc-text">ip和端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型相加"><span class="toc-number">54.</span> <span class="toc-text">数据类型相加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof-判断一个对象是否属于某个类的示例"><span class="toc-number">55.</span> <span class="toc-text">instanceof 判断一个对象是否属于某个类的示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承-1"><span class="toc-number">56.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#return"><span class="toc-number">57.</span> <span class="toc-text">return</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equals方法默认比较的是首地址-必须重写"><span class="toc-number">58.</span> <span class="toc-text">equals方法默认比较的是首地址 必须重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部变量系统不会自动初始化-成员变量才会"><span class="toc-number">59.</span> <span class="toc-text">局部变量系统不会自动初始化 成员变量才会</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-String-c-4-3"><span class="toc-number">60.</span> <span class="toc-text">new String(c,4,3);</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#s-indexof-“java”"><span class="toc-number">61.</span> <span class="toc-text">s.indexof(“java”)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-split-s-split-“-”"><span class="toc-number">62.</span> <span class="toc-text">String[] _split= s.split(“,”);</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断c是否小写"><span class="toc-number">63.</span> <span class="toc-text">判断c是否小写</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#继承-2"><span class="toc-number"></span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口实现"><span class="toc-number"></span> <span class="toc-text">接口实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关联-即A中引用了B"><span class="toc-number"></span> <span class="toc-text">关联 即A中引用了B</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#聚合"><span class="toc-number"></span> <span class="toc-text">聚合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组合-对于-自身属性"><span class="toc-number"></span> <span class="toc-text">组合 对于 自身属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#依赖-对于传入方法参数"><span class="toc-number"></span> <span class="toc-text">依赖  对于传入方法参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么尽量不去改动已有的代码"><span class="toc-number"></span> <span class="toc-text">为什么尽量不去改动已有的代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#连接字符串"><span class="toc-number"></span> <span class="toc-text">连接字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生成随机数"><span class="toc-number">1.</span> <span class="toc-text">生成随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#毫秒"><span class="toc-number">2.</span> <span class="toc-text">毫秒</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串常用的函数"><span class="toc-number"></span> <span class="toc-text">字符串常用的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#随机产生26个字母中的20个-可重复"><span class="toc-number">1.</span> <span class="toc-text">随机产生26个字母中的20个 可重复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#给定一个java-util-Date对象，如何转化为”2007-3-22-20-23-22”格式的字符串"><span class="toc-number">2.</span> <span class="toc-text">给定一个java.util.Date对象，如何转化为”2007-3-22 20:23:22”格式的字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断是否是一个数的因子"><span class="toc-number">3.</span> <span class="toc-text">判断是否是一个数的因子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#弹出对话框并从中获取用户输入的值保存到str中"><span class="toc-number">4.</span> <span class="toc-text">弹出对话框并从中获取用户输入的值保存到str中</span></a></li></ol>
        </li></div>
    
</div>


    </div>
</div>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>